use crate::parser::Token;

use super::{token::Precedence, Error, Parser, TokenType};

pub struct State<const N: usize>;

impl<const N: usize> State<N> {
    fn get_previous_binop<'a>(parser: &Parser<'a>) -> TokenType<'a> {
        let ord = &parser.stack[parser.stack.len() - 2];
        log::trace!("{:?}", ord);

        let Token {
            tokens: _,
            token_type: token,
        } = ord.tokens[0];
        log::trace!("{:?}", token);

        token
    }

    fn unimplemented_lookahead() -> Result<(), Error> {
        log::error!("State {N} has unimplemented lookahead.");
        Err(Error::Unimplemented)
    }
}
pub trait StateProcessor {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error>;
}

impl StateProcessor for State<0> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(4),
            TokenType::Do => parser.shift(5),
            TokenType::For => parser.shift(6),
            TokenType::Function => parser.shift(7),
            TokenType::Goto => parser.shift(8),
            TokenType::If => parser.shift(9),
            TokenType::Local => parser.shift(10),
            TokenType::Repeat => parser.shift(11),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(12),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(17),
            TokenType::SemiColon => parser.shift(13),
            TokenType::Eof => parser.reduce::<2>(),
            TokenType::Block => parser.goto(1),
            TokenType::BlockStat => parser.goto(2),
            TokenType::Stat => parser.goto(3),
            TokenType::Label => parser.goto(14),
            TokenType::Varlist => parser.goto(15),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(20),
            TokenType::Functioncall => parser.goto(16),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<0>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Return => parser.shift(49),
            TokenType::Eof => parser.reduce::<4>(),
            TokenType::BlockRetstat => parser.goto(22),
            TokenType::Retstat => parser.goto(23),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<3> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(4),
            TokenType::Do => parser.shift(5),
            TokenType::For => parser.shift(6),
            TokenType::Function => parser.shift(7),
            TokenType::Goto => parser.shift(8),
            TokenType::If => parser.shift(9),
            TokenType::Local => parser.shift(10),
            TokenType::Repeat => parser.shift(11),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(12),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(17),
            TokenType::SemiColon => parser.shift(13),
            TokenType::Eof => parser.reduce::<2>(),
            TokenType::BlockStat => parser.goto(43),
            TokenType::Stat => parser.goto(3),
            TokenType::Label => parser.goto(14),
            TokenType::Varlist => parser.goto(15),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(20),
            TokenType::Functioncall => parser.goto(16),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<4> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<10>(),
            TokenType::Break => parser.reduce::<10>(),
            TokenType::Do => parser.reduce::<10>(),
            TokenType::For => parser.reduce::<10>(),
            TokenType::Function => parser.reduce::<10>(),
            TokenType::Goto => parser.reduce::<10>(),
            TokenType::If => parser.reduce::<10>(),
            TokenType::Local => parser.reduce::<10>(),
            TokenType::Repeat => parser.reduce::<10>(),
            TokenType::Return => parser.reduce::<10>(),
            TokenType::While => parser.reduce::<10>(),
            TokenType::LParen => parser.reduce::<10>(),
            TokenType::DoubleColon => parser.reduce::<10>(),
            TokenType::SemiColon => parser.reduce::<10>(),
            TokenType::Eof => parser.reduce::<10>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<5> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(62),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<6> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(28),
            TokenType::Namelist => parser.goto(35),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<7> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(36),
            TokenType::Funcname => parser.goto(29),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<8> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(24),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<9> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(70),
            TokenType::String(_) => parser.shift(84),
            TokenType::Integer(_) => parser.shift(85),
            TokenType::Float(_) => parser.shift(86),
            TokenType::False => parser.shift(87),
            TokenType::Function => parser.shift(132),
            TokenType::Nil => parser.shift(88),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(89),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(123),
            TokenType::LCurly => parser.shift(134),
            TokenType::Dots => parser.shift(90),
            TokenType::Var => parser.goto(127),
            TokenType::Exp => parser.goto(44),
            TokenType::Prefixexp => parser.goto(71),
            TokenType::Functioncall => parser.goto(128),
            TokenType::Functiondef => parser.goto(96),
            TokenType::Tableconstructor => parser.goto(97),
            TokenType::Unop => parser.goto(103),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<10> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::Function => parser.shift(26),
            TokenType::Attnamelist => parser.goto(33),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<11> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(42),
            TokenType::Do => parser.shift(45),
            TokenType::For => parser.shift(59),
            TokenType::Function => parser.shift(60),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(66),
            TokenType::Local => parser.shift(98),
            TokenType::Repeat => parser.shift(100),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(104),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<12> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(67),
            TokenType::String(_) => parser.shift(77),
            TokenType::Integer(_) => parser.shift(78),
            TokenType::Float(_) => parser.shift(79),
            TokenType::False => parser.shift(80),
            TokenType::Function => parser.shift(133),
            TokenType::Nil => parser.shift(81),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(82),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(122),
            TokenType::LCurly => parser.shift(135),
            TokenType::Dots => parser.shift(83),
            TokenType::Var => parser.goto(129),
            TokenType::Exp => parser.goto(40),
            TokenType::Prefixexp => parser.goto(68),
            TokenType::Functioncall => parser.goto(130),
            TokenType::Functiondef => parser.goto(94),
            TokenType::Tableconstructor => parser.goto(95),
            TokenType::Unop => parser.goto(101),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<13> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<6>(),
            TokenType::Break => parser.reduce::<6>(),
            TokenType::Do => parser.reduce::<6>(),
            TokenType::For => parser.reduce::<6>(),
            TokenType::Function => parser.reduce::<6>(),
            TokenType::Goto => parser.reduce::<6>(),
            TokenType::If => parser.reduce::<6>(),
            TokenType::Local => parser.reduce::<6>(),
            TokenType::Repeat => parser.reduce::<6>(),
            TokenType::Return => parser.reduce::<6>(),
            TokenType::While => parser.reduce::<6>(),
            TokenType::LParen => parser.reduce::<6>(),
            TokenType::DoubleColon => parser.reduce::<6>(),
            TokenType::SemiColon => parser.reduce::<6>(),
            TokenType::Eof => parser.reduce::<6>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<14> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<9>(),
            TokenType::Break => parser.reduce::<9>(),
            TokenType::Do => parser.reduce::<9>(),
            TokenType::For => parser.reduce::<9>(),
            TokenType::Function => parser.reduce::<9>(),
            TokenType::Goto => parser.reduce::<9>(),
            TokenType::If => parser.reduce::<9>(),
            TokenType::Local => parser.reduce::<9>(),
            TokenType::Repeat => parser.reduce::<9>(),
            TokenType::Return => parser.reduce::<9>(),
            TokenType::While => parser.reduce::<9>(),
            TokenType::LParen => parser.reduce::<9>(),
            TokenType::DoubleColon => parser.reduce::<9>(),
            TokenType::SemiColon => parser.reduce::<9>(),
            TokenType::Eof => parser.reduce::<9>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<15> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(50),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<16> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<8>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<8>(),
            TokenType::Do => parser.reduce::<8>(),
            TokenType::For => parser.reduce::<8>(),
            TokenType::Function => parser.reduce::<8>(),
            TokenType::Goto => parser.reduce::<8>(),
            TokenType::If => parser.reduce::<8>(),
            TokenType::Local => parser.reduce::<8>(),
            TokenType::Repeat => parser.reduce::<8>(),
            TokenType::Return => parser.reduce::<8>(),
            TokenType::While => parser.reduce::<8>(),
            // Reduce(8)-Reduce(70)
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<8>(),
            TokenType::SemiColon => parser.reduce::<8>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Eof => parser.reduce::<8>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<17> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(31),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<18> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::Assign => parser.reduce::<46>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.shift(34),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::VarlistCont => parser.goto(30),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<19> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::Assign => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<20> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(75),
            TokenType::LParen => parser.shift(76),
            TokenType::LSquare => parser.shift(47),
            TokenType::LCurly => parser.shift(108),
            TokenType::Colon => parser.shift(73),
            TokenType::Dot => parser.shift(72),
            TokenType::Args => parser.goto(74),
            TokenType::Tableconstructor => parser.goto(107),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<21> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(58),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<22> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<1>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<23> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<5>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<24> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<11>(),
            TokenType::Break => parser.reduce::<11>(),
            TokenType::Do => parser.reduce::<11>(),
            TokenType::For => parser.reduce::<11>(),
            TokenType::Function => parser.reduce::<11>(),
            TokenType::Goto => parser.reduce::<11>(),
            TokenType::If => parser.reduce::<11>(),
            TokenType::Local => parser.reduce::<11>(),
            TokenType::Repeat => parser.reduce::<11>(),
            TokenType::Return => parser.reduce::<11>(),
            TokenType::While => parser.reduce::<11>(),
            TokenType::LParen => parser.reduce::<11>(),
            TokenType::DoubleColon => parser.reduce::<11>(),
            TokenType::SemiColon => parser.reduce::<11>(),
            TokenType::Eof => parser.reduce::<11>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<25> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<4>(),
            TokenType::Return => parser.shift(200),
            TokenType::BlockRetstat => parser.goto(142),
            TokenType::Retstat => parser.goto(143),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<26> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(146),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<27> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Return => parser.shift(201),
            TokenType::Until => parser.reduce::<4>(),
            TokenType::BlockRetstat => parser.goto(140),
            TokenType::Retstat => parser.goto(141),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<28> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<52>(),
            TokenType::Assign => parser.shift(199),
            TokenType::Comma => parser.shift(265),
            TokenType::NamelistCont => parser.goto(264),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<29> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(161),
            TokenType::Funcbody => parser.goto(145),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<30> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.reduce::<45>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<31> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::DoubleColon => parser.shift(149),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<32> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::RParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<33> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<27>(),
            TokenType::Break => parser.reduce::<27>(),
            TokenType::Do => parser.reduce::<27>(),
            TokenType::For => parser.reduce::<27>(),
            TokenType::Function => parser.reduce::<27>(),
            TokenType::Goto => parser.reduce::<27>(),
            TokenType::If => parser.reduce::<27>(),
            TokenType::Local => parser.reduce::<27>(),
            TokenType::Repeat => parser.reduce::<27>(),
            TokenType::Return => parser.reduce::<27>(),
            TokenType::While => parser.reduce::<27>(),
            TokenType::Assign => parser.shift(216),
            TokenType::LParen => parser.reduce::<27>(),
            TokenType::DoubleColon => parser.reduce::<27>(),
            TokenType::SemiColon => parser.reduce::<27>(),
            TokenType::Eof => parser.reduce::<27>(),
            TokenType::StatAttexplist => parser.goto(144),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<34> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::LParen => parser.shift(21),
            TokenType::Var => parser.goto(151),
            TokenType::Prefixexp => parser.goto(162),
            TokenType::Functioncall => parser.goto(244),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<35> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.shift(207),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<36> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<41>(),
            TokenType::Colon => parser.reduce::<41>(),
            TokenType::Dot => parser.shift(150),
            TokenType::FuncnameCont => parser.goto(148),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<37> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(170),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Eof => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(147),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<38> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(290),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.shift(296),
            TokenType::RParen => parser.reduce::<65>(),
            TokenType::LSquare => parser.shift(202),
            TokenType::LCurly => parser.shift(339),
            TokenType::Colon => parser.shift(288),
            TokenType::Dot => parser.shift(287),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(289),
            TokenType::Tableconstructor => parser.goto(338),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<39> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(42),
            TokenType::Do => parser.shift(45),
            TokenType::For => parser.shift(59),
            TokenType::Function => parser.shift(60),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(66),
            TokenType::Local => parser.shift(98),
            TokenType::Repeat => parser.shift(100),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::BlockStat => parser.goto(185),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<40> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Do => parser.shift(187),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(250),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<41> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::BlockStat => parser.goto(193),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<42> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<10>(),
            TokenType::Break => parser.reduce::<10>(),
            TokenType::Do => parser.reduce::<10>(),
            TokenType::For => parser.reduce::<10>(),
            TokenType::Function => parser.reduce::<10>(),
            TokenType::Goto => parser.reduce::<10>(),
            TokenType::If => parser.reduce::<10>(),
            TokenType::Local => parser.reduce::<10>(),
            TokenType::Repeat => parser.reduce::<10>(),
            TokenType::Return => parser.reduce::<10>(),
            TokenType::Until => parser.reduce::<10>(),
            TokenType::While => parser.reduce::<10>(),
            TokenType::LParen => parser.reduce::<10>(),
            TokenType::DoubleColon => parser.reduce::<10>(),
            TokenType::SemiColon => parser.reduce::<10>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<43> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Return => parser.reduce::<3>(),
            TokenType::Eof => parser.reduce::<3>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<44> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Then => parser.shift(192),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(252),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<45> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(225),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<46> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<10>(),
            TokenType::Break => parser.reduce::<10>(),
            TokenType::Do => parser.reduce::<10>(),
            TokenType::End => parser.reduce::<10>(),
            TokenType::For => parser.reduce::<10>(),
            TokenType::Function => parser.reduce::<10>(),
            TokenType::Goto => parser.reduce::<10>(),
            TokenType::If => parser.reduce::<10>(),
            TokenType::Local => parser.reduce::<10>(),
            TokenType::Repeat => parser.reduce::<10>(),
            TokenType::Return => parser.reduce::<10>(),
            TokenType::While => parser.reduce::<10>(),
            TokenType::LParen => parser.reduce::<10>(),
            TokenType::DoubleColon => parser.reduce::<10>(),
            TokenType::SemiColon => parser.reduce::<10>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<47> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(212),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<48> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(213),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<49> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(156),
            TokenType::String(_) => parser.shift(239),
            TokenType::Integer(_) => parser.shift(240),
            TokenType::Float(_) => parser.shift(241),
            TokenType::False => parser.shift(242),
            TokenType::Function => parser.shift(344),
            TokenType::Nil => parser.shift(243),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(334),
            TokenType::LCurly => parser.shift(345),
            TokenType::SemiColon => parser.reduce::<35>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Eof => parser.reduce::<35>(),
            TokenType::RetstatExplist => parser.goto(153),
            TokenType::Var => parser.goto(342),
            TokenType::Explist => parser.goto(155),
            TokenType::Exp => parser.goto(238),
            TokenType::Prefixexp => parser.goto(175),
            TokenType::Functioncall => parser.goto(343),
            TokenType::Functiondef => parser.goto(274),
            TokenType::Tableconstructor => parser.goto(275),
            TokenType::Unop => parser.goto(282),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<50> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(171),
            TokenType::String(_) => parser.shift(273),
            TokenType::Integer(_) => parser.shift(276),
            TokenType::Float(_) => parser.shift(277),
            TokenType::False => parser.shift(278),
            TokenType::Function => parser.shift(370),
            TokenType::Nil => parser.shift(279),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(280),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(366),
            TokenType::LCurly => parser.shift(371),
            TokenType::Dots => parser.shift(281),
            TokenType::Var => parser.goto(368),
            TokenType::Explist => parser.goto(154),
            TokenType::Exp => parser.goto(255),
            TokenType::Prefixexp => parser.goto(186),
            TokenType::Functioncall => parser.goto(369),
            TokenType::Functiondef => parser.goto(329),
            TokenType::Tableconstructor => parser.goto(330),
            TokenType::Unop => parser.goto(331),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<51> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::RParen => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<52> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::RParen => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<53> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::RParen => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<54> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::RParen => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<55> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::RParen => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<56> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::RParen => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<57> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::RParen => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<58> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(299),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<59> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(158),
            TokenType::Namelist => parser.goto(173),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<60> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(36),
            TokenType::Funcname => parser.goto(163),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<61> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(157),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<62> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(159),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<63> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(168),
            TokenType::Namelist => parser.goto(169),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<64> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(36),
            TokenType::Funcname => parser.goto(166),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<65> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<66> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(70),
            TokenType::String(_) => parser.shift(84),
            TokenType::Integer(_) => parser.shift(85),
            TokenType::Float(_) => parser.shift(86),
            TokenType::False => parser.shift(87),
            TokenType::Function => parser.shift(132),
            TokenType::Nil => parser.shift(88),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(89),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(123),
            TokenType::LCurly => parser.shift(134),
            TokenType::Dots => parser.shift(90),
            TokenType::Var => parser.goto(127),
            TokenType::Exp => parser.goto(190),
            TokenType::Prefixexp => parser.goto(71),
            TokenType::Functioncall => parser.goto(128),
            TokenType::Functiondef => parser.goto(96),
            TokenType::Tableconstructor => parser.goto(97),
            TokenType::Unop => parser.goto(103),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<67> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<68> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(325),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.shift(328),
            TokenType::LSquare => parser.shift(203),
            TokenType::LCurly => parser.shift(341),
            TokenType::Colon => parser.shift(323),
            TokenType::Dot => parser.shift(322),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(324),
            TokenType::Tableconstructor => parser.goto(340),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<69> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(70),
            TokenType::String(_) => parser.shift(84),
            TokenType::Integer(_) => parser.shift(85),
            TokenType::Float(_) => parser.shift(86),
            TokenType::False => parser.shift(87),
            TokenType::Function => parser.shift(132),
            TokenType::Nil => parser.shift(88),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(89),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(123),
            TokenType::LCurly => parser.shift(134),
            TokenType::Dots => parser.shift(90),
            TokenType::Var => parser.goto(127),
            TokenType::Exp => parser.goto(188),
            TokenType::Prefixexp => parser.goto(71),
            TokenType::Functioncall => parser.goto(128),
            TokenType::Functiondef => parser.goto(96),
            TokenType::Tableconstructor => parser.goto(97),
            TokenType::Unop => parser.goto(103),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<70> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Then => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<71> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(294),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Then => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.shift(298),
            TokenType::LSquare => parser.shift(208),
            TokenType::LCurly => parser.shift(335),
            TokenType::Colon => parser.shift(292),
            TokenType::Dot => parser.shift(291),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(293),
            TokenType::Tableconstructor => parser.goto(333),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<72> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(165),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<73> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(167),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<74> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Eof => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<75> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Eof => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<76> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(348),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<77> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<78> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<79> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<80> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<81> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<82> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<83> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<84> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Then => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<85> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Then => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<86> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Then => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<87> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Then => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<88> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Then => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<89> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Then => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<90> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Then => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<91> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::RParen => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<92> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::RParen => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<93> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(237),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<94> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<95> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<96> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Then => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<97> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Then => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<98> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(191),
            TokenType::Function => parser.shift(174),
            TokenType::Attnamelist => parser.goto(181),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<99> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(194),
            TokenType::Function => parser.shift(183),
            TokenType::Attnamelist => parser.goto(184),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<100> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(42),
            TokenType::Do => parser.shift(45),
            TokenType::For => parser.shift(59),
            TokenType::Function => parser.shift(60),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(66),
            TokenType::Local => parser.shift(98),
            TokenType::Repeat => parser.shift(100),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(326),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<101> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(67),
            TokenType::String(_) => parser.shift(77),
            TokenType::Integer(_) => parser.shift(78),
            TokenType::Float(_) => parser.shift(79),
            TokenType::False => parser.shift(80),
            TokenType::Function => parser.shift(133),
            TokenType::Nil => parser.shift(81),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(82),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(122),
            TokenType::LCurly => parser.shift(135),
            TokenType::Dots => parser.shift(83),
            TokenType::Var => parser.goto(129),
            TokenType::Exp => parser.goto(210),
            TokenType::Prefixexp => parser.goto(68),
            TokenType::Functioncall => parser.goto(130),
            TokenType::Functiondef => parser.goto(94),
            TokenType::Tableconstructor => parser.goto(95),
            TokenType::Unop => parser.goto(101),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<102> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(42),
            TokenType::Do => parser.shift(45),
            TokenType::For => parser.shift(59),
            TokenType::Function => parser.shift(60),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(66),
            TokenType::Local => parser.shift(98),
            TokenType::Repeat => parser.shift(100),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(283),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<103> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(70),
            TokenType::String(_) => parser.shift(84),
            TokenType::Integer(_) => parser.shift(85),
            TokenType::Float(_) => parser.shift(86),
            TokenType::False => parser.shift(87),
            TokenType::Function => parser.shift(132),
            TokenType::Nil => parser.shift(88),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(89),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(123),
            TokenType::LCurly => parser.shift(134),
            TokenType::Dots => parser.shift(90),
            TokenType::Var => parser.goto(127),
            TokenType::Exp => parser.goto(235),
            TokenType::Prefixexp => parser.goto(71),
            TokenType::Functioncall => parser.goto(128),
            TokenType::Functiondef => parser.goto(96),
            TokenType::Tableconstructor => parser.goto(97),
            TokenType::Unop => parser.goto(103),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<104> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.shift(224),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<105> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(67),
            TokenType::String(_) => parser.shift(77),
            TokenType::Integer(_) => parser.shift(78),
            TokenType::Float(_) => parser.shift(79),
            TokenType::False => parser.shift(80),
            TokenType::Function => parser.shift(133),
            TokenType::Nil => parser.shift(81),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(82),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(122),
            TokenType::LCurly => parser.shift(135),
            TokenType::Dots => parser.shift(83),
            TokenType::Var => parser.goto(129),
            TokenType::Exp => parser.goto(206),
            TokenType::Prefixexp => parser.goto(68),
            TokenType::Functioncall => parser.goto(130),
            TokenType::Functiondef => parser.goto(94),
            TokenType::Tableconstructor => parser.goto(95),
            TokenType::Unop => parser.goto(101),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<106> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(67),
            TokenType::String(_) => parser.shift(77),
            TokenType::Integer(_) => parser.shift(78),
            TokenType::Float(_) => parser.shift(79),
            TokenType::False => parser.shift(80),
            TokenType::Function => parser.shift(133),
            TokenType::Nil => parser.shift(81),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(82),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(122),
            TokenType::LCurly => parser.shift(135),
            TokenType::Dots => parser.shift(83),
            TokenType::Var => parser.goto(129),
            TokenType::Exp => parser.goto(205),
            TokenType::Prefixexp => parser.goto(68),
            TokenType::Functioncall => parser.goto(130),
            TokenType::Functiondef => parser.goto(94),
            TokenType::Tableconstructor => parser.goto(95),
            TokenType::Unop => parser.goto(101),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<107> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Eof => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<108> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(360),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<109> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<6>(),
            TokenType::Break => parser.reduce::<6>(),
            TokenType::Do => parser.reduce::<6>(),
            TokenType::For => parser.reduce::<6>(),
            TokenType::Function => parser.reduce::<6>(),
            TokenType::Goto => parser.reduce::<6>(),
            TokenType::If => parser.reduce::<6>(),
            TokenType::Local => parser.reduce::<6>(),
            TokenType::Repeat => parser.reduce::<6>(),
            TokenType::Return => parser.reduce::<6>(),
            TokenType::Until => parser.reduce::<6>(),
            TokenType::While => parser.reduce::<6>(),
            TokenType::LParen => parser.reduce::<6>(),
            TokenType::DoubleColon => parser.reduce::<6>(),
            TokenType::SemiColon => parser.reduce::<6>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<110> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<9>(),
            TokenType::Break => parser.reduce::<9>(),
            TokenType::Do => parser.reduce::<9>(),
            TokenType::For => parser.reduce::<9>(),
            TokenType::Function => parser.reduce::<9>(),
            TokenType::Goto => parser.reduce::<9>(),
            TokenType::If => parser.reduce::<9>(),
            TokenType::Local => parser.reduce::<9>(),
            TokenType::Repeat => parser.reduce::<9>(),
            TokenType::Return => parser.reduce::<9>(),
            TokenType::Until => parser.reduce::<9>(),
            TokenType::While => parser.reduce::<9>(),
            TokenType::LParen => parser.reduce::<9>(),
            TokenType::DoubleColon => parser.reduce::<9>(),
            TokenType::SemiColon => parser.reduce::<9>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<111> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(209),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<112> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<8>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<8>(),
            TokenType::Do => parser.reduce::<8>(),
            TokenType::For => parser.reduce::<8>(),
            TokenType::Function => parser.reduce::<8>(),
            TokenType::Goto => parser.reduce::<8>(),
            TokenType::If => parser.reduce::<8>(),
            TokenType::Local => parser.reduce::<8>(),
            TokenType::Repeat => parser.reduce::<8>(),
            TokenType::Return => parser.reduce::<8>(),
            TokenType::Until => parser.reduce::<8>(),
            TokenType::While => parser.reduce::<8>(),
            // Reduce(8)-Reduce(70)
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<8>(),
            TokenType::SemiColon => parser.reduce::<8>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<113> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(179),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<114> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(249),
            TokenType::LParen => parser.shift(251),
            TokenType::LSquare => parser.shift(47),
            TokenType::LCurly => parser.shift(297),
            TokenType::Colon => parser.shift(247),
            TokenType::Dot => parser.shift(72),
            TokenType::Args => parser.goto(248),
            TokenType::Tableconstructor => parser.goto(295),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<115> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<6>(),
            TokenType::Break => parser.reduce::<6>(),
            TokenType::Do => parser.reduce::<6>(),
            TokenType::End => parser.reduce::<6>(),
            TokenType::For => parser.reduce::<6>(),
            TokenType::Function => parser.reduce::<6>(),
            TokenType::Goto => parser.reduce::<6>(),
            TokenType::If => parser.reduce::<6>(),
            TokenType::Local => parser.reduce::<6>(),
            TokenType::Repeat => parser.reduce::<6>(),
            TokenType::Return => parser.reduce::<6>(),
            TokenType::While => parser.reduce::<6>(),
            TokenType::LParen => parser.reduce::<6>(),
            TokenType::DoubleColon => parser.reduce::<6>(),
            TokenType::SemiColon => parser.reduce::<6>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<116> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<9>(),
            TokenType::Break => parser.reduce::<9>(),
            TokenType::Do => parser.reduce::<9>(),
            TokenType::End => parser.reduce::<9>(),
            TokenType::For => parser.reduce::<9>(),
            TokenType::Function => parser.reduce::<9>(),
            TokenType::Goto => parser.reduce::<9>(),
            TokenType::If => parser.reduce::<9>(),
            TokenType::Local => parser.reduce::<9>(),
            TokenType::Repeat => parser.reduce::<9>(),
            TokenType::Return => parser.reduce::<9>(),
            TokenType::While => parser.reduce::<9>(),
            TokenType::LParen => parser.reduce::<9>(),
            TokenType::DoubleColon => parser.reduce::<9>(),
            TokenType::SemiColon => parser.reduce::<9>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<117> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(211),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<118> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<8>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<8>(),
            TokenType::Do => parser.reduce::<8>(),
            TokenType::End => parser.reduce::<8>(),
            TokenType::For => parser.reduce::<8>(),
            TokenType::Function => parser.reduce::<8>(),
            TokenType::Goto => parser.reduce::<8>(),
            TokenType::If => parser.reduce::<8>(),
            TokenType::Local => parser.reduce::<8>(),
            TokenType::Repeat => parser.reduce::<8>(),
            TokenType::Return => parser.reduce::<8>(),
            TokenType::While => parser.reduce::<8>(),
            // Reduce(8)-Reduce(70)
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<8>(),
            TokenType::SemiColon => parser.reduce::<8>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<119> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(178),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<120> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(263),
            TokenType::LParen => parser.shift(266),
            TokenType::LSquare => parser.shift(47),
            TokenType::LCurly => parser.shift(327),
            TokenType::Colon => parser.shift(261),
            TokenType::Dot => parser.shift(72),
            TokenType::Args => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(321),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<121> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(221),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<122> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(236),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<123> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(228),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<124> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::RParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<125> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::RParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<126> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(182),
            TokenType::Funcbody => parser.goto(180),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<127> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Then => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<128> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Then => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<129> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<130> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<131> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(365),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<132> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(197),
            TokenType::Funcbody => parser.goto(195),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<133> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(198),
            TokenType::Funcbody => parser.goto(196),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<134> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(364),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<135> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(367),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<136> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<121>(),
            TokenType::String(_) => parser.reduce::<121>(),
            TokenType::Integer(_) => parser.reduce::<121>(),
            TokenType::Float(_) => parser.reduce::<121>(),
            TokenType::False => parser.reduce::<121>(),
            TokenType::Function => parser.reduce::<121>(),
            TokenType::Nil => parser.reduce::<121>(),
            TokenType::Not => parser.reduce::<121>(),
            TokenType::True => parser.reduce::<121>(),
            TokenType::Sub => parser.reduce::<121>(),
            TokenType::Len => parser.reduce::<121>(),
            TokenType::BitXor => parser.reduce::<121>(),
            TokenType::LParen => parser.reduce::<121>(),
            TokenType::LCurly => parser.reduce::<121>(),
            TokenType::Dots => parser.reduce::<121>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<137> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<123>(),
            TokenType::String(_) => parser.reduce::<123>(),
            TokenType::Integer(_) => parser.reduce::<123>(),
            TokenType::Float(_) => parser.reduce::<123>(),
            TokenType::False => parser.reduce::<123>(),
            TokenType::Function => parser.reduce::<123>(),
            TokenType::Nil => parser.reduce::<123>(),
            TokenType::Not => parser.reduce::<123>(),
            TokenType::True => parser.reduce::<123>(),
            TokenType::Sub => parser.reduce::<123>(),
            TokenType::Len => parser.reduce::<123>(),
            TokenType::BitXor => parser.reduce::<123>(),
            TokenType::LParen => parser.reduce::<123>(),
            TokenType::LCurly => parser.reduce::<123>(),
            TokenType::Dots => parser.reduce::<123>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<138> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<122>(),
            TokenType::String(_) => parser.reduce::<122>(),
            TokenType::Integer(_) => parser.reduce::<122>(),
            TokenType::Float(_) => parser.reduce::<122>(),
            TokenType::False => parser.reduce::<122>(),
            TokenType::Function => parser.reduce::<122>(),
            TokenType::Nil => parser.reduce::<122>(),
            TokenType::Not => parser.reduce::<122>(),
            TokenType::True => parser.reduce::<122>(),
            TokenType::Sub => parser.reduce::<122>(),
            TokenType::Len => parser.reduce::<122>(),
            TokenType::BitXor => parser.reduce::<122>(),
            TokenType::LParen => parser.reduce::<122>(),
            TokenType::LCurly => parser.reduce::<122>(),
            TokenType::Dots => parser.reduce::<122>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<139> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<124>(),
            TokenType::String(_) => parser.reduce::<124>(),
            TokenType::Integer(_) => parser.reduce::<124>(),
            TokenType::Float(_) => parser.reduce::<124>(),
            TokenType::False => parser.reduce::<124>(),
            TokenType::Function => parser.reduce::<124>(),
            TokenType::Nil => parser.reduce::<124>(),
            TokenType::Not => parser.reduce::<124>(),
            TokenType::True => parser.reduce::<124>(),
            TokenType::Sub => parser.reduce::<124>(),
            TokenType::Len => parser.reduce::<124>(),
            TokenType::BitXor => parser.reduce::<124>(),
            TokenType::LParen => parser.reduce::<124>(),
            TokenType::LCurly => parser.reduce::<124>(),
            TokenType::Dots => parser.reduce::<124>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<140> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<1>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<141> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<5>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<142> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<1>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<143> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<5>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<144> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<26>(),
            TokenType::Break => parser.reduce::<26>(),
            TokenType::Do => parser.reduce::<26>(),
            TokenType::For => parser.reduce::<26>(),
            TokenType::Function => parser.reduce::<26>(),
            TokenType::Goto => parser.reduce::<26>(),
            TokenType::If => parser.reduce::<26>(),
            TokenType::Local => parser.reduce::<26>(),
            TokenType::Repeat => parser.reduce::<26>(),
            TokenType::Return => parser.reduce::<26>(),
            TokenType::While => parser.reduce::<26>(),
            TokenType::LParen => parser.reduce::<26>(),
            TokenType::DoubleColon => parser.reduce::<26>(),
            TokenType::SemiColon => parser.reduce::<26>(),
            TokenType::Eof => parser.reduce::<26>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<145> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<24>(),
            TokenType::Break => parser.reduce::<24>(),
            TokenType::Do => parser.reduce::<24>(),
            TokenType::For => parser.reduce::<24>(),
            TokenType::Function => parser.reduce::<24>(),
            TokenType::Goto => parser.reduce::<24>(),
            TokenType::If => parser.reduce::<24>(),
            TokenType::Local => parser.reduce::<24>(),
            TokenType::Repeat => parser.reduce::<24>(),
            TokenType::Return => parser.reduce::<24>(),
            TokenType::While => parser.reduce::<24>(),
            TokenType::LParen => parser.reduce::<24>(),
            TokenType::DoubleColon => parser.reduce::<24>(),
            TokenType::SemiColon => parser.reduce::<24>(),
            TokenType::Eof => parser.reduce::<24>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<146> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(161),
            TokenType::Funcbody => parser.goto(373),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<147> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(409),
            TokenType::Eof => parser.reduce::<30>(),
            TokenType::AttnamelistCont => parser.goto(372),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<148> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<43>(),
            TokenType::Colon => parser.shift(378),
            TokenType::FuncnameEnd => parser.goto(374),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<149> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<39>(),
            TokenType::Break => parser.reduce::<39>(),
            TokenType::Do => parser.reduce::<39>(),
            TokenType::For => parser.reduce::<39>(),
            TokenType::Function => parser.reduce::<39>(),
            TokenType::Goto => parser.reduce::<39>(),
            TokenType::If => parser.reduce::<39>(),
            TokenType::Local => parser.reduce::<39>(),
            TokenType::Repeat => parser.reduce::<39>(),
            TokenType::Return => parser.reduce::<39>(),
            TokenType::While => parser.reduce::<39>(),
            TokenType::LParen => parser.reduce::<39>(),
            TokenType::DoubleColon => parser.reduce::<39>(),
            TokenType::SemiColon => parser.reduce::<39>(),
            TokenType::Eof => parser.reduce::<39>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<150> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<151> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::Assign => parser.reduce::<46>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.shift(34),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::VarlistCont => parser.goto(385),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<152> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::RSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<153> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::SemiColon => parser.shift(377),
            TokenType::Eof => parser.reduce::<37>(),
            TokenType::RetstatEnd => parser.goto(375),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<154> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<7>(),
            TokenType::Break => parser.reduce::<7>(),
            TokenType::Do => parser.reduce::<7>(),
            TokenType::For => parser.reduce::<7>(),
            TokenType::Function => parser.reduce::<7>(),
            TokenType::Goto => parser.reduce::<7>(),
            TokenType::If => parser.reduce::<7>(),
            TokenType::Local => parser.reduce::<7>(),
            TokenType::Repeat => parser.reduce::<7>(),
            TokenType::Return => parser.reduce::<7>(),
            TokenType::While => parser.reduce::<7>(),
            TokenType::LParen => parser.reduce::<7>(),
            TokenType::DoubleColon => parser.reduce::<7>(),
            TokenType::SemiColon => parser.reduce::<7>(),
            TokenType::Eof => parser.reduce::<7>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<155> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::SemiColon => parser.reduce::<36>(),
            TokenType::Eof => parser.reduce::<36>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<156> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            TokenType::Eof => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<157> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<11>(),
            TokenType::Break => parser.reduce::<11>(),
            TokenType::Do => parser.reduce::<11>(),
            TokenType::For => parser.reduce::<11>(),
            TokenType::Function => parser.reduce::<11>(),
            TokenType::Goto => parser.reduce::<11>(),
            TokenType::If => parser.reduce::<11>(),
            TokenType::Local => parser.reduce::<11>(),
            TokenType::Repeat => parser.reduce::<11>(),
            TokenType::Return => parser.reduce::<11>(),
            TokenType::Until => parser.reduce::<11>(),
            TokenType::While => parser.reduce::<11>(),
            TokenType::LParen => parser.reduce::<11>(),
            TokenType::DoubleColon => parser.reduce::<11>(),
            TokenType::SemiColon => parser.reduce::<11>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<158> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<52>(),
            TokenType::Assign => parser.shift(455),
            TokenType::Comma => parser.shift(265),
            TokenType::NamelistCont => parser.goto(264),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<159> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<12>(),
            TokenType::Break => parser.reduce::<12>(),
            TokenType::Do => parser.reduce::<12>(),
            TokenType::For => parser.reduce::<12>(),
            TokenType::Function => parser.reduce::<12>(),
            TokenType::Goto => parser.reduce::<12>(),
            TokenType::If => parser.reduce::<12>(),
            TokenType::Local => parser.reduce::<12>(),
            TokenType::Repeat => parser.reduce::<12>(),
            TokenType::Return => parser.reduce::<12>(),
            TokenType::While => parser.reduce::<12>(),
            TokenType::LParen => parser.reduce::<12>(),
            TokenType::DoubleColon => parser.reduce::<12>(),
            TokenType::SemiColon => parser.reduce::<12>(),
            TokenType::Eof => parser.reduce::<12>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<160> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<11>(),
            TokenType::Break => parser.reduce::<11>(),
            TokenType::Do => parser.reduce::<11>(),
            TokenType::End => parser.reduce::<11>(),
            TokenType::For => parser.reduce::<11>(),
            TokenType::Function => parser.reduce::<11>(),
            TokenType::Goto => parser.reduce::<11>(),
            TokenType::If => parser.reduce::<11>(),
            TokenType::Local => parser.reduce::<11>(),
            TokenType::Repeat => parser.reduce::<11>(),
            TokenType::Return => parser.reduce::<11>(),
            TokenType::While => parser.reduce::<11>(),
            TokenType::LParen => parser.reduce::<11>(),
            TokenType::DoubleColon => parser.reduce::<11>(),
            TokenType::SemiColon => parser.reduce::<11>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<161> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(380),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<162> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(498),
            TokenType::LParen => parser.shift(513),
            TokenType::LSquare => parser.shift(47),
            TokenType::LCurly => parser.shift(551),
            TokenType::Colon => parser.shift(495),
            TokenType::Dot => parser.shift(72),
            TokenType::Args => parser.goto(496),
            TokenType::Tableconstructor => parser.goto(550),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<163> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(395),
            TokenType::Funcbody => parser.goto(379),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<164> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::RParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<165> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::Assign => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<166> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(392),
            TokenType::Funcbody => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<167> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(75),
            TokenType::LParen => parser.shift(76),
            TokenType::LCurly => parser.shift(108),
            TokenType::Args => parser.goto(383),
            TokenType::Tableconstructor => parser.goto(107),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<168> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<52>(),
            TokenType::Assign => parser.shift(458),
            TokenType::Comma => parser.shift(265),
            TokenType::NamelistCont => parser.goto(264),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<169> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.shift(466),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<170> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(381),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<171> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            TokenType::Eof => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<172> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(587),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.shift(589),
            TokenType::RParen => parser.reduce::<65>(),
            TokenType::LSquare => parser.shift(457),
            TokenType::LCurly => parser.shift(629),
            TokenType::Colon => parser.shift(585),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Dot => parser.shift(584),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(586),
            TokenType::Tableconstructor => parser.goto(627),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<173> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.shift(464),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<174> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(384),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<175> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(580),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.shift(588),
            TokenType::LSquare => parser.shift(465),
            TokenType::LCurly => parser.shift(644),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Colon => parser.shift(577),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Dot => parser.shift(575),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Eof => parser.reduce::<65>(),
            TokenType::Args => parser.goto(579),
            TokenType::Tableconstructor => parser.goto(643),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<176> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(605),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.shift(606),
            TokenType::LSquare => parser.shift(454),
            TokenType::RSquare => parser.reduce::<65>(),
            TokenType::LCurly => parser.shift(641),
            TokenType::Colon => parser.shift(603),
            TokenType::Dot => parser.shift(602),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(604),
            TokenType::Tableconstructor => parser.goto(638),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<177> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::Assign => parser.shift(447),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::RCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<178> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::DoubleColon => parser.shift(386),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<179> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::DoubleColon => parser.shift(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<180> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::RParen => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<181> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<27>(),
            TokenType::Break => parser.reduce::<27>(),
            TokenType::Do => parser.reduce::<27>(),
            TokenType::For => parser.reduce::<27>(),
            TokenType::Function => parser.reduce::<27>(),
            TokenType::Goto => parser.reduce::<27>(),
            TokenType::If => parser.reduce::<27>(),
            TokenType::Local => parser.reduce::<27>(),
            TokenType::Repeat => parser.reduce::<27>(),
            TokenType::Return => parser.reduce::<27>(),
            TokenType::Until => parser.reduce::<27>(),
            TokenType::While => parser.reduce::<27>(),
            TokenType::Assign => parser.shift(478),
            TokenType::LParen => parser.reduce::<27>(),
            TokenType::DoubleColon => parser.reduce::<27>(),
            TokenType::SemiColon => parser.reduce::<27>(),
            TokenType::StatAttexplist => parser.goto(387),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<182> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(389),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<183> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(390),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<184> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<27>(),
            TokenType::Break => parser.reduce::<27>(),
            TokenType::Do => parser.reduce::<27>(),
            TokenType::End => parser.reduce::<27>(),
            TokenType::For => parser.reduce::<27>(),
            TokenType::Function => parser.reduce::<27>(),
            TokenType::Goto => parser.reduce::<27>(),
            TokenType::If => parser.reduce::<27>(),
            TokenType::Local => parser.reduce::<27>(),
            TokenType::Repeat => parser.reduce::<27>(),
            TokenType::Return => parser.reduce::<27>(),
            TokenType::While => parser.reduce::<27>(),
            TokenType::Assign => parser.shift(472),
            TokenType::LParen => parser.reduce::<27>(),
            TokenType::DoubleColon => parser.reduce::<27>(),
            TokenType::SemiColon => parser.reduce::<27>(),
            TokenType::StatAttexplist => parser.goto(391),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<185> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Return => parser.reduce::<3>(),
            TokenType::Until => parser.reduce::<3>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<186> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::String(_) => parser.shift(616),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            // Shift(617)-Reduce(65)
            TokenType::LParen => parser.shift(617),
            TokenType::LSquare => parser.shift(462),
            TokenType::LCurly => parser.shift(642),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Colon => parser.shift(614),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Dot => parser.shift(613),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Eof => parser.reduce::<65>(),
            TokenType::Args => parser.goto(615),
            TokenType::Tableconstructor => parser.goto(640),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<187> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(618),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<188> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Then => parser.shift(441),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(252),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<189> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(594),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.shift(598),
            TokenType::LSquare => parser.shift(461),
            TokenType::LCurly => parser.shift(639),
            TokenType::RCurly => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Colon => parser.shift(592),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Dot => parser.shift(591),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(593),
            TokenType::Tableconstructor => parser.goto(637),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<190> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Then => parser.shift(449),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(252),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<191> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::Until => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(414),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(402),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<192> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(468),
            TokenType::Do => parser.shift(484),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(502),
            TokenType::Function => parser.shift(505),
            TokenType::Goto => parser.shift(506),
            TokenType::If => parser.shift(528),
            TokenType::Local => parser.shift(578),
            TokenType::Repeat => parser.shift(582),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(597),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(626),
            TokenType::SemiColon => parser.shift(622),
            TokenType::Block => parser.goto(576),
            TokenType::BlockStat => parser.goto(396),
            TokenType::Stat => parser.goto(420),
            TokenType::Label => parser.goto(623),
            TokenType::Varlist => parser.goto(624),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(628),
            TokenType::Functioncall => parser.goto(625),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<193> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<3>(),
            TokenType::Return => parser.reduce::<3>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<194> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::End => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(412),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(399),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<195> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Then => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<196> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<197> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(397),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<198> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(400),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<199> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(490),
            TokenType::String(_) => parser.shift(536),
            TokenType::Integer(_) => parser.shift(538),
            TokenType::Float(_) => parser.shift(539),
            TokenType::False => parser.shift(542),
            TokenType::Function => parser.shift(657),
            TokenType::Nil => parser.shift(544),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(546),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(646),
            TokenType::LCurly => parser.shift(658),
            TokenType::Dots => parser.shift(547),
            TokenType::Var => parser.goto(655),
            TokenType::Exp => parser.goto(423),
            TokenType::Prefixexp => parser.goto(494),
            TokenType::Functioncall => parser.goto(656),
            TokenType::Functiondef => parser.goto(600),
            TokenType::Tableconstructor => parser.goto(601),
            TokenType::Unop => parser.goto(607),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<200> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(408),
            TokenType::String(_) => parser.shift(531),
            TokenType::Integer(_) => parser.shift(532),
            TokenType::Float(_) => parser.shift(534),
            TokenType::End => parser.reduce::<35>(),
            TokenType::False => parser.shift(535),
            TokenType::Function => parser.shift(662),
            TokenType::Nil => parser.shift(540),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(543),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(647),
            TokenType::LCurly => parser.shift(663),
            TokenType::SemiColon => parser.reduce::<35>(),
            TokenType::Dots => parser.shift(545),
            TokenType::RetstatExplist => parser.goto(403),
            TokenType::Var => parser.goto(659),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(526),
            TokenType::Prefixexp => parser.goto(422),
            TokenType::Functioncall => parser.goto(660),
            TokenType::Functiondef => parser.goto(608),
            TokenType::Tableconstructor => parser.goto(610),
            TokenType::Unop => parser.goto(612),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<201> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(407),
            TokenType::String(_) => parser.shift(501),
            TokenType::Integer(_) => parser.shift(503),
            TokenType::Float(_) => parser.shift(504),
            TokenType::False => parser.shift(507),
            TokenType::Function => parser.shift(669),
            TokenType::Nil => parser.shift(509),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(511),
            TokenType::Until => parser.reduce::<35>(),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(645),
            TokenType::LCurly => parser.shift(673),
            TokenType::SemiColon => parser.reduce::<35>(),
            TokenType::Dots => parser.shift(514),
            TokenType::RetstatExplist => parser.goto(401),
            TokenType::Var => parser.goto(665),
            TokenType::Explist => parser.goto(405),
            TokenType::Exp => parser.goto(493),
            TokenType::Prefixexp => parser.goto(427),
            TokenType::Functioncall => parser.goto(666),
            TokenType::Functiondef => parser.goto(581),
            TokenType::Tableconstructor => parser.goto(583),
            TokenType::Unop => parser.goto(590),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<202> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(491),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<203> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(488),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<204> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(500),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<205> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Do => parser.shift(419),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(250),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<206> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Do => parser.shift(418),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(250),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<207> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(416),
            TokenType::String(_) => parser.shift(519),
            TokenType::Integer(_) => parser.shift(520),
            TokenType::Float(_) => parser.shift(521),
            TokenType::False => parser.shift(523),
            TokenType::Function => parser.shift(650),
            TokenType::Nil => parser.shift(524),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(525),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(636),
            TokenType::LCurly => parser.shift(651),
            TokenType::Dots => parser.shift(527),
            TokenType::Var => parser.goto(648),
            TokenType::Explist => parser.goto(415),
            TokenType::Exp => parser.goto(518),
            TokenType::Prefixexp => parser.goto(429),
            TokenType::Functioncall => parser.goto(649),
            TokenType::Functiondef => parser.goto(595),
            TokenType::Tableconstructor => parser.goto(596),
            TokenType::Unop => parser.goto(599),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<208> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(489),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<209> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(417),
            TokenType::String(_) => parser.shift(552),
            TokenType::Integer(_) => parser.shift(555),
            TokenType::Float(_) => parser.shift(558),
            TokenType::False => parser.shift(560),
            TokenType::Function => parser.shift(686),
            TokenType::Nil => parser.shift(562),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(565),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(671),
            TokenType::LCurly => parser.shift(687),
            TokenType::Dots => parser.shift(566),
            TokenType::Var => parser.goto(682),
            TokenType::Explist => parser.goto(404),
            TokenType::Exp => parser.goto(517),
            TokenType::Prefixexp => parser.goto(443),
            TokenType::Functioncall => parser.goto(683),
            TokenType::Functiondef => parser.goto(619),
            TokenType::Tableconstructor => parser.goto(620),
            TokenType::Unop => parser.goto(621),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<210> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(250),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<211> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(411),
            TokenType::String(_) => parser.shift(553),
            TokenType::Integer(_) => parser.shift(554),
            TokenType::Float(_) => parser.shift(556),
            TokenType::False => parser.shift(557),
            TokenType::Function => parser.shift(692),
            TokenType::Nil => parser.shift(561),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(563),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(680),
            TokenType::LCurly => parser.shift(693),
            TokenType::Dots => parser.shift(564),
            TokenType::Var => parser.goto(690),
            TokenType::Explist => parser.goto(410),
            TokenType::Exp => parser.goto(515),
            TokenType::Prefixexp => parser.goto(421),
            TokenType::Functioncall => parser.goto(691),
            TokenType::Functiondef => parser.goto(630),
            TokenType::Tableconstructor => parser.goto(631),
            TokenType::Unop => parser.goto(634),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<212> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(413),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<213> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(424),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<214> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(474),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(426),
            TokenType::Binop => parser.goto(485),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<215> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::RParen => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<216> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(171),
            TokenType::String(_) => parser.shift(273),
            TokenType::Integer(_) => parser.shift(276),
            TokenType::Float(_) => parser.shift(277),
            TokenType::False => parser.shift(278),
            TokenType::Function => parser.shift(370),
            TokenType::Nil => parser.shift(279),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(280),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(366),
            TokenType::LCurly => parser.shift(371),
            TokenType::Dots => parser.shift(281),
            TokenType::Var => parser.goto(368),
            TokenType::Explist => parser.goto(428),
            TokenType::Exp => parser.goto(255),
            TokenType::Prefixexp => parser.goto(186),
            TokenType::Functioncall => parser.goto(369),
            TokenType::Functiondef => parser.goto(329),
            TokenType::Tableconstructor => parser.goto(330),
            TokenType::Unop => parser.goto(331),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<217> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::RParen => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<218> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::RParen => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<219> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::RParen => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<220> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::RParen => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<221> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(559),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<222> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::RParen => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<223> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::RParen => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<224> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(548),
            TokenType::String(_) => parser.shift(568),
            TokenType::Integer(_) => parser.shift(569),
            TokenType::Float(_) => parser.shift(570),
            TokenType::False => parser.shift(571),
            TokenType::Function => parser.shift(688),
            TokenType::Nil => parser.shift(572),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(573),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(672),
            TokenType::LCurly => parser.shift(689),
            TokenType::Dots => parser.shift(574),
            TokenType::Var => parser.goto(684),
            TokenType::Exp => parser.goto(453),
            TokenType::Prefixexp => parser.goto(549),
            TokenType::Functioncall => parser.goto(685),
            TokenType::Functiondef => parser.goto(632),
            TokenType::Tableconstructor => parser.goto(633),
            TokenType::Unop => parser.goto(635),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<225> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(463),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<226> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::RCurly => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<227> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::RCurly => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<228> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(609),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<229> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::RCurly => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<230> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::RCurly => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<231> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::RCurly => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<232> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::RCurly => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<233> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::RCurly => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<234> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RCurly => parser.reduce::<97>(),
            TokenType::SemiColon => parser.reduce::<97>(),
            TokenType::Comma => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(481),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<235> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Then => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(252),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<236> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(567),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<237> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::RParen => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<238> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(470),
            TokenType::Concat => parser.shift(320),
            TokenType::Eof => parser.reduce::<55>(),
            TokenType::ExplistCont => parser.goto(435),
            TokenType::Binop => parser.goto(487),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<239> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            TokenType::Eof => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<240> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            TokenType::Eof => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<241> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            TokenType::Eof => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<242> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            TokenType::Eof => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<243> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            TokenType::Eof => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<244> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<245> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            TokenType::Eof => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<246> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            TokenType::Eof => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<247> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(431),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<248> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::Until => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<249> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::Until => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<250> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(67),
            TokenType::String(_) => parser.shift(77),
            TokenType::Integer(_) => parser.shift(78),
            TokenType::Float(_) => parser.shift(79),
            TokenType::False => parser.shift(80),
            TokenType::Function => parser.shift(133),
            TokenType::Nil => parser.shift(81),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(82),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(122),
            TokenType::LCurly => parser.shift(135),
            TokenType::Dots => parser.shift(83),
            TokenType::Var => parser.goto(129),
            TokenType::Exp => parser.goto(530),
            TokenType::Prefixexp => parser.goto(68),
            TokenType::Functioncall => parser.goto(130),
            TokenType::Functiondef => parser.goto(94),
            TokenType::Tableconstructor => parser.goto(95),
            TokenType::Unop => parser.goto(101),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<251> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(654),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<252> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(70),
            TokenType::String(_) => parser.shift(84),
            TokenType::Integer(_) => parser.shift(85),
            TokenType::Float(_) => parser.shift(86),
            TokenType::False => parser.shift(87),
            TokenType::Function => parser.shift(132),
            TokenType::Nil => parser.shift(88),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(89),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(123),
            TokenType::LCurly => parser.shift(134),
            TokenType::Dots => parser.shift(90),
            TokenType::Var => parser.goto(127),
            TokenType::Exp => parser.goto(508),
            TokenType::Prefixexp => parser.goto(71),
            TokenType::Functioncall => parser.goto(128),
            TokenType::Functiondef => parser.goto(96),
            TokenType::Tableconstructor => parser.goto(97),
            TokenType::Unop => parser.goto(103),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<253> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::RSquare => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<254> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::RSquare => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<255> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<55>(),
            TokenType::And => parser.shift(300),
            TokenType::Break => parser.reduce::<55>(),
            TokenType::Do => parser.reduce::<55>(),
            TokenType::For => parser.reduce::<55>(),
            TokenType::Function => parser.reduce::<55>(),
            TokenType::Goto => parser.reduce::<55>(),
            TokenType::If => parser.reduce::<55>(),
            TokenType::Local => parser.reduce::<55>(),
            TokenType::Or => parser.shift(301),
            TokenType::Repeat => parser.reduce::<55>(),
            TokenType::Return => parser.reduce::<55>(),
            TokenType::While => parser.reduce::<55>(),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::LParen => parser.reduce::<55>(),
            TokenType::DoubleColon => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(477),
            TokenType::Concat => parser.shift(320),
            TokenType::Eof => parser.reduce::<55>(),
            TokenType::ExplistCont => parser.goto(425),
            TokenType::Binop => parser.goto(611),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<256> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::RSquare => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<257> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::RSquare => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<258> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::RSquare => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<259> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::RSquare => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<260> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::RSquare => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<261> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(436),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<262> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<263> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<264> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<265> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(430),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<266> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(661),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<267> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::RParen => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<268> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::RParen => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<269> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::RCurly => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<270> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::RCurly => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<271> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Exp => parser.goto(512),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<272> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(432),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LCurly => parser.shift(359),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(537),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<273> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            TokenType::Eof => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<274> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Eof => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<275> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            TokenType::Eof => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<276> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            TokenType::Eof => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<277> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            TokenType::Eof => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<278> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            TokenType::Eof => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<279> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            TokenType::Eof => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<280> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            TokenType::Eof => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<281> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            TokenType::Eof => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<282> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(156),
            TokenType::String(_) => parser.shift(239),
            TokenType::Integer(_) => parser.shift(240),
            TokenType::Float(_) => parser.shift(241),
            TokenType::False => parser.shift(242),
            TokenType::Function => parser.shift(344),
            TokenType::Nil => parser.shift(243),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(334),
            TokenType::LCurly => parser.shift(345),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(342),
            TokenType::Exp => parser.goto(533),
            TokenType::Prefixexp => parser.goto(175),
            TokenType::Functioncall => parser.goto(343),
            TokenType::Functiondef => parser.goto(274),
            TokenType::Tableconstructor => parser.goto(275),
            TokenType::Unop => parser.goto(282),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<283> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.shift(476),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<284> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::RSquare => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<285> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::RSquare => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<286> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(510),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<287> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(445),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<288> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(456),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<289> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::RParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<290> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::RParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<291> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(434),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<292> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(433),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<293> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Then => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<294> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Then => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<295> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::Until => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<296> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(664),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<297> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(668),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<298> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(652),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<299> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<300> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<101>(),
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::Integer(_) => parser.reduce::<101>(),
            TokenType::Float(_) => parser.reduce::<101>(),
            TokenType::False => parser.reduce::<101>(),
            TokenType::Function => parser.reduce::<101>(),
            TokenType::Nil => parser.reduce::<101>(),
            TokenType::Not => parser.reduce::<101>(),
            TokenType::True => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Len => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::Dots => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<301> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<100>(),
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::Integer(_) => parser.reduce::<100>(),
            TokenType::Float(_) => parser.reduce::<100>(),
            TokenType::False => parser.reduce::<100>(),
            TokenType::Function => parser.reduce::<100>(),
            TokenType::Nil => parser.reduce::<100>(),
            TokenType::Not => parser.reduce::<100>(),
            TokenType::True => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Len => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::Dots => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<302> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<114>(),
            TokenType::String(_) => parser.reduce::<114>(),
            TokenType::Integer(_) => parser.reduce::<114>(),
            TokenType::Float(_) => parser.reduce::<114>(),
            TokenType::False => parser.reduce::<114>(),
            TokenType::Function => parser.reduce::<114>(),
            TokenType::Nil => parser.reduce::<114>(),
            TokenType::Not => parser.reduce::<114>(),
            TokenType::True => parser.reduce::<114>(),
            TokenType::Sub => parser.reduce::<114>(),
            TokenType::Len => parser.reduce::<114>(),
            TokenType::BitXor => parser.reduce::<114>(),
            TokenType::LParen => parser.reduce::<114>(),
            TokenType::LCurly => parser.reduce::<114>(),
            TokenType::Dots => parser.reduce::<114>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<303> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<115>(),
            TokenType::String(_) => parser.reduce::<115>(),
            TokenType::Integer(_) => parser.reduce::<115>(),
            TokenType::Float(_) => parser.reduce::<115>(),
            TokenType::False => parser.reduce::<115>(),
            TokenType::Function => parser.reduce::<115>(),
            TokenType::Nil => parser.reduce::<115>(),
            TokenType::Not => parser.reduce::<115>(),
            TokenType::True => parser.reduce::<115>(),
            TokenType::Sub => parser.reduce::<115>(),
            TokenType::Len => parser.reduce::<115>(),
            TokenType::BitXor => parser.reduce::<115>(),
            TokenType::LParen => parser.reduce::<115>(),
            TokenType::LCurly => parser.reduce::<115>(),
            TokenType::Dots => parser.reduce::<115>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<304> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<116>(),
            TokenType::String(_) => parser.reduce::<116>(),
            TokenType::Integer(_) => parser.reduce::<116>(),
            TokenType::Float(_) => parser.reduce::<116>(),
            TokenType::False => parser.reduce::<116>(),
            TokenType::Function => parser.reduce::<116>(),
            TokenType::Nil => parser.reduce::<116>(),
            TokenType::Not => parser.reduce::<116>(),
            TokenType::True => parser.reduce::<116>(),
            TokenType::Sub => parser.reduce::<116>(),
            TokenType::Len => parser.reduce::<116>(),
            TokenType::BitXor => parser.reduce::<116>(),
            TokenType::LParen => parser.reduce::<116>(),
            TokenType::LCurly => parser.reduce::<116>(),
            TokenType::Dots => parser.reduce::<116>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<305> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::Integer(_) => parser.reduce::<117>(),
            TokenType::Float(_) => parser.reduce::<117>(),
            TokenType::False => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Nil => parser.reduce::<117>(),
            TokenType::Not => parser.reduce::<117>(),
            TokenType::True => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Len => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::Dots => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<306> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<118>(),
            TokenType::String(_) => parser.reduce::<118>(),
            TokenType::Integer(_) => parser.reduce::<118>(),
            TokenType::Float(_) => parser.reduce::<118>(),
            TokenType::False => parser.reduce::<118>(),
            TokenType::Function => parser.reduce::<118>(),
            TokenType::Nil => parser.reduce::<118>(),
            TokenType::Not => parser.reduce::<118>(),
            TokenType::True => parser.reduce::<118>(),
            TokenType::Sub => parser.reduce::<118>(),
            TokenType::Len => parser.reduce::<118>(),
            TokenType::BitXor => parser.reduce::<118>(),
            TokenType::LParen => parser.reduce::<118>(),
            TokenType::LCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.reduce::<118>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<307> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<119>(),
            TokenType::String(_) => parser.reduce::<119>(),
            TokenType::Integer(_) => parser.reduce::<119>(),
            TokenType::Float(_) => parser.reduce::<119>(),
            TokenType::False => parser.reduce::<119>(),
            TokenType::Function => parser.reduce::<119>(),
            TokenType::Nil => parser.reduce::<119>(),
            TokenType::Not => parser.reduce::<119>(),
            TokenType::True => parser.reduce::<119>(),
            TokenType::Sub => parser.reduce::<119>(),
            TokenType::Len => parser.reduce::<119>(),
            TokenType::BitXor => parser.reduce::<119>(),
            TokenType::LParen => parser.reduce::<119>(),
            TokenType::LCurly => parser.reduce::<119>(),
            TokenType::Dots => parser.reduce::<119>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<308> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<120>(),
            TokenType::String(_) => parser.reduce::<120>(),
            TokenType::Integer(_) => parser.reduce::<120>(),
            TokenType::Float(_) => parser.reduce::<120>(),
            TokenType::False => parser.reduce::<120>(),
            TokenType::Function => parser.reduce::<120>(),
            TokenType::Nil => parser.reduce::<120>(),
            TokenType::Not => parser.reduce::<120>(),
            TokenType::True => parser.reduce::<120>(),
            TokenType::Sub => parser.reduce::<120>(),
            TokenType::Len => parser.reduce::<120>(),
            TokenType::BitXor => parser.reduce::<120>(),
            TokenType::LParen => parser.reduce::<120>(),
            TokenType::LCurly => parser.reduce::<120>(),
            TokenType::Dots => parser.reduce::<120>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<309> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<110>(),
            TokenType::String(_) => parser.reduce::<110>(),
            TokenType::Integer(_) => parser.reduce::<110>(),
            TokenType::Float(_) => parser.reduce::<110>(),
            TokenType::False => parser.reduce::<110>(),
            TokenType::Function => parser.reduce::<110>(),
            TokenType::Nil => parser.reduce::<110>(),
            TokenType::Not => parser.reduce::<110>(),
            TokenType::True => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Len => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::LParen => parser.reduce::<110>(),
            TokenType::LCurly => parser.reduce::<110>(),
            TokenType::Dots => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<310> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<109>(),
            TokenType::String(_) => parser.reduce::<109>(),
            TokenType::Integer(_) => parser.reduce::<109>(),
            TokenType::Float(_) => parser.reduce::<109>(),
            TokenType::False => parser.reduce::<109>(),
            TokenType::Function => parser.reduce::<109>(),
            TokenType::Nil => parser.reduce::<109>(),
            TokenType::Not => parser.reduce::<109>(),
            TokenType::True => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Len => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::LParen => parser.reduce::<109>(),
            TokenType::LCurly => parser.reduce::<109>(),
            TokenType::Dots => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<311> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<108>(),
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::Integer(_) => parser.reduce::<108>(),
            TokenType::Float(_) => parser.reduce::<108>(),
            TokenType::False => parser.reduce::<108>(),
            TokenType::Function => parser.reduce::<108>(),
            TokenType::Nil => parser.reduce::<108>(),
            TokenType::Not => parser.reduce::<108>(),
            TokenType::True => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Len => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::Dots => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<312> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<111>(),
            TokenType::String(_) => parser.reduce::<111>(),
            TokenType::Integer(_) => parser.reduce::<111>(),
            TokenType::Float(_) => parser.reduce::<111>(),
            TokenType::False => parser.reduce::<111>(),
            TokenType::Function => parser.reduce::<111>(),
            TokenType::Nil => parser.reduce::<111>(),
            TokenType::Not => parser.reduce::<111>(),
            TokenType::True => parser.reduce::<111>(),
            TokenType::Sub => parser.reduce::<111>(),
            TokenType::Len => parser.reduce::<111>(),
            TokenType::BitXor => parser.reduce::<111>(),
            TokenType::LParen => parser.reduce::<111>(),
            TokenType::LCurly => parser.reduce::<111>(),
            TokenType::Dots => parser.reduce::<111>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<313> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<112>(),
            TokenType::String(_) => parser.reduce::<112>(),
            TokenType::Integer(_) => parser.reduce::<112>(),
            TokenType::Float(_) => parser.reduce::<112>(),
            TokenType::False => parser.reduce::<112>(),
            TokenType::Function => parser.reduce::<112>(),
            TokenType::Nil => parser.reduce::<112>(),
            TokenType::Not => parser.reduce::<112>(),
            TokenType::True => parser.reduce::<112>(),
            TokenType::Sub => parser.reduce::<112>(),
            TokenType::Len => parser.reduce::<112>(),
            TokenType::BitXor => parser.reduce::<112>(),
            TokenType::LParen => parser.reduce::<112>(),
            TokenType::LCurly => parser.reduce::<112>(),
            TokenType::Dots => parser.reduce::<112>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<314> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<106>(),
            TokenType::String(_) => parser.reduce::<106>(),
            TokenType::Integer(_) => parser.reduce::<106>(),
            TokenType::Float(_) => parser.reduce::<106>(),
            TokenType::False => parser.reduce::<106>(),
            TokenType::Function => parser.reduce::<106>(),
            TokenType::Nil => parser.reduce::<106>(),
            TokenType::Not => parser.reduce::<106>(),
            TokenType::True => parser.reduce::<106>(),
            TokenType::Sub => parser.reduce::<106>(),
            TokenType::Len => parser.reduce::<106>(),
            TokenType::BitXor => parser.reduce::<106>(),
            TokenType::LParen => parser.reduce::<106>(),
            TokenType::LCurly => parser.reduce::<106>(),
            TokenType::Dots => parser.reduce::<106>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<315> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<107>(),
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::Integer(_) => parser.reduce::<107>(),
            TokenType::Float(_) => parser.reduce::<107>(),
            TokenType::False => parser.reduce::<107>(),
            TokenType::Function => parser.reduce::<107>(),
            TokenType::Nil => parser.reduce::<107>(),
            TokenType::Not => parser.reduce::<107>(),
            TokenType::True => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Len => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::Dots => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<316> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<104>(),
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::Integer(_) => parser.reduce::<104>(),
            TokenType::Float(_) => parser.reduce::<104>(),
            TokenType::False => parser.reduce::<104>(),
            TokenType::Function => parser.reduce::<104>(),
            TokenType::Nil => parser.reduce::<104>(),
            TokenType::Not => parser.reduce::<104>(),
            TokenType::True => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Len => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::Dots => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<317> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<105>(),
            TokenType::String(_) => parser.reduce::<105>(),
            TokenType::Integer(_) => parser.reduce::<105>(),
            TokenType::Float(_) => parser.reduce::<105>(),
            TokenType::False => parser.reduce::<105>(),
            TokenType::Function => parser.reduce::<105>(),
            TokenType::Nil => parser.reduce::<105>(),
            TokenType::Not => parser.reduce::<105>(),
            TokenType::True => parser.reduce::<105>(),
            TokenType::Sub => parser.reduce::<105>(),
            TokenType::Len => parser.reduce::<105>(),
            TokenType::BitXor => parser.reduce::<105>(),
            TokenType::LParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.reduce::<105>(),
            TokenType::Dots => parser.reduce::<105>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<318> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<102>(),
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::Integer(_) => parser.reduce::<102>(),
            TokenType::Float(_) => parser.reduce::<102>(),
            TokenType::False => parser.reduce::<102>(),
            TokenType::Function => parser.reduce::<102>(),
            TokenType::Nil => parser.reduce::<102>(),
            TokenType::Not => parser.reduce::<102>(),
            TokenType::True => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Len => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::Dots => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<319> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<103>(),
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::Integer(_) => parser.reduce::<103>(),
            TokenType::Float(_) => parser.reduce::<103>(),
            TokenType::False => parser.reduce::<103>(),
            TokenType::Function => parser.reduce::<103>(),
            TokenType::Nil => parser.reduce::<103>(),
            TokenType::Not => parser.reduce::<103>(),
            TokenType::True => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Len => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::Dots => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<320> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<113>(),
            TokenType::String(_) => parser.reduce::<113>(),
            TokenType::Integer(_) => parser.reduce::<113>(),
            TokenType::Float(_) => parser.reduce::<113>(),
            TokenType::False => parser.reduce::<113>(),
            TokenType::Function => parser.reduce::<113>(),
            TokenType::Nil => parser.reduce::<113>(),
            TokenType::Not => parser.reduce::<113>(),
            TokenType::True => parser.reduce::<113>(),
            TokenType::Sub => parser.reduce::<113>(),
            TokenType::Len => parser.reduce::<113>(),
            TokenType::BitXor => parser.reduce::<113>(),
            TokenType::LParen => parser.reduce::<113>(),
            TokenType::LCurly => parser.reduce::<113>(),
            TokenType::Dots => parser.reduce::<113>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<321> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<322> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(444),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<323> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(450),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<324> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<325> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<326> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.shift(486),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<327> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(674),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<328> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(653),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<329> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Eof => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<330> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            TokenType::Eof => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<331> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(171),
            TokenType::String(_) => parser.shift(273),
            TokenType::Integer(_) => parser.shift(276),
            TokenType::Float(_) => parser.shift(277),
            TokenType::False => parser.shift(278),
            TokenType::Function => parser.shift(370),
            TokenType::Nil => parser.shift(279),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(280),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(366),
            TokenType::LCurly => parser.shift(371),
            TokenType::Dots => parser.shift(281),
            TokenType::Var => parser.goto(368),
            TokenType::Exp => parser.goto(541),
            TokenType::Prefixexp => parser.goto(186),
            TokenType::Functioncall => parser.goto(369),
            TokenType::Functiondef => parser.goto(329),
            TokenType::Tableconstructor => parser.goto(330),
            TokenType::Unop => parser.goto(331),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<332> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(499),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<333> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Then => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<334> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(516),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<335> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(667),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<336> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(529),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<337> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(497),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<338> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::RParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<339> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(675),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<340> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<341> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(678),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<342> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Eof => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<343> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Eof => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<344> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(460),
            TokenType::Funcbody => parser.goto(452),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<345> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(677),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<346> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::RParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<347> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::RParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<348> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(471),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<349> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<350> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(475),
            TokenType::Funcbody => parser.goto(448),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<351> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(676),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<352> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::RSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<353> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::RSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<354> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::RCurly => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<355> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::RCurly => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<356> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(473),
            TokenType::Funcbody => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<357> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(681),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<358> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(442),
            TokenType::Funcbody => parser.goto(440),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<359> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(670),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<360> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(479),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<361> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<362> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<92>(),
            TokenType::SemiColon => parser.shift(482),
            TokenType::Comma => parser.shift(483),
            TokenType::FieldlistCont => parser.goto(437),
            TokenType::Fieldsep => parser.goto(469),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<363> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(522),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<364> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(438),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<365> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(439),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<366> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(492),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<367> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(451),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<368> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Eof => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<369> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Eof => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<370> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(480),
            TokenType::Funcbody => parser.goto(446),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<371> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(679),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<372> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            TokenType::Eof => parser.reduce::<29>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<373> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<25>(),
            TokenType::Break => parser.reduce::<25>(),
            TokenType::Do => parser.reduce::<25>(),
            TokenType::For => parser.reduce::<25>(),
            TokenType::Function => parser.reduce::<25>(),
            TokenType::Goto => parser.reduce::<25>(),
            TokenType::If => parser.reduce::<25>(),
            TokenType::Local => parser.reduce::<25>(),
            TokenType::Repeat => parser.reduce::<25>(),
            TokenType::Return => parser.reduce::<25>(),
            TokenType::While => parser.reduce::<25>(),
            TokenType::LParen => parser.reduce::<25>(),
            TokenType::DoubleColon => parser.reduce::<25>(),
            TokenType::SemiColon => parser.reduce::<25>(),
            TokenType::Eof => parser.reduce::<25>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<374> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<40>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<375> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<34>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<376> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<41>(),
            TokenType::Colon => parser.reduce::<41>(),
            TokenType::Dot => parser.shift(150),
            TokenType::FuncnameCont => parser.goto(694),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<377> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<38>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<378> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(695),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<379> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<24>(),
            TokenType::Break => parser.reduce::<24>(),
            TokenType::Do => parser.reduce::<24>(),
            TokenType::For => parser.reduce::<24>(),
            TokenType::Function => parser.reduce::<24>(),
            TokenType::Goto => parser.reduce::<24>(),
            TokenType::If => parser.reduce::<24>(),
            TokenType::Local => parser.reduce::<24>(),
            TokenType::Repeat => parser.reduce::<24>(),
            TokenType::Return => parser.reduce::<24>(),
            TokenType::Until => parser.reduce::<24>(),
            TokenType::While => parser.reduce::<24>(),
            TokenType::LParen => parser.reduce::<24>(),
            TokenType::DoubleColon => parser.reduce::<24>(),
            TokenType::SemiColon => parser.reduce::<24>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<380> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(727),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<381> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Greater => parser.shift(696),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<382> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<24>(),
            TokenType::Break => parser.reduce::<24>(),
            TokenType::Do => parser.reduce::<24>(),
            TokenType::End => parser.reduce::<24>(),
            TokenType::For => parser.reduce::<24>(),
            TokenType::Function => parser.reduce::<24>(),
            TokenType::Goto => parser.reduce::<24>(),
            TokenType::If => parser.reduce::<24>(),
            TokenType::Local => parser.reduce::<24>(),
            TokenType::Repeat => parser.reduce::<24>(),
            TokenType::Return => parser.reduce::<24>(),
            TokenType::While => parser.reduce::<24>(),
            TokenType::LParen => parser.reduce::<24>(),
            TokenType::DoubleColon => parser.reduce::<24>(),
            TokenType::SemiColon => parser.reduce::<24>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<383> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Eof => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<384> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(395),
            TokenType::Funcbody => parser.goto(697),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<385> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<386> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<39>(),
            TokenType::Break => parser.reduce::<39>(),
            TokenType::Do => parser.reduce::<39>(),
            TokenType::End => parser.reduce::<39>(),
            TokenType::For => parser.reduce::<39>(),
            TokenType::Function => parser.reduce::<39>(),
            TokenType::Goto => parser.reduce::<39>(),
            TokenType::If => parser.reduce::<39>(),
            TokenType::Local => parser.reduce::<39>(),
            TokenType::Repeat => parser.reduce::<39>(),
            TokenType::Return => parser.reduce::<39>(),
            TokenType::While => parser.reduce::<39>(),
            TokenType::LParen => parser.reduce::<39>(),
            TokenType::DoubleColon => parser.reduce::<39>(),
            TokenType::SemiColon => parser.reduce::<39>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<387> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<26>(),
            TokenType::Break => parser.reduce::<26>(),
            TokenType::Do => parser.reduce::<26>(),
            TokenType::For => parser.reduce::<26>(),
            TokenType::Function => parser.reduce::<26>(),
            TokenType::Goto => parser.reduce::<26>(),
            TokenType::If => parser.reduce::<26>(),
            TokenType::Local => parser.reduce::<26>(),
            TokenType::Repeat => parser.reduce::<26>(),
            TokenType::Return => parser.reduce::<26>(),
            TokenType::Until => parser.reduce::<26>(),
            TokenType::While => parser.reduce::<26>(),
            TokenType::LParen => parser.reduce::<26>(),
            TokenType::DoubleColon => parser.reduce::<26>(),
            TokenType::SemiColon => parser.reduce::<26>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<388> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<39>(),
            TokenType::Break => parser.reduce::<39>(),
            TokenType::Do => parser.reduce::<39>(),
            TokenType::For => parser.reduce::<39>(),
            TokenType::Function => parser.reduce::<39>(),
            TokenType::Goto => parser.reduce::<39>(),
            TokenType::If => parser.reduce::<39>(),
            TokenType::Local => parser.reduce::<39>(),
            TokenType::Repeat => parser.reduce::<39>(),
            TokenType::Return => parser.reduce::<39>(),
            TokenType::Until => parser.reduce::<39>(),
            TokenType::While => parser.reduce::<39>(),
            TokenType::LParen => parser.reduce::<39>(),
            TokenType::DoubleColon => parser.reduce::<39>(),
            TokenType::SemiColon => parser.reduce::<39>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<389> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(733),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<390> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(392),
            TokenType::Funcbody => parser.goto(700),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<391> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<26>(),
            TokenType::Break => parser.reduce::<26>(),
            TokenType::Do => parser.reduce::<26>(),
            TokenType::End => parser.reduce::<26>(),
            TokenType::For => parser.reduce::<26>(),
            TokenType::Function => parser.reduce::<26>(),
            TokenType::Goto => parser.reduce::<26>(),
            TokenType::If => parser.reduce::<26>(),
            TokenType::Local => parser.reduce::<26>(),
            TokenType::Repeat => parser.reduce::<26>(),
            TokenType::Return => parser.reduce::<26>(),
            TokenType::While => parser.reduce::<26>(),
            TokenType::LParen => parser.reduce::<26>(),
            TokenType::DoubleColon => parser.reduce::<26>(),
            TokenType::SemiColon => parser.reduce::<26>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<392> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(702),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<393> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<394> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<84>(),
            TokenType::Comma => parser.shift(705),
            TokenType::ParlistCont => parser.goto(703),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<395> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(701),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<396> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<4>(),
            TokenType::Elseif => parser.reduce::<4>(),
            TokenType::End => parser.reduce::<4>(),
            TokenType::Return => parser.shift(765),
            TokenType::BlockRetstat => parser.goto(698),
            TokenType::Retstat => parser.goto(710),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<397> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(732),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<398> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<399> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::End => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(726),
            TokenType::AttnamelistCont => parser.goto(704),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<400> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(729),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<401> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<37>(),
            TokenType::SemiColon => parser.shift(707),
            TokenType::RetstatEnd => parser.goto(699),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<402> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::Until => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(730),
            TokenType::AttnamelistCont => parser.goto(706),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<403> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<37>(),
            TokenType::SemiColon => parser.shift(711),
            TokenType::RetstatEnd => parser.goto(708),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<404> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<7>(),
            TokenType::Break => parser.reduce::<7>(),
            TokenType::Do => parser.reduce::<7>(),
            TokenType::For => parser.reduce::<7>(),
            TokenType::Function => parser.reduce::<7>(),
            TokenType::Goto => parser.reduce::<7>(),
            TokenType::If => parser.reduce::<7>(),
            TokenType::Local => parser.reduce::<7>(),
            TokenType::Repeat => parser.reduce::<7>(),
            TokenType::Return => parser.reduce::<7>(),
            TokenType::Until => parser.reduce::<7>(),
            TokenType::While => parser.reduce::<7>(),
            TokenType::LParen => parser.reduce::<7>(),
            TokenType::DoubleColon => parser.reduce::<7>(),
            TokenType::SemiColon => parser.reduce::<7>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<405> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<36>(),
            TokenType::SemiColon => parser.reduce::<36>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<406> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<36>(),
            TokenType::SemiColon => parser.reduce::<36>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<407> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Until => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<408> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<409> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(715),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<410> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<7>(),
            TokenType::Break => parser.reduce::<7>(),
            TokenType::Do => parser.reduce::<7>(),
            TokenType::End => parser.reduce::<7>(),
            TokenType::For => parser.reduce::<7>(),
            TokenType::Function => parser.reduce::<7>(),
            TokenType::Goto => parser.reduce::<7>(),
            TokenType::If => parser.reduce::<7>(),
            TokenType::Local => parser.reduce::<7>(),
            TokenType::Repeat => parser.reduce::<7>(),
            TokenType::Return => parser.reduce::<7>(),
            TokenType::While => parser.reduce::<7>(),
            TokenType::LParen => parser.reduce::<7>(),
            TokenType::DoubleColon => parser.reduce::<7>(),
            TokenType::SemiColon => parser.reduce::<7>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<411> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<412> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(712),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<413> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::Assign => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<414> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(709),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<415> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(731),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<416> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<417> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::Until => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<418> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(916),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<419> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(928),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<420> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(468),
            TokenType::Do => parser.shift(484),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(502),
            TokenType::Function => parser.shift(505),
            TokenType::Goto => parser.shift(506),
            TokenType::If => parser.shift(528),
            TokenType::Local => parser.shift(578),
            TokenType::Repeat => parser.shift(582),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(597),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(626),
            TokenType::SemiColon => parser.shift(622),
            TokenType::BlockStat => parser.goto(784),
            TokenType::Stat => parser.goto(420),
            TokenType::Label => parser.goto(623),
            TokenType::Varlist => parser.goto(624),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(628),
            TokenType::Functioncall => parser.goto(625),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<421> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::String(_) => parser.shift(924),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            // Shift(926)-Reduce(65)
            TokenType::LParen => parser.shift(926),
            TokenType::LSquare => parser.shift(752),
            TokenType::LCurly => parser.shift(948),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Colon => parser.shift(922),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Dot => parser.shift(920),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(923),
            TokenType::Tableconstructor => parser.goto(947),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<422> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(894),
            TokenType::And => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.shift(896),
            TokenType::LSquare => parser.shift(760),
            TokenType::LCurly => parser.shift(933),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Colon => parser.shift(891),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Dot => parser.shift(890),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(893),
            TokenType::Tableconstructor => parser.goto(932),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<423> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Comma => parser.shift(766),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(858),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<424> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<12>(),
            TokenType::Break => parser.reduce::<12>(),
            TokenType::Do => parser.reduce::<12>(),
            TokenType::End => parser.reduce::<12>(),
            TokenType::For => parser.reduce::<12>(),
            TokenType::Function => parser.reduce::<12>(),
            TokenType::Goto => parser.reduce::<12>(),
            TokenType::If => parser.reduce::<12>(),
            TokenType::Local => parser.reduce::<12>(),
            TokenType::Repeat => parser.reduce::<12>(),
            TokenType::Return => parser.reduce::<12>(),
            TokenType::While => parser.reduce::<12>(),
            TokenType::LParen => parser.reduce::<12>(),
            TokenType::DoubleColon => parser.reduce::<12>(),
            TokenType::SemiColon => parser.reduce::<12>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<425> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Eof => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<426> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<427> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(908),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Until => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.shift(912),
            TokenType::LSquare => parser.shift(772),
            TokenType::LCurly => parser.shift(934),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Colon => parser.shift(906),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Dot => parser.shift(904),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(907),
            TokenType::Tableconstructor => parser.goto(931),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<428> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<28>(),
            TokenType::Break => parser.reduce::<28>(),
            TokenType::Do => parser.reduce::<28>(),
            TokenType::For => parser.reduce::<28>(),
            TokenType::Function => parser.reduce::<28>(),
            TokenType::Goto => parser.reduce::<28>(),
            TokenType::If => parser.reduce::<28>(),
            TokenType::Local => parser.reduce::<28>(),
            TokenType::Repeat => parser.reduce::<28>(),
            TokenType::Return => parser.reduce::<28>(),
            TokenType::While => parser.reduce::<28>(),
            TokenType::LParen => parser.reduce::<28>(),
            TokenType::DoubleColon => parser.reduce::<28>(),
            TokenType::SemiColon => parser.reduce::<28>(),
            TokenType::Eof => parser.reduce::<28>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<429> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(880),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.shift(882),
            TokenType::LSquare => parser.shift(757),
            TokenType::LCurly => parser.shift(930),
            TokenType::Colon => parser.shift(878),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Dot => parser.shift(877),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(879),
            TokenType::Tableconstructor => parser.goto(929),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<430> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<52>(),
            TokenType::Comma => parser.shift(265),
            TokenType::NamelistCont => parser.goto(714),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<431> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(249),
            TokenType::LParen => parser.shift(251),
            TokenType::LCurly => parser.shift(297),
            TokenType::Args => parser.goto(713),
            TokenType::Tableconstructor => parser.goto(295),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<432> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::RCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<433> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(294),
            TokenType::LParen => parser.shift(298),
            TokenType::LCurly => parser.shift(335),
            TokenType::Args => parser.goto(717),
            TokenType::Tableconstructor => parser.goto(333),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<434> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Then => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<435> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Eof => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<436> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(263),
            TokenType::LParen => parser.shift(266),
            TokenType::LCurly => parser.shift(327),
            TokenType::Args => parser.goto(716),
            TokenType::Tableconstructor => parser.goto(321),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<437> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<438> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Then => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<439> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::RParen => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<440> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::RCurly => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<441> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(468),
            TokenType::Do => parser.shift(484),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(502),
            TokenType::Function => parser.shift(505),
            TokenType::Goto => parser.shift(506),
            TokenType::If => parser.shift(528),
            TokenType::Local => parser.shift(578),
            TokenType::Repeat => parser.shift(582),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(597),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(626),
            TokenType::SemiColon => parser.shift(622),
            TokenType::Block => parser.goto(874),
            TokenType::BlockStat => parser.goto(396),
            TokenType::Stat => parser.goto(420),
            TokenType::Label => parser.goto(623),
            TokenType::Varlist => parser.goto(624),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(628),
            TokenType::Functioncall => parser.goto(625),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<442> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(718),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<443> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::String(_) => parser.shift(888),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::Until => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            // Shift(889)-Reduce(65)
            TokenType::LParen => parser.shift(889),
            TokenType::LSquare => parser.shift(750),
            TokenType::LCurly => parser.shift(939),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Colon => parser.shift(886),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Dot => parser.shift(884),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(887),
            TokenType::Tableconstructor => parser.goto(938),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<444> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<445> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::RParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<446> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            TokenType::Eof => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<447> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(432),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LCurly => parser.shift(359),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(823),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<448> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::RParen => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<449> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(468),
            TokenType::Do => parser.shift(484),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(502),
            TokenType::Function => parser.shift(505),
            TokenType::Goto => parser.shift(506),
            TokenType::If => parser.shift(528),
            TokenType::Local => parser.shift(578),
            TokenType::Repeat => parser.shift(582),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(597),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(626),
            TokenType::SemiColon => parser.shift(622),
            TokenType::Block => parser.goto(876),
            TokenType::BlockStat => parser.goto(396),
            TokenType::Stat => parser.goto(420),
            TokenType::Label => parser.goto(623),
            TokenType::Varlist => parser.goto(624),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(628),
            TokenType::Functioncall => parser.goto(625),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<450> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(325),
            TokenType::LParen => parser.shift(328),
            TokenType::LCurly => parser.shift(341),
            TokenType::Args => parser.goto(719),
            TokenType::Tableconstructor => parser.goto(340),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<451> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<452> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            TokenType::Eof => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<453> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<14>(),
            TokenType::And => parser.shift(300),
            TokenType::Break => parser.reduce::<14>(),
            TokenType::Do => parser.reduce::<14>(),
            TokenType::For => parser.reduce::<14>(),
            TokenType::Function => parser.reduce::<14>(),
            TokenType::Goto => parser.reduce::<14>(),
            TokenType::If => parser.reduce::<14>(),
            TokenType::Local => parser.reduce::<14>(),
            TokenType::Or => parser.shift(301),
            TokenType::Repeat => parser.reduce::<14>(),
            TokenType::Return => parser.reduce::<14>(),
            TokenType::While => parser.reduce::<14>(),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::LParen => parser.reduce::<14>(),
            TokenType::DoubleColon => parser.reduce::<14>(),
            TokenType::SemiColon => parser.reduce::<14>(),
            TokenType::Concat => parser.shift(320),
            TokenType::Eof => parser.reduce::<14>(),
            TokenType::Binop => parser.goto(814),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<454> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(816),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<455> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(490),
            TokenType::String(_) => parser.shift(536),
            TokenType::Integer(_) => parser.shift(538),
            TokenType::Float(_) => parser.shift(539),
            TokenType::False => parser.shift(542),
            TokenType::Function => parser.shift(657),
            TokenType::Nil => parser.shift(544),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(546),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(646),
            TokenType::LCurly => parser.shift(658),
            TokenType::Dots => parser.shift(547),
            TokenType::Var => parser.goto(655),
            TokenType::Exp => parser.goto(759),
            TokenType::Prefixexp => parser.goto(494),
            TokenType::Functioncall => parser.goto(656),
            TokenType::Functiondef => parser.goto(600),
            TokenType::Tableconstructor => parser.goto(601),
            TokenType::Unop => parser.goto(607),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<456> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(290),
            TokenType::LParen => parser.shift(296),
            TokenType::LCurly => parser.shift(339),
            TokenType::Args => parser.goto(745),
            TokenType::Tableconstructor => parser.goto(338),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<457> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(819),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<458> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(490),
            TokenType::String(_) => parser.shift(536),
            TokenType::Integer(_) => parser.shift(538),
            TokenType::Float(_) => parser.shift(539),
            TokenType::False => parser.shift(542),
            TokenType::Function => parser.shift(657),
            TokenType::Nil => parser.shift(544),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(546),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(646),
            TokenType::LCurly => parser.shift(658),
            TokenType::Dots => parser.shift(547),
            TokenType::Var => parser.goto(655),
            TokenType::Exp => parser.goto(762),
            TokenType::Prefixexp => parser.goto(494),
            TokenType::Functioncall => parser.goto(656),
            TokenType::Functiondef => parser.goto(600),
            TokenType::Tableconstructor => parser.goto(601),
            TokenType::Unop => parser.goto(607),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<459> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(838),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<460> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(754),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<461> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(786),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<462> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(787),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<463> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<12>(),
            TokenType::Break => parser.reduce::<12>(),
            TokenType::Do => parser.reduce::<12>(),
            TokenType::For => parser.reduce::<12>(),
            TokenType::Function => parser.reduce::<12>(),
            TokenType::Goto => parser.reduce::<12>(),
            TokenType::If => parser.reduce::<12>(),
            TokenType::Local => parser.reduce::<12>(),
            TokenType::Repeat => parser.reduce::<12>(),
            TokenType::Return => parser.reduce::<12>(),
            TokenType::Until => parser.reduce::<12>(),
            TokenType::While => parser.reduce::<12>(),
            TokenType::LParen => parser.reduce::<12>(),
            TokenType::DoubleColon => parser.reduce::<12>(),
            TokenType::SemiColon => parser.reduce::<12>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<464> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(416),
            TokenType::String(_) => parser.shift(519),
            TokenType::Integer(_) => parser.shift(520),
            TokenType::Float(_) => parser.shift(521),
            TokenType::False => parser.shift(523),
            TokenType::Function => parser.shift(650),
            TokenType::Nil => parser.shift(524),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(525),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(636),
            TokenType::LCurly => parser.shift(651),
            TokenType::Dots => parser.shift(527),
            TokenType::Var => parser.goto(648),
            TokenType::Explist => parser.goto(725),
            TokenType::Exp => parser.goto(518),
            TokenType::Prefixexp => parser.goto(429),
            TokenType::Functioncall => parser.goto(649),
            TokenType::Functiondef => parser.goto(595),
            TokenType::Tableconstructor => parser.goto(596),
            TokenType::Unop => parser.goto(599),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<465> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(828),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<466> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(416),
            TokenType::String(_) => parser.shift(519),
            TokenType::Integer(_) => parser.shift(520),
            TokenType::Float(_) => parser.shift(521),
            TokenType::False => parser.shift(523),
            TokenType::Function => parser.shift(650),
            TokenType::Nil => parser.shift(524),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(525),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(636),
            TokenType::LCurly => parser.shift(651),
            TokenType::Dots => parser.shift(527),
            TokenType::Var => parser.goto(648),
            TokenType::Explist => parser.goto(720),
            TokenType::Exp => parser.goto(518),
            TokenType::Prefixexp => parser.goto(429),
            TokenType::Functioncall => parser.goto(649),
            TokenType::Functiondef => parser.goto(595),
            TokenType::Tableconstructor => parser.goto(596),
            TokenType::Unop => parser.goto(599),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<467> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::RSquare => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<468> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<10>(),
            TokenType::Break => parser.reduce::<10>(),
            TokenType::Do => parser.reduce::<10>(),
            TokenType::Else => parser.reduce::<10>(),
            TokenType::Elseif => parser.reduce::<10>(),
            TokenType::End => parser.reduce::<10>(),
            TokenType::For => parser.reduce::<10>(),
            TokenType::Function => parser.reduce::<10>(),
            TokenType::Goto => parser.reduce::<10>(),
            TokenType::If => parser.reduce::<10>(),
            TokenType::Local => parser.reduce::<10>(),
            TokenType::Repeat => parser.reduce::<10>(),
            TokenType::Return => parser.reduce::<10>(),
            TokenType::While => parser.reduce::<10>(),
            TokenType::LParen => parser.reduce::<10>(),
            TokenType::DoubleColon => parser.reduce::<10>(),
            TokenType::SemiColon => parser.reduce::<10>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<469> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<94>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::Field => parser.goto(956),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<470> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(156),
            TokenType::String(_) => parser.shift(239),
            TokenType::Integer(_) => parser.shift(240),
            TokenType::Float(_) => parser.shift(241),
            TokenType::False => parser.shift(242),
            TokenType::Function => parser.shift(344),
            TokenType::Nil => parser.shift(243),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(334),
            TokenType::LCurly => parser.shift(345),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(342),
            TokenType::Exp => parser.goto(836),
            TokenType::Prefixexp => parser.goto(175),
            TokenType::Functioncall => parser.goto(343),
            TokenType::Functiondef => parser.goto(274),
            TokenType::Tableconstructor => parser.goto(275),
            TokenType::Unop => parser.goto(282),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<471> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Eof => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<472> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(411),
            TokenType::String(_) => parser.shift(553),
            TokenType::Integer(_) => parser.shift(554),
            TokenType::Float(_) => parser.shift(556),
            TokenType::False => parser.shift(557),
            TokenType::Function => parser.shift(692),
            TokenType::Nil => parser.shift(561),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(563),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(680),
            TokenType::LCurly => parser.shift(693),
            TokenType::Dots => parser.shift(564),
            TokenType::Var => parser.goto(690),
            TokenType::Explist => parser.goto(758),
            TokenType::Exp => parser.goto(515),
            TokenType::Prefixexp => parser.goto(421),
            TokenType::Functioncall => parser.goto(691),
            TokenType::Functiondef => parser.goto(630),
            TokenType::Tableconstructor => parser.goto(631),
            TokenType::Unop => parser.goto(634),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<473> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(722),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<474> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Exp => parser.goto(829),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<475> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(724),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<476> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(847),
            TokenType::String(_) => parser.shift(867),
            TokenType::Integer(_) => parser.shift(868),
            TokenType::Float(_) => parser.shift(869),
            TokenType::False => parser.shift(870),
            TokenType::Function => parser.shift(967),
            TokenType::Nil => parser.shift(871),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(872),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(955),
            TokenType::LCurly => parser.shift(970),
            TokenType::Dots => parser.shift(873),
            TokenType::Var => parser.goto(965),
            TokenType::Exp => parser.goto(748),
            TokenType::Prefixexp => parser.goto(849),
            TokenType::Functioncall => parser.goto(966),
            TokenType::Functiondef => parser.goto(917),
            TokenType::Tableconstructor => parser.goto(918),
            TokenType::Unop => parser.goto(925),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<477> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(171),
            TokenType::String(_) => parser.shift(273),
            TokenType::Integer(_) => parser.shift(276),
            TokenType::Float(_) => parser.shift(277),
            TokenType::False => parser.shift(278),
            TokenType::Function => parser.shift(370),
            TokenType::Nil => parser.shift(279),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(280),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(366),
            TokenType::LCurly => parser.shift(371),
            TokenType::Dots => parser.shift(281),
            TokenType::Var => parser.goto(368),
            TokenType::Exp => parser.goto(853),
            TokenType::Prefixexp => parser.goto(186),
            TokenType::Functioncall => parser.goto(369),
            TokenType::Functiondef => parser.goto(329),
            TokenType::Tableconstructor => parser.goto(330),
            TokenType::Unop => parser.goto(331),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<478> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(417),
            TokenType::String(_) => parser.shift(552),
            TokenType::Integer(_) => parser.shift(555),
            TokenType::Float(_) => parser.shift(558),
            TokenType::False => parser.shift(560),
            TokenType::Function => parser.shift(686),
            TokenType::Nil => parser.shift(562),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(565),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(671),
            TokenType::LCurly => parser.shift(687),
            TokenType::Dots => parser.shift(566),
            TokenType::Var => parser.goto(682),
            TokenType::Explist => parser.goto(721),
            TokenType::Exp => parser.goto(517),
            TokenType::Prefixexp => parser.goto(443),
            TokenType::Functioncall => parser.goto(683),
            TokenType::Functiondef => parser.goto(619),
            TokenType::Tableconstructor => parser.goto(620),
            TokenType::Unop => parser.goto(621),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<479> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Eof => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<480> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(769),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<481> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(432),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LCurly => parser.shift(359),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(827),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<482> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<99>(),
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::Integer(_) => parser.reduce::<99>(),
            TokenType::Float(_) => parser.reduce::<99>(),
            TokenType::False => parser.reduce::<99>(),
            TokenType::Function => parser.reduce::<99>(),
            TokenType::Nil => parser.reduce::<99>(),
            TokenType::Not => parser.reduce::<99>(),
            TokenType::True => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Len => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::RCurly => parser.reduce::<99>(),
            TokenType::Dots => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<483> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<98>(),
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::Integer(_) => parser.reduce::<98>(),
            TokenType::Float(_) => parser.reduce::<98>(),
            TokenType::False => parser.reduce::<98>(),
            TokenType::Function => parser.reduce::<98>(),
            TokenType::Nil => parser.reduce::<98>(),
            TokenType::Not => parser.reduce::<98>(),
            TokenType::True => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Len => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::RCurly => parser.reduce::<98>(),
            TokenType::Dots => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<484> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(830),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<485> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Exp => parser.goto(818),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<486> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(832),
            TokenType::String(_) => parser.shift(860),
            TokenType::Integer(_) => parser.shift(861),
            TokenType::Float(_) => parser.shift(862),
            TokenType::False => parser.shift(863),
            TokenType::Function => parser.shift(971),
            TokenType::Nil => parser.shift(864),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(865),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(957),
            TokenType::LCurly => parser.shift(972),
            TokenType::Dots => parser.shift(866),
            TokenType::Var => parser.goto(968),
            TokenType::Exp => parser.goto(764),
            TokenType::Prefixexp => parser.goto(833),
            TokenType::Functioncall => parser.goto(969),
            TokenType::Functiondef => parser.goto(919),
            TokenType::Tableconstructor => parser.goto(921),
            TokenType::Unop => parser.goto(927),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<487> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(156),
            TokenType::String(_) => parser.shift(239),
            TokenType::Integer(_) => parser.shift(240),
            TokenType::Float(_) => parser.shift(241),
            TokenType::False => parser.shift(242),
            TokenType::Function => parser.shift(344),
            TokenType::Nil => parser.shift(243),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(334),
            TokenType::LCurly => parser.shift(345),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(342),
            TokenType::Exp => parser.goto(831),
            TokenType::Prefixexp => parser.goto(175),
            TokenType::Functioncall => parser.goto(343),
            TokenType::Functiondef => parser.goto(274),
            TokenType::Tableconstructor => parser.goto(275),
            TokenType::Unop => parser.goto(282),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<488> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(749),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<489> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(747),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<490> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<491> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(723),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<492> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(881),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<493> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Until => parser.reduce::<55>(),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(776),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(755),
            TokenType::Binop => parser.goto(817),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<494> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(901),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.shift(910),
            TokenType::LSquare => parser.shift(768),
            TokenType::LCurly => parser.shift(937),
            TokenType::Colon => parser.shift(899),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Dot => parser.shift(898),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(900),
            TokenType::Tableconstructor => parser.goto(936),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<495> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(739),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<496> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<497> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(875),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<498> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<499> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(885),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<500> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::RParen, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<501> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Until => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<502> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(738),
            TokenType::Namelist => parser.goto(778),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<503> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Until => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<504> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Until => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<505> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(36),
            TokenType::Funcname => parser.goto(761),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<506> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(728),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<507> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Until => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<508> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Then, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(252),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<509> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Until => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<510> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::RSquare => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<511> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Until => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<512> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::RParen => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(485),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<513> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(935),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<514> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Until => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<515> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<55>(),
            TokenType::And => parser.shift(300),
            TokenType::Break => parser.reduce::<55>(),
            TokenType::Do => parser.reduce::<55>(),
            TokenType::End => parser.reduce::<55>(),
            TokenType::For => parser.reduce::<55>(),
            TokenType::Function => parser.reduce::<55>(),
            TokenType::Goto => parser.reduce::<55>(),
            TokenType::If => parser.reduce::<55>(),
            TokenType::Local => parser.reduce::<55>(),
            TokenType::Or => parser.shift(301),
            TokenType::Repeat => parser.reduce::<55>(),
            TokenType::Return => parser.reduce::<55>(),
            TokenType::While => parser.reduce::<55>(),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::LParen => parser.reduce::<55>(),
            TokenType::DoubleColon => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(826),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(742),
            TokenType::Binop => parser.goto(905),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<516> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(883),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<517> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<55>(),
            TokenType::And => parser.shift(300),
            TokenType::Break => parser.reduce::<55>(),
            TokenType::Do => parser.reduce::<55>(),
            TokenType::For => parser.reduce::<55>(),
            TokenType::Function => parser.reduce::<55>(),
            TokenType::Goto => parser.reduce::<55>(),
            TokenType::If => parser.reduce::<55>(),
            TokenType::Local => parser.reduce::<55>(),
            TokenType::Or => parser.shift(301),
            TokenType::Repeat => parser.reduce::<55>(),
            TokenType::Return => parser.reduce::<55>(),
            TokenType::Until => parser.reduce::<55>(),
            TokenType::While => parser.reduce::<55>(),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::LParen => parser.reduce::<55>(),
            TokenType::DoubleColon => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(824),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(753),
            TokenType::Binop => parser.goto(895),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<518> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Do => parser.reduce::<55>(),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Comma => parser.shift(771),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(743),
            TokenType::Binop => parser.goto(780),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<519> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<520> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<521> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<522> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(892),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<523> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<524> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<525> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<526> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::End => parser.reduce::<55>(),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(763),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(734),
            TokenType::Binop => parser.goto(783),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<527> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<528> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(70),
            TokenType::String(_) => parser.shift(84),
            TokenType::Integer(_) => parser.shift(85),
            TokenType::Float(_) => parser.shift(86),
            TokenType::False => parser.shift(87),
            TokenType::Function => parser.shift(132),
            TokenType::Nil => parser.shift(88),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(89),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(123),
            TokenType::LCurly => parser.shift(134),
            TokenType::Dots => parser.shift(90),
            TokenType::Var => parser.goto(127),
            TokenType::Exp => parser.goto(756),
            TokenType::Prefixexp => parser.goto(71),
            TokenType::Functioncall => parser.goto(128),
            TokenType::Functiondef => parser.goto(96),
            TokenType::Tableconstructor => parser.goto(97),
            TokenType::Unop => parser.goto(103),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<529> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(902),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<530> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Do, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(250),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<531> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<532> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<533> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Eof => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(487),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<534> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<535> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<536> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<537> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::RCurly => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(481),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<538> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<539> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<540> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::End => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<541> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Eof => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(611),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<542> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<543> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<544> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<545> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<546> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<547> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<548> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            TokenType::Eof => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<549> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::String(_) => parser.shift(914),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            // Shift(915)-Reduce(65)
            TokenType::LParen => parser.shift(915),
            TokenType::LSquare => parser.shift(804),
            TokenType::LCurly => parser.shift(941),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Colon => parser.shift(911),
            TokenType::Dot => parser.shift(909),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Eof => parser.reduce::<65>(),
            TokenType::Args => parser.goto(913),
            TokenType::Tableconstructor => parser.goto(940),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<550> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<551> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(945),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<552> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::Until => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<553> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<554> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<555> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::Until => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<556> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<557> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<558> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::Until => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<559> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::RParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<560> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::Until => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<561> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::End => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<562> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::Until => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<563> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<564> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<565> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::Until => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<566> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::Until => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<567> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<568> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            TokenType::Eof => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<569> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            TokenType::Eof => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<570> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            TokenType::Eof => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<571> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            TokenType::Eof => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<572> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            TokenType::Eof => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<573> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            TokenType::Eof => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<574> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            TokenType::Eof => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<575> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(781),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<576> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<16>(),
            TokenType::Elseif => parser.shift(808),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatElseif => parser.goto(737),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<577> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(735),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<578> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(779),
            TokenType::Function => parser.shift(736),
            TokenType::Attnamelist => parser.goto(774),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<579> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            TokenType::Eof => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<580> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            TokenType::Eof => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<581> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Until => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<582> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(42),
            TokenType::Do => parser.shift(45),
            TokenType::For => parser.shift(59),
            TokenType::Function => parser.shift(60),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(66),
            TokenType::Local => parser.shift(98),
            TokenType::Repeat => parser.shift(100),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(859),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<583> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Until => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<584> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(746),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<585> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(744),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<586> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::RParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<587> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::RParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<588> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(949),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<589> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(942),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<590> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(407),
            TokenType::String(_) => parser.shift(501),
            TokenType::Integer(_) => parser.shift(503),
            TokenType::Float(_) => parser.shift(504),
            TokenType::False => parser.shift(507),
            TokenType::Function => parser.shift(669),
            TokenType::Nil => parser.shift(509),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(511),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(645),
            TokenType::LCurly => parser.shift(673),
            TokenType::Dots => parser.shift(514),
            TokenType::Var => parser.goto(665),
            TokenType::Exp => parser.goto(840),
            TokenType::Prefixexp => parser.goto(427),
            TokenType::Functioncall => parser.goto(666),
            TokenType::Functiondef => parser.goto(581),
            TokenType::Tableconstructor => parser.goto(583),
            TokenType::Unop => parser.goto(590),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<591> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(782),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<592> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(777),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<593> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::RCurly => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<594> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::RCurly => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<595> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<596> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<597> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(67),
            TokenType::String(_) => parser.shift(77),
            TokenType::Integer(_) => parser.shift(78),
            TokenType::Float(_) => parser.shift(79),
            TokenType::False => parser.shift(80),
            TokenType::Function => parser.shift(133),
            TokenType::Nil => parser.shift(81),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(82),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(122),
            TokenType::LCurly => parser.shift(135),
            TokenType::Dots => parser.shift(83),
            TokenType::Var => parser.goto(129),
            TokenType::Exp => parser.goto(751),
            TokenType::Prefixexp => parser.goto(68),
            TokenType::Functioncall => parser.goto(130),
            TokenType::Functiondef => parser.goto(94),
            TokenType::Tableconstructor => parser.goto(95),
            TokenType::Unop => parser.goto(101),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<598> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(943),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<599> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(416),
            TokenType::String(_) => parser.shift(519),
            TokenType::Integer(_) => parser.shift(520),
            TokenType::Float(_) => parser.shift(521),
            TokenType::False => parser.shift(523),
            TokenType::Function => parser.shift(650),
            TokenType::Nil => parser.shift(524),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(525),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(636),
            TokenType::LCurly => parser.shift(651),
            TokenType::Dots => parser.shift(527),
            TokenType::Var => parser.goto(648),
            TokenType::Exp => parser.goto(834),
            TokenType::Prefixexp => parser.goto(429),
            TokenType::Functioncall => parser.goto(649),
            TokenType::Functiondef => parser.goto(595),
            TokenType::Tableconstructor => parser.goto(596),
            TokenType::Unop => parser.goto(599),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<600> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<601> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<602> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(740),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<603> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(773),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<604> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::RSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<605> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::RSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<606> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(946),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<607> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(490),
            TokenType::String(_) => parser.shift(536),
            TokenType::Integer(_) => parser.shift(538),
            TokenType::Float(_) => parser.shift(539),
            TokenType::False => parser.shift(542),
            TokenType::Function => parser.shift(657),
            TokenType::Nil => parser.shift(544),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(546),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(646),
            TokenType::LCurly => parser.shift(658),
            TokenType::Dots => parser.shift(547),
            TokenType::Var => parser.goto(655),
            TokenType::Exp => parser.goto(835),
            TokenType::Prefixexp => parser.goto(494),
            TokenType::Functioncall => parser.goto(656),
            TokenType::Functiondef => parser.goto(600),
            TokenType::Tableconstructor => parser.goto(601),
            TokenType::Unop => parser.goto(607),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<608> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<609> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Then => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<610> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<611> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(171),
            TokenType::String(_) => parser.shift(273),
            TokenType::Integer(_) => parser.shift(276),
            TokenType::Float(_) => parser.shift(277),
            TokenType::False => parser.shift(278),
            TokenType::Function => parser.shift(370),
            TokenType::Nil => parser.shift(279),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(280),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(366),
            TokenType::LCurly => parser.shift(371),
            TokenType::Dots => parser.shift(281),
            TokenType::Var => parser.goto(368),
            TokenType::Exp => parser.goto(854),
            TokenType::Prefixexp => parser.goto(186),
            TokenType::Functioncall => parser.goto(369),
            TokenType::Functiondef => parser.goto(329),
            TokenType::Tableconstructor => parser.goto(330),
            TokenType::Unop => parser.goto(331),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<612> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(408),
            TokenType::String(_) => parser.shift(531),
            TokenType::Integer(_) => parser.shift(532),
            TokenType::Float(_) => parser.shift(534),
            TokenType::False => parser.shift(535),
            TokenType::Function => parser.shift(662),
            TokenType::Nil => parser.shift(540),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(543),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(647),
            TokenType::LCurly => parser.shift(663),
            TokenType::Dots => parser.shift(545),
            TokenType::Var => parser.goto(659),
            TokenType::Exp => parser.goto(844),
            TokenType::Prefixexp => parser.goto(422),
            TokenType::Functioncall => parser.goto(660),
            TokenType::Functiondef => parser.goto(608),
            TokenType::Tableconstructor => parser.goto(610),
            TokenType::Unop => parser.goto(612),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<613> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(775),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<614> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(767),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<615> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            TokenType::Eof => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<616> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            TokenType::Eof => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<617> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(944),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<618> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(741),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<619> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::Until => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<620> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::Until => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<621> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(417),
            TokenType::String(_) => parser.shift(552),
            TokenType::Integer(_) => parser.shift(555),
            TokenType::Float(_) => parser.shift(558),
            TokenType::False => parser.shift(560),
            TokenType::Function => parser.shift(686),
            TokenType::Nil => parser.shift(562),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(565),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(671),
            TokenType::LCurly => parser.shift(687),
            TokenType::Dots => parser.shift(566),
            TokenType::Var => parser.goto(682),
            TokenType::Exp => parser.goto(857),
            TokenType::Prefixexp => parser.goto(443),
            TokenType::Functioncall => parser.goto(683),
            TokenType::Functiondef => parser.goto(619),
            TokenType::Tableconstructor => parser.goto(620),
            TokenType::Unop => parser.goto(621),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<622> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<6>(),
            TokenType::Break => parser.reduce::<6>(),
            TokenType::Do => parser.reduce::<6>(),
            TokenType::Else => parser.reduce::<6>(),
            TokenType::Elseif => parser.reduce::<6>(),
            TokenType::End => parser.reduce::<6>(),
            TokenType::For => parser.reduce::<6>(),
            TokenType::Function => parser.reduce::<6>(),
            TokenType::Goto => parser.reduce::<6>(),
            TokenType::If => parser.reduce::<6>(),
            TokenType::Local => parser.reduce::<6>(),
            TokenType::Repeat => parser.reduce::<6>(),
            TokenType::Return => parser.reduce::<6>(),
            TokenType::While => parser.reduce::<6>(),
            TokenType::LParen => parser.reduce::<6>(),
            TokenType::DoubleColon => parser.reduce::<6>(),
            TokenType::SemiColon => parser.reduce::<6>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<623> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<9>(),
            TokenType::Break => parser.reduce::<9>(),
            TokenType::Do => parser.reduce::<9>(),
            TokenType::Else => parser.reduce::<9>(),
            TokenType::Elseif => parser.reduce::<9>(),
            TokenType::End => parser.reduce::<9>(),
            TokenType::For => parser.reduce::<9>(),
            TokenType::Function => parser.reduce::<9>(),
            TokenType::Goto => parser.reduce::<9>(),
            TokenType::If => parser.reduce::<9>(),
            TokenType::Local => parser.reduce::<9>(),
            TokenType::Repeat => parser.reduce::<9>(),
            TokenType::Return => parser.reduce::<9>(),
            TokenType::While => parser.reduce::<9>(),
            TokenType::LParen => parser.reduce::<9>(),
            TokenType::DoubleColon => parser.reduce::<9>(),
            TokenType::SemiColon => parser.reduce::<9>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<624> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(770),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<625> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<8>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<8>(),
            TokenType::Do => parser.reduce::<8>(),
            TokenType::Else => parser.reduce::<8>(),
            TokenType::Elseif => parser.reduce::<8>(),
            TokenType::End => parser.reduce::<8>(),
            TokenType::For => parser.reduce::<8>(),
            TokenType::Function => parser.reduce::<8>(),
            TokenType::Goto => parser.reduce::<8>(),
            TokenType::If => parser.reduce::<8>(),
            TokenType::Local => parser.reduce::<8>(),
            TokenType::Repeat => parser.reduce::<8>(),
            TokenType::Return => parser.reduce::<8>(),
            TokenType::While => parser.reduce::<8>(),
            // Reduce(8)-Reduce(70)
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<8>(),
            TokenType::SemiColon => parser.reduce::<8>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<626> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(785),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<627> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::RParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<628> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(846),
            TokenType::LParen => parser.shift(852),
            TokenType::LSquare => parser.shift(47),
            TokenType::LCurly => parser.shift(903),
            TokenType::Colon => parser.shift(839),
            TokenType::Dot => parser.shift(72),
            TokenType::Args => parser.goto(845),
            TokenType::Tableconstructor => parser.goto(897),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<629> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(960),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<630> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<631> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<632> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Eof => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<633> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            TokenType::Eof => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<634> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(411),
            TokenType::String(_) => parser.shift(553),
            TokenType::Integer(_) => parser.shift(554),
            TokenType::Float(_) => parser.shift(556),
            TokenType::False => parser.shift(557),
            TokenType::Function => parser.shift(692),
            TokenType::Nil => parser.shift(561),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(563),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(680),
            TokenType::LCurly => parser.shift(693),
            TokenType::Dots => parser.shift(564),
            TokenType::Var => parser.goto(690),
            TokenType::Exp => parser.goto(855),
            TokenType::Prefixexp => parser.goto(421),
            TokenType::Functioncall => parser.goto(691),
            TokenType::Functiondef => parser.goto(630),
            TokenType::Tableconstructor => parser.goto(631),
            TokenType::Unop => parser.goto(634),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<635> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(548),
            TokenType::String(_) => parser.shift(568),
            TokenType::Integer(_) => parser.shift(569),
            TokenType::Float(_) => parser.shift(570),
            TokenType::False => parser.shift(571),
            TokenType::Function => parser.shift(688),
            TokenType::Nil => parser.shift(572),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(573),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(672),
            TokenType::LCurly => parser.shift(689),
            TokenType::Dots => parser.shift(574),
            TokenType::Var => parser.goto(684),
            TokenType::Exp => parser.goto(856),
            TokenType::Prefixexp => parser.goto(549),
            TokenType::Functioncall => parser.goto(685),
            TokenType::Functiondef => parser.goto(632),
            TokenType::Tableconstructor => parser.goto(633),
            TokenType::Unop => parser.goto(635),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<636> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(837),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<637> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::RCurly => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<638> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::RSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<639> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(953),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<640> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            TokenType::Eof => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<641> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(951),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<642> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(954),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<643> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            TokenType::Eof => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<644> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(963),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<645> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(842),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<646> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(841),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<647> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(843),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<648> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<649> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<650> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(811),
            TokenType::Funcbody => parser.goto(789),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<651> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(961),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<652> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(815),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<653> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(800),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<654> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(790),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<655> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<656> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<657> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(806),
            TokenType::Funcbody => parser.goto(798),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<658> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(958),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<659> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<660> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<661> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(796),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<662> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(822),
            TokenType::Funcbody => parser.goto(793),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<663> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(964),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<664> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(810),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<665> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Until => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<666> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Until => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<667> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(799),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<668> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(791),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<669> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(807),
            TokenType::Funcbody => parser.goto(788),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<670> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(813),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<671> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(850),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<672> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(848),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<673> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(959),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<674> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(802),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<675> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(795),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<676> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(820),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<677> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(801),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<678> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(809),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<679> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(803),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<680> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(851),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<681> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(792),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<682> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::Until => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<683> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::Until => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<684> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Eof => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<685> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Eof => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<686> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(805),
            TokenType::Funcbody => parser.goto(797),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<687> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(952),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<688> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(825),
            TokenType::Funcbody => parser.goto(794),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<689> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(950),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<690> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<691> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<692> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(821),
            TokenType::Funcbody => parser.goto(812),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<693> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(962),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<694> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<42>(),
            TokenType::Colon => parser.reduce::<42>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<695> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<44>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<696> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<33>(),
            TokenType::Break => parser.reduce::<33>(),
            TokenType::Do => parser.reduce::<33>(),
            TokenType::For => parser.reduce::<33>(),
            TokenType::Function => parser.reduce::<33>(),
            TokenType::Goto => parser.reduce::<33>(),
            TokenType::If => parser.reduce::<33>(),
            TokenType::Local => parser.reduce::<33>(),
            TokenType::Repeat => parser.reduce::<33>(),
            TokenType::Return => parser.reduce::<33>(),
            TokenType::While => parser.reduce::<33>(),
            TokenType::Assign => parser.reduce::<33>(),
            TokenType::LParen => parser.reduce::<33>(),
            TokenType::DoubleColon => parser.reduce::<33>(),
            TokenType::SemiColon => parser.reduce::<33>(),
            TokenType::Comma => parser.reduce::<33>(),
            TokenType::Eof => parser.reduce::<33>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<697> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<25>(),
            TokenType::Break => parser.reduce::<25>(),
            TokenType::Do => parser.reduce::<25>(),
            TokenType::For => parser.reduce::<25>(),
            TokenType::Function => parser.reduce::<25>(),
            TokenType::Goto => parser.reduce::<25>(),
            TokenType::If => parser.reduce::<25>(),
            TokenType::Local => parser.reduce::<25>(),
            TokenType::Repeat => parser.reduce::<25>(),
            TokenType::Return => parser.reduce::<25>(),
            TokenType::Until => parser.reduce::<25>(),
            TokenType::While => parser.reduce::<25>(),
            TokenType::LParen => parser.reduce::<25>(),
            TokenType::DoubleColon => parser.reduce::<25>(),
            TokenType::SemiColon => parser.reduce::<25>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<698> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<1>(),
            TokenType::Elseif => parser.reduce::<1>(),
            TokenType::End => parser.reduce::<1>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<699> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<34>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<700> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<25>(),
            TokenType::Break => parser.reduce::<25>(),
            TokenType::Do => parser.reduce::<25>(),
            TokenType::End => parser.reduce::<25>(),
            TokenType::For => parser.reduce::<25>(),
            TokenType::Function => parser.reduce::<25>(),
            TokenType::Goto => parser.reduce::<25>(),
            TokenType::If => parser.reduce::<25>(),
            TokenType::Local => parser.reduce::<25>(),
            TokenType::Repeat => parser.reduce::<25>(),
            TokenType::Return => parser.reduce::<25>(),
            TokenType::While => parser.reduce::<25>(),
            TokenType::LParen => parser.reduce::<25>(),
            TokenType::DoubleColon => parser.reduce::<25>(),
            TokenType::SemiColon => parser.reduce::<25>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<701> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(992),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<702> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1002),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<703> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<704> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::End => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<705> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(974),
            TokenType::Dots => parser.shift(975),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<706> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::Until => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<707> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<38>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<708> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<34>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<709> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Greater => parser.shift(973),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<710> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<5>(),
            TokenType::Elseif => parser.reduce::<5>(),
            TokenType::End => parser.reduce::<5>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<711> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<38>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<712> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Greater => parser.shift(976),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<713> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::Until => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<714> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<715> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(170),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Eof => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(977),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<716> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<717> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Then => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<718> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1001),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<719> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<720> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(991),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<721> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<28>(),
            TokenType::Break => parser.reduce::<28>(),
            TokenType::Do => parser.reduce::<28>(),
            TokenType::For => parser.reduce::<28>(),
            TokenType::Function => parser.reduce::<28>(),
            TokenType::Goto => parser.reduce::<28>(),
            TokenType::If => parser.reduce::<28>(),
            TokenType::Local => parser.reduce::<28>(),
            TokenType::Repeat => parser.reduce::<28>(),
            TokenType::Return => parser.reduce::<28>(),
            TokenType::Until => parser.reduce::<28>(),
            TokenType::While => parser.reduce::<28>(),
            TokenType::LParen => parser.reduce::<28>(),
            TokenType::DoubleColon => parser.reduce::<28>(),
            TokenType::SemiColon => parser.reduce::<28>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<722> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(989),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<723> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::RParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<724> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<725> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(996),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<726> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(978),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<727> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1142),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<728> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<11>(),
            TokenType::Break => parser.reduce::<11>(),
            TokenType::Do => parser.reduce::<11>(),
            TokenType::Else => parser.reduce::<11>(),
            TokenType::Elseif => parser.reduce::<11>(),
            TokenType::End => parser.reduce::<11>(),
            TokenType::For => parser.reduce::<11>(),
            TokenType::Function => parser.reduce::<11>(),
            TokenType::Goto => parser.reduce::<11>(),
            TokenType::If => parser.reduce::<11>(),
            TokenType::Local => parser.reduce::<11>(),
            TokenType::Repeat => parser.reduce::<11>(),
            TokenType::Return => parser.reduce::<11>(),
            TokenType::While => parser.reduce::<11>(),
            TokenType::LParen => parser.reduce::<11>(),
            TokenType::DoubleColon => parser.reduce::<11>(),
            TokenType::SemiColon => parser.reduce::<11>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<729> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1143),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<730> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(980),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<731> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1082),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<732> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1141),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<733> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1119),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<734> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<735> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(580),
            TokenType::LParen => parser.shift(588),
            TokenType::LCurly => parser.shift(644),
            TokenType::Args => parser.goto(979),
            TokenType::Tableconstructor => parser.goto(643),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<736> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(982),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<737> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.shift(1015),
            TokenType::End => parser.reduce::<18>(),
            TokenType::StatElse => parser.goto(981),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<738> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<52>(),
            TokenType::Assign => parser.shift(1037),
            TokenType::Comma => parser.shift(265),
            TokenType::NamelistCont => parser.goto(264),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<739> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(498),
            TokenType::LParen => parser.shift(513),
            TokenType::LCurly => parser.shift(551),
            TokenType::Args => parser.goto(983),
            TokenType::Tableconstructor => parser.goto(550),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<740> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::RSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<741> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<13>(),
            TokenType::Break => parser.reduce::<13>(),
            TokenType::Do => parser.reduce::<13>(),
            TokenType::For => parser.reduce::<13>(),
            TokenType::Function => parser.reduce::<13>(),
            TokenType::Goto => parser.reduce::<13>(),
            TokenType::If => parser.reduce::<13>(),
            TokenType::Local => parser.reduce::<13>(),
            TokenType::Repeat => parser.reduce::<13>(),
            TokenType::Return => parser.reduce::<13>(),
            TokenType::While => parser.reduce::<13>(),
            TokenType::LParen => parser.reduce::<13>(),
            TokenType::DoubleColon => parser.reduce::<13>(),
            TokenType::SemiColon => parser.reduce::<13>(),
            TokenType::Eof => parser.reduce::<13>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<742> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<743> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<744> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(587),
            TokenType::LParen => parser.shift(589),
            TokenType::LCurly => parser.shift(629),
            TokenType::Args => parser.goto(984),
            TokenType::Tableconstructor => parser.goto(627),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<745> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::RParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<746> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::RParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<747> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Then => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<748> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<14>(),
            TokenType::And => parser.shift(300),
            TokenType::Break => parser.reduce::<14>(),
            TokenType::Do => parser.reduce::<14>(),
            TokenType::End => parser.reduce::<14>(),
            TokenType::For => parser.reduce::<14>(),
            TokenType::Function => parser.reduce::<14>(),
            TokenType::Goto => parser.reduce::<14>(),
            TokenType::If => parser.reduce::<14>(),
            TokenType::Local => parser.reduce::<14>(),
            TokenType::Or => parser.shift(301),
            TokenType::Repeat => parser.reduce::<14>(),
            TokenType::Return => parser.reduce::<14>(),
            TokenType::While => parser.reduce::<14>(),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::LParen => parser.reduce::<14>(),
            TokenType::DoubleColon => parser.reduce::<14>(),
            TokenType::SemiColon => parser.reduce::<14>(),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(1039),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<749> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<750> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(1083),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<751> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Do => parser.shift(1014),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(250),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<752> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(1089),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<753> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::Until => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<754> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1012),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<755> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<756> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Then => parser.shift(1013),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(252),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<757> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(1085),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<758> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<28>(),
            TokenType::Break => parser.reduce::<28>(),
            TokenType::Do => parser.reduce::<28>(),
            TokenType::End => parser.reduce::<28>(),
            TokenType::For => parser.reduce::<28>(),
            TokenType::Function => parser.reduce::<28>(),
            TokenType::Goto => parser.reduce::<28>(),
            TokenType::If => parser.reduce::<28>(),
            TokenType::Local => parser.reduce::<28>(),
            TokenType::Repeat => parser.reduce::<28>(),
            TokenType::Return => parser.reduce::<28>(),
            TokenType::While => parser.reduce::<28>(),
            TokenType::LParen => parser.reduce::<28>(),
            TokenType::DoubleColon => parser.reduce::<28>(),
            TokenType::SemiColon => parser.reduce::<28>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<759> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Comma => parser.shift(1031),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(858),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<760> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(1052),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<761> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1011),
            TokenType::Funcbody => parser.goto(987),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<762> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Comma => parser.shift(1030),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(858),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<763> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(408),
            TokenType::String(_) => parser.shift(531),
            TokenType::Integer(_) => parser.shift(532),
            TokenType::Float(_) => parser.shift(534),
            TokenType::False => parser.shift(535),
            TokenType::Function => parser.shift(662),
            TokenType::Nil => parser.shift(540),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(543),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(647),
            TokenType::LCurly => parser.shift(663),
            TokenType::Dots => parser.shift(545),
            TokenType::Var => parser.goto(659),
            TokenType::Exp => parser.goto(1092),
            TokenType::Prefixexp => parser.goto(422),
            TokenType::Functioncall => parser.goto(660),
            TokenType::Functiondef => parser.goto(608),
            TokenType::Tableconstructor => parser.goto(610),
            TokenType::Unop => parser.goto(612),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<764> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<14>(),
            TokenType::And => parser.shift(300),
            TokenType::Break => parser.reduce::<14>(),
            TokenType::Do => parser.reduce::<14>(),
            TokenType::For => parser.reduce::<14>(),
            TokenType::Function => parser.reduce::<14>(),
            TokenType::Goto => parser.reduce::<14>(),
            TokenType::If => parser.reduce::<14>(),
            TokenType::Local => parser.reduce::<14>(),
            TokenType::Or => parser.shift(301),
            TokenType::Repeat => parser.reduce::<14>(),
            TokenType::Return => parser.reduce::<14>(),
            TokenType::Until => parser.reduce::<14>(),
            TokenType::While => parser.reduce::<14>(),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::LParen => parser.reduce::<14>(),
            TokenType::DoubleColon => parser.reduce::<14>(),
            TokenType::SemiColon => parser.reduce::<14>(),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(1032),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<765> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1009),
            TokenType::String(_) => parser.shift(1103),
            TokenType::Integer(_) => parser.shift(1106),
            TokenType::Float(_) => parser.shift(1107),
            TokenType::Else => parser.reduce::<35>(),
            TokenType::Elseif => parser.reduce::<35>(),
            TokenType::End => parser.reduce::<35>(),
            TokenType::False => parser.shift(1108),
            TokenType::Function => parser.shift(1166),
            TokenType::Nil => parser.shift(1110),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1111),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1153),
            TokenType::LCurly => parser.shift(1167),
            TokenType::SemiColon => parser.reduce::<35>(),
            TokenType::Dots => parser.shift(1112),
            TokenType::RetstatExplist => parser.goto(986),
            TokenType::Var => parser.goto(1164),
            TokenType::Explist => parser.goto(995),
            TokenType::Exp => parser.goto(1099),
            TokenType::Prefixexp => parser.goto(1036),
            TokenType::Functioncall => parser.goto(1165),
            TokenType::Functiondef => parser.goto(1128),
            TokenType::Tableconstructor => parser.goto(1129),
            TokenType::Unop => parser.goto(1130),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<766> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(416),
            TokenType::String(_) => parser.shift(519),
            TokenType::Integer(_) => parser.shift(520),
            TokenType::Float(_) => parser.shift(521),
            TokenType::False => parser.shift(523),
            TokenType::Function => parser.shift(650),
            TokenType::Nil => parser.shift(524),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(525),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(636),
            TokenType::LCurly => parser.shift(651),
            TokenType::Dots => parser.shift(527),
            TokenType::Var => parser.goto(648),
            TokenType::Exp => parser.goto(1020),
            TokenType::Prefixexp => parser.goto(429),
            TokenType::Functioncall => parser.goto(649),
            TokenType::Functiondef => parser.goto(595),
            TokenType::Tableconstructor => parser.goto(596),
            TokenType::Unop => parser.goto(599),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<767> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(616),
            TokenType::LParen => parser.shift(617),
            TokenType::LCurly => parser.shift(642),
            TokenType::Args => parser.goto(990),
            TokenType::Tableconstructor => parser.goto(640),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<768> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(1051),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<769> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1007),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<770> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1019),
            TokenType::String(_) => parser.shift(1118),
            TokenType::Integer(_) => parser.shift(1120),
            TokenType::Float(_) => parser.shift(1121),
            TokenType::False => parser.shift(1122),
            TokenType::Function => parser.shift(1182),
            TokenType::Nil => parser.shift(1123),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1124),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1179),
            TokenType::LCurly => parser.shift(1183),
            TokenType::Dots => parser.shift(1125),
            TokenType::Var => parser.goto(1180),
            TokenType::Explist => parser.goto(1016),
            TokenType::Exp => parser.goto(1105),
            TokenType::Prefixexp => parser.goto(1042),
            TokenType::Functioncall => parser.goto(1181),
            TokenType::Functiondef => parser.goto(1149),
            TokenType::Tableconstructor => parser.goto(1150),
            TokenType::Unop => parser.goto(1152),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<771> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(416),
            TokenType::String(_) => parser.shift(519),
            TokenType::Integer(_) => parser.shift(520),
            TokenType::Float(_) => parser.shift(521),
            TokenType::False => parser.shift(523),
            TokenType::Function => parser.shift(650),
            TokenType::Nil => parser.shift(524),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(525),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(636),
            TokenType::LCurly => parser.shift(651),
            TokenType::Dots => parser.shift(527),
            TokenType::Var => parser.goto(648),
            TokenType::Exp => parser.goto(1093),
            TokenType::Prefixexp => parser.goto(429),
            TokenType::Functioncall => parser.goto(649),
            TokenType::Functiondef => parser.goto(595),
            TokenType::Tableconstructor => parser.goto(596),
            TokenType::Unop => parser.goto(599),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<772> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(1061),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<773> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(605),
            TokenType::LParen => parser.shift(606),
            TokenType::LCurly => parser.shift(641),
            TokenType::Args => parser.goto(993),
            TokenType::Tableconstructor => parser.goto(638),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<774> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<27>(),
            TokenType::Break => parser.reduce::<27>(),
            TokenType::Do => parser.reduce::<27>(),
            TokenType::Else => parser.reduce::<27>(),
            TokenType::Elseif => parser.reduce::<27>(),
            TokenType::End => parser.reduce::<27>(),
            TokenType::For => parser.reduce::<27>(),
            TokenType::Function => parser.reduce::<27>(),
            TokenType::Goto => parser.reduce::<27>(),
            TokenType::If => parser.reduce::<27>(),
            TokenType::Local => parser.reduce::<27>(),
            TokenType::Repeat => parser.reduce::<27>(),
            TokenType::Return => parser.reduce::<27>(),
            TokenType::While => parser.reduce::<27>(),
            TokenType::Assign => parser.shift(1035),
            TokenType::LParen => parser.reduce::<27>(),
            TokenType::DoubleColon => parser.reduce::<27>(),
            TokenType::SemiColon => parser.reduce::<27>(),
            TokenType::StatAttexplist => parser.goto(988),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<775> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            TokenType::Eof => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<776> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(407),
            TokenType::String(_) => parser.shift(501),
            TokenType::Integer(_) => parser.shift(503),
            TokenType::Float(_) => parser.shift(504),
            TokenType::False => parser.shift(507),
            TokenType::Function => parser.shift(669),
            TokenType::Nil => parser.shift(509),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(511),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(645),
            TokenType::LCurly => parser.shift(673),
            TokenType::Dots => parser.shift(514),
            TokenType::Var => parser.goto(665),
            TokenType::Exp => parser.goto(1098),
            TokenType::Prefixexp => parser.goto(427),
            TokenType::Functioncall => parser.goto(666),
            TokenType::Functiondef => parser.goto(581),
            TokenType::Tableconstructor => parser.goto(583),
            TokenType::Unop => parser.goto(590),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<777> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(594),
            TokenType::LParen => parser.shift(598),
            TokenType::LCurly => parser.shift(639),
            TokenType::Args => parser.goto(999),
            TokenType::Tableconstructor => parser.goto(637),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<778> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.shift(1025),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<779> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::Else => parser.reduce::<32>(),
            TokenType::Elseif => parser.reduce::<32>(),
            TokenType::End => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(1033),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(1000),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<780> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(416),
            TokenType::String(_) => parser.shift(519),
            TokenType::Integer(_) => parser.shift(520),
            TokenType::Float(_) => parser.shift(521),
            TokenType::False => parser.shift(523),
            TokenType::Function => parser.shift(650),
            TokenType::Nil => parser.shift(524),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(525),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(636),
            TokenType::LCurly => parser.shift(651),
            TokenType::Dots => parser.shift(527),
            TokenType::Var => parser.goto(648),
            TokenType::Exp => parser.goto(1095),
            TokenType::Prefixexp => parser.goto(429),
            TokenType::Functioncall => parser.goto(649),
            TokenType::Functiondef => parser.goto(595),
            TokenType::Tableconstructor => parser.goto(596),
            TokenType::Unop => parser.goto(599),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<781> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            TokenType::Eof => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<782> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::RCurly => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<783> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(408),
            TokenType::String(_) => parser.shift(531),
            TokenType::Integer(_) => parser.shift(532),
            TokenType::Float(_) => parser.shift(534),
            TokenType::False => parser.shift(535),
            TokenType::Function => parser.shift(662),
            TokenType::Nil => parser.shift(540),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(543),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(647),
            TokenType::LCurly => parser.shift(663),
            TokenType::Dots => parser.shift(545),
            TokenType::Var => parser.goto(659),
            TokenType::Exp => parser.goto(1097),
            TokenType::Prefixexp => parser.goto(422),
            TokenType::Functioncall => parser.goto(660),
            TokenType::Functiondef => parser.goto(608),
            TokenType::Tableconstructor => parser.goto(610),
            TokenType::Unop => parser.goto(612),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<784> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<3>(),
            TokenType::Elseif => parser.reduce::<3>(),
            TokenType::End => parser.reduce::<3>(),
            TokenType::Return => parser.reduce::<3>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<785> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::DoubleColon => parser.shift(997),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<786> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1018),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<787> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1006),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<788> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Until => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<789> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<790> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::Until => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<791> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::Until => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<792> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::RSquare => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<793> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<794> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            TokenType::Eof => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<795> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::RParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<796> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::End => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<797> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::Until => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<798> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<799> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Then => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<800> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<801> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            TokenType::Eof => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<802> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<803> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            TokenType::Eof => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<804> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(1079),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<805> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(1005),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<806> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(994),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<807> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(1008),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<808> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(70),
            TokenType::String(_) => parser.shift(84),
            TokenType::Integer(_) => parser.shift(85),
            TokenType::Float(_) => parser.shift(86),
            TokenType::False => parser.shift(87),
            TokenType::Function => parser.shift(132),
            TokenType::Nil => parser.shift(88),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(89),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(123),
            TokenType::LCurly => parser.shift(134),
            TokenType::Dots => parser.shift(90),
            TokenType::Var => parser.goto(127),
            TokenType::Exp => parser.goto(1017),
            TokenType::Prefixexp => parser.goto(71),
            TokenType::Functioncall => parser.goto(128),
            TokenType::Functiondef => parser.goto(96),
            TokenType::Tableconstructor => parser.goto(97),
            TokenType::Unop => parser.goto(103),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<809> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<810> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<811> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(1004),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<812> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<813> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<814> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(548),
            TokenType::String(_) => parser.shift(568),
            TokenType::Integer(_) => parser.shift(569),
            TokenType::Float(_) => parser.shift(570),
            TokenType::False => parser.shift(571),
            TokenType::Function => parser.shift(688),
            TokenType::Nil => parser.shift(572),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(573),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(672),
            TokenType::LCurly => parser.shift(689),
            TokenType::Dots => parser.shift(574),
            TokenType::Var => parser.goto(684),
            TokenType::Exp => parser.goto(1113),
            TokenType::Prefixexp => parser.goto(549),
            TokenType::Functioncall => parser.goto(685),
            TokenType::Functiondef => parser.goto(632),
            TokenType::Tableconstructor => parser.goto(633),
            TokenType::Unop => parser.goto(635),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<815> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Then => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<816> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1003),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<817> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(407),
            TokenType::String(_) => parser.shift(501),
            TokenType::Integer(_) => parser.shift(503),
            TokenType::Float(_) => parser.shift(504),
            TokenType::False => parser.shift(507),
            TokenType::Function => parser.shift(669),
            TokenType::Nil => parser.shift(509),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(511),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(645),
            TokenType::LCurly => parser.shift(673),
            TokenType::Dots => parser.shift(514),
            TokenType::Var => parser.goto(665),
            TokenType::Exp => parser.goto(1096),
            TokenType::Prefixexp => parser.goto(427),
            TokenType::Functioncall => parser.goto(666),
            TokenType::Functiondef => parser.goto(581),
            TokenType::Tableconstructor => parser.goto(583),
            TokenType::Unop => parser.goto(590),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<818> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::RParen, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Comma, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(485),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<819> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1010),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<820> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::RParen => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<821> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(998),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<822> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(1021),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<823> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RCurly => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Comma => parser.reduce::<96>(),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(481),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<824> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(417),
            TokenType::String(_) => parser.shift(552),
            TokenType::Integer(_) => parser.shift(555),
            TokenType::Float(_) => parser.shift(558),
            TokenType::False => parser.shift(560),
            TokenType::Function => parser.shift(686),
            TokenType::Nil => parser.shift(562),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(565),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(671),
            TokenType::LCurly => parser.shift(687),
            TokenType::Dots => parser.shift(566),
            TokenType::Var => parser.goto(682),
            TokenType::Exp => parser.goto(1100),
            TokenType::Prefixexp => parser.goto(443),
            TokenType::Functioncall => parser.goto(683),
            TokenType::Functiondef => parser.goto(619),
            TokenType::Tableconstructor => parser.goto(620),
            TokenType::Unop => parser.goto(621),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<825> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(1022),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<826> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(411),
            TokenType::String(_) => parser.shift(553),
            TokenType::Integer(_) => parser.shift(554),
            TokenType::Float(_) => parser.shift(556),
            TokenType::False => parser.shift(557),
            TokenType::Function => parser.shift(692),
            TokenType::Nil => parser.shift(561),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(563),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(680),
            TokenType::LCurly => parser.shift(693),
            TokenType::Dots => parser.shift(564),
            TokenType::Var => parser.goto(690),
            TokenType::Exp => parser.goto(1104),
            TokenType::Prefixexp => parser.goto(421),
            TokenType::Functioncall => parser.goto(691),
            TokenType::Functiondef => parser.goto(630),
            TokenType::Tableconstructor => parser.goto(631),
            TokenType::Unop => parser.goto(634),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<827> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::RCurly, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::SemiColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Comma, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(481),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<828> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1023),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<829> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(474),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(1038),
            TokenType::Binop => parser.goto(485),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<830> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1024),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<831> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::SemiColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Comma, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eof, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(487),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<832> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::Until => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<833> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::String(_) => parser.shift(1137),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::Until => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            // Shift(1139)-Reduce(65)
            TokenType::LParen => parser.shift(1139),
            TokenType::LSquare => parser.shift(1048),
            TokenType::LCurly => parser.shift(1159),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Colon => parser.shift(1134),
            TokenType::Dot => parser.shift(1133),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(1135),
            TokenType::Tableconstructor => parser.goto(1158),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<834> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(780),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<835> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(858),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<836> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(470),
            TokenType::Concat => parser.shift(320),
            TokenType::Eof => parser.reduce::<55>(),
            TokenType::ExplistCont => parser.goto(1058),
            TokenType::Binop => parser.goto(487),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<837> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(1126),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<838> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::RSquare, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<839> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1029),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<840> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Until => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(817),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<841> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(1115),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<842> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(1131),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<843> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(1138),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<844> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(783),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<845> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::Else => parser.reduce::<72>(),
            TokenType::Elseif => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<846> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::Else => parser.reduce::<78>(),
            TokenType::Elseif => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<847> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<848> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(1140),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<849> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::String(_) => parser.shift(1147),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            // Shift(1148)-Reduce(65)
            TokenType::LParen => parser.shift(1148),
            TokenType::LSquare => parser.shift(1065),
            TokenType::LCurly => parser.shift(1170),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Colon => parser.shift(1145),
            TokenType::Dot => parser.shift(1144),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(1146),
            TokenType::Tableconstructor => parser.goto(1169),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<850> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(1136),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<851> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(1132),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<852> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(1151),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<853> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<55>(),
            TokenType::And => parser.shift(300),
            TokenType::Break => parser.reduce::<55>(),
            TokenType::Do => parser.reduce::<55>(),
            TokenType::For => parser.reduce::<55>(),
            TokenType::Function => parser.reduce::<55>(),
            TokenType::Goto => parser.reduce::<55>(),
            TokenType::If => parser.reduce::<55>(),
            TokenType::Local => parser.reduce::<55>(),
            TokenType::Or => parser.shift(301),
            TokenType::Repeat => parser.reduce::<55>(),
            TokenType::Return => parser.reduce::<55>(),
            TokenType::While => parser.reduce::<55>(),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::LParen => parser.reduce::<55>(),
            TokenType::DoubleColon => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(477),
            TokenType::Concat => parser.shift(320),
            TokenType::Eof => parser.reduce::<55>(),
            TokenType::ExplistCont => parser.goto(1127),
            TokenType::Binop => parser.goto(611),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<854> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::Name(_), Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Break, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Do, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::For, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Function, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Goto, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::If, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Local, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Repeat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Return, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::While, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::LParen, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::DoubleColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::SemiColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Comma, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eof, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(611),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<855> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(905),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<856> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Eof => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(814),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<857> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::Until => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(895),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<858> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(490),
            TokenType::String(_) => parser.shift(536),
            TokenType::Integer(_) => parser.shift(538),
            TokenType::Float(_) => parser.shift(539),
            TokenType::False => parser.shift(542),
            TokenType::Function => parser.shift(657),
            TokenType::Nil => parser.shift(544),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(546),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(646),
            TokenType::LCurly => parser.shift(658),
            TokenType::Dots => parser.shift(547),
            TokenType::Var => parser.goto(655),
            TokenType::Exp => parser.goto(1109),
            TokenType::Prefixexp => parser.goto(494),
            TokenType::Functioncall => parser.goto(656),
            TokenType::Functiondef => parser.goto(600),
            TokenType::Tableconstructor => parser.goto(601),
            TokenType::Unop => parser.goto(607),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<859> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.shift(1091),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<860> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::Until => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<861> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::Until => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<862> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::Until => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<863> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::Until => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<864> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::Until => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<865> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::Until => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<866> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::Until => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<867> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<868> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<869> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<870> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<871> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::End => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<872> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<873> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<874> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<16>(),
            TokenType::Elseif => parser.shift(808),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatElseif => parser.goto(1074),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<875> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::RCurly => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<876> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<16>(),
            TokenType::Elseif => parser.shift(808),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatElseif => parser.goto(1066),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<877> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1026),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<878> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1028),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<879> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<880> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<881> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Eof => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<882> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(1155),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<883> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Eof => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<884> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1034),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<885> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::RParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<886> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1041),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<887> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::Until => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<888> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::Until => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<889> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(1160),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<890> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1078),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<891> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1087),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<892> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(1088),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<893> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<894> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<895> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(417),
            TokenType::String(_) => parser.shift(552),
            TokenType::Integer(_) => parser.shift(555),
            TokenType::Float(_) => parser.shift(558),
            TokenType::False => parser.shift(560),
            TokenType::Function => parser.shift(686),
            TokenType::Nil => parser.shift(562),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(565),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(671),
            TokenType::LCurly => parser.shift(687),
            TokenType::Dots => parser.shift(566),
            TokenType::Var => parser.goto(682),
            TokenType::Exp => parser.goto(1116),
            TokenType::Prefixexp => parser.goto(443),
            TokenType::Functioncall => parser.goto(683),
            TokenType::Functiondef => parser.goto(619),
            TokenType::Tableconstructor => parser.goto(620),
            TokenType::Unop => parser.goto(621),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<896> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(1161),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<897> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::Else => parser.reduce::<77>(),
            TokenType::Elseif => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<898> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1075),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<899> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1043),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<900> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<901> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<902> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::RSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<903> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1163),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<904> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1081),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<905> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(411),
            TokenType::String(_) => parser.shift(553),
            TokenType::Integer(_) => parser.shift(554),
            TokenType::Float(_) => parser.shift(556),
            TokenType::False => parser.shift(557),
            TokenType::Function => parser.shift(692),
            TokenType::Nil => parser.shift(561),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(563),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(680),
            TokenType::LCurly => parser.shift(693),
            TokenType::Dots => parser.shift(564),
            TokenType::Var => parser.goto(690),
            TokenType::Exp => parser.goto(1117),
            TokenType::Prefixexp => parser.goto(421),
            TokenType::Functioncall => parser.goto(691),
            TokenType::Functiondef => parser.goto(630),
            TokenType::Tableconstructor => parser.goto(631),
            TokenType::Unop => parser.goto(634),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<906> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1080),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<907> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Until => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<908> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Until => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<909> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1086),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<910> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(1162),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<911> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1077),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<912> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(1154),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<913> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            TokenType::Eof => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<914> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            TokenType::Eof => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<915> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(1157),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<916> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1076),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<917> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<918> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<919> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::Until => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<920> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1073),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<921> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::Until => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<922> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1062),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<923> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<924> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<925> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(847),
            TokenType::String(_) => parser.shift(867),
            TokenType::Integer(_) => parser.shift(868),
            TokenType::Float(_) => parser.shift(869),
            TokenType::False => parser.shift(870),
            TokenType::Function => parser.shift(967),
            TokenType::Nil => parser.shift(871),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(872),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(955),
            TokenType::LCurly => parser.shift(970),
            TokenType::Dots => parser.shift(873),
            TokenType::Var => parser.goto(965),
            TokenType::Exp => parser.goto(1102),
            TokenType::Prefixexp => parser.goto(849),
            TokenType::Functioncall => parser.goto(966),
            TokenType::Functiondef => parser.goto(917),
            TokenType::Tableconstructor => parser.goto(918),
            TokenType::Unop => parser.goto(925),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<926> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(1156),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<927> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(832),
            TokenType::String(_) => parser.shift(860),
            TokenType::Integer(_) => parser.shift(861),
            TokenType::Float(_) => parser.shift(862),
            TokenType::False => parser.shift(863),
            TokenType::Function => parser.shift(971),
            TokenType::Nil => parser.shift(864),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(865),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(957),
            TokenType::LCurly => parser.shift(972),
            TokenType::Dots => parser.shift(866),
            TokenType::Var => parser.goto(968),
            TokenType::Exp => parser.goto(1114),
            TokenType::Prefixexp => parser.goto(833),
            TokenType::Functioncall => parser.goto(969),
            TokenType::Functiondef => parser.goto(919),
            TokenType::Tableconstructor => parser.goto(921),
            TokenType::Unop => parser.goto(927),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<928> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1064),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<929> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<930> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1172),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<931> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Until => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<932> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<933> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1178),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<934> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1173),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<935> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1046),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<936> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<937> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1168),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<938> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::Until => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<939> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1174),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<940> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            TokenType::Eof => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<941> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1176),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<942> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1049),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<943> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1047),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<944> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1067),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<945> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1072),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<946> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1060),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<947> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<948> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1177),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<949> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1050),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<950> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1044),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<951> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1045),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<952> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1063),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<953> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1070),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<954> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1071),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<955> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(1101),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<956> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<92>(),
            TokenType::SemiColon => parser.shift(482),
            TokenType::Comma => parser.shift(483),
            TokenType::FieldlistCont => parser.goto(1090),
            TokenType::Fieldsep => parser.goto(469),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<957> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(1094),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<958> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1059),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<959> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1053),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<960> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1057),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<961> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1068),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<962> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1055),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<963> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1084),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<964> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1069),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<965> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<966> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<967> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1040),
            TokenType::Funcbody => parser.goto(1027),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<968> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::Until => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<969> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::Until => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<970> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1175),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<971> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1056),
            TokenType::Funcbody => parser.goto(1054),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<972> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1171),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<973> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<33>(),
            TokenType::Break => parser.reduce::<33>(),
            TokenType::Do => parser.reduce::<33>(),
            TokenType::For => parser.reduce::<33>(),
            TokenType::Function => parser.reduce::<33>(),
            TokenType::Goto => parser.reduce::<33>(),
            TokenType::If => parser.reduce::<33>(),
            TokenType::Local => parser.reduce::<33>(),
            TokenType::Repeat => parser.reduce::<33>(),
            TokenType::Return => parser.reduce::<33>(),
            TokenType::Until => parser.reduce::<33>(),
            TokenType::While => parser.reduce::<33>(),
            TokenType::Assign => parser.reduce::<33>(),
            TokenType::LParen => parser.reduce::<33>(),
            TokenType::DoubleColon => parser.reduce::<33>(),
            TokenType::SemiColon => parser.reduce::<33>(),
            TokenType::Comma => parser.reduce::<33>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<974> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<84>(),
            TokenType::Comma => parser.shift(705),
            TokenType::ParlistCont => parser.goto(1185),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<975> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<976> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<33>(),
            TokenType::Break => parser.reduce::<33>(),
            TokenType::Do => parser.reduce::<33>(),
            TokenType::End => parser.reduce::<33>(),
            TokenType::For => parser.reduce::<33>(),
            TokenType::Function => parser.reduce::<33>(),
            TokenType::Goto => parser.reduce::<33>(),
            TokenType::If => parser.reduce::<33>(),
            TokenType::Local => parser.reduce::<33>(),
            TokenType::Repeat => parser.reduce::<33>(),
            TokenType::Return => parser.reduce::<33>(),
            TokenType::While => parser.reduce::<33>(),
            TokenType::Assign => parser.reduce::<33>(),
            TokenType::LParen => parser.reduce::<33>(),
            TokenType::DoubleColon => parser.reduce::<33>(),
            TokenType::SemiColon => parser.reduce::<33>(),
            TokenType::Comma => parser.reduce::<33>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<977> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(409),
            TokenType::Eof => parser.reduce::<30>(),
            TokenType::AttnamelistCont => parser.goto(1196),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<978> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::End => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(412),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(1187),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<979> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            TokenType::Eof => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<980> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::Until => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(414),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(1186),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<981> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1188),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<982> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1011),
            TokenType::Funcbody => parser.goto(1184),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<983> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<984> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::RParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<985> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1301),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<986> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<37>(),
            TokenType::Elseif => parser.reduce::<37>(),
            TokenType::End => parser.reduce::<37>(),
            TokenType::SemiColon => parser.shift(1191),
            TokenType::RetstatEnd => parser.goto(1189),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<987> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<24>(),
            TokenType::Break => parser.reduce::<24>(),
            TokenType::Do => parser.reduce::<24>(),
            TokenType::Else => parser.reduce::<24>(),
            TokenType::Elseif => parser.reduce::<24>(),
            TokenType::End => parser.reduce::<24>(),
            TokenType::For => parser.reduce::<24>(),
            TokenType::Function => parser.reduce::<24>(),
            TokenType::Goto => parser.reduce::<24>(),
            TokenType::If => parser.reduce::<24>(),
            TokenType::Local => parser.reduce::<24>(),
            TokenType::Repeat => parser.reduce::<24>(),
            TokenType::Return => parser.reduce::<24>(),
            TokenType::While => parser.reduce::<24>(),
            TokenType::LParen => parser.reduce::<24>(),
            TokenType::DoubleColon => parser.reduce::<24>(),
            TokenType::SemiColon => parser.reduce::<24>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<988> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<26>(),
            TokenType::Break => parser.reduce::<26>(),
            TokenType::Do => parser.reduce::<26>(),
            TokenType::Else => parser.reduce::<26>(),
            TokenType::Elseif => parser.reduce::<26>(),
            TokenType::End => parser.reduce::<26>(),
            TokenType::For => parser.reduce::<26>(),
            TokenType::Function => parser.reduce::<26>(),
            TokenType::Goto => parser.reduce::<26>(),
            TokenType::If => parser.reduce::<26>(),
            TokenType::Local => parser.reduce::<26>(),
            TokenType::Repeat => parser.reduce::<26>(),
            TokenType::Return => parser.reduce::<26>(),
            TokenType::While => parser.reduce::<26>(),
            TokenType::LParen => parser.reduce::<26>(),
            TokenType::DoubleColon => parser.reduce::<26>(),
            TokenType::SemiColon => parser.reduce::<26>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<989> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1320),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<990> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            TokenType::Eof => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<991> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1278),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<992> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1317),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<993> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::RSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<994> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1211),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<995> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<36>(),
            TokenType::Elseif => parser.reduce::<36>(),
            TokenType::End => parser.reduce::<36>(),
            TokenType::SemiColon => parser.reduce::<36>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<996> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1275),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<997> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<39>(),
            TokenType::Break => parser.reduce::<39>(),
            TokenType::Do => parser.reduce::<39>(),
            TokenType::Else => parser.reduce::<39>(),
            TokenType::Elseif => parser.reduce::<39>(),
            TokenType::End => parser.reduce::<39>(),
            TokenType::For => parser.reduce::<39>(),
            TokenType::Function => parser.reduce::<39>(),
            TokenType::Goto => parser.reduce::<39>(),
            TokenType::If => parser.reduce::<39>(),
            TokenType::Local => parser.reduce::<39>(),
            TokenType::Repeat => parser.reduce::<39>(),
            TokenType::Return => parser.reduce::<39>(),
            TokenType::While => parser.reduce::<39>(),
            TokenType::LParen => parser.reduce::<39>(),
            TokenType::DoubleColon => parser.reduce::<39>(),
            TokenType::SemiColon => parser.reduce::<39>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<998> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1209),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<999> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::RCurly => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1000> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::Else => parser.reduce::<30>(),
            TokenType::Elseif => parser.reduce::<30>(),
            TokenType::End => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(1194),
            TokenType::AttnamelistCont => parser.goto(1190),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1001> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1306),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1002> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1302),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1003> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::RSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1004> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1205),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1005> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1216),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1006> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            TokenType::Eof => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1007> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1322),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1008> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1212),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1009> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Else => parser.reduce::<48>(),
            TokenType::Elseif => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1010> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::RParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1011> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(1192),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1012> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1313),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1013> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(468),
            TokenType::Do => parser.shift(484),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(502),
            TokenType::Function => parser.shift(505),
            TokenType::Goto => parser.shift(506),
            TokenType::If => parser.shift(528),
            TokenType::Local => parser.shift(578),
            TokenType::Repeat => parser.shift(582),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(597),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(626),
            TokenType::SemiColon => parser.shift(622),
            TokenType::Block => parser.goto(1283),
            TokenType::BlockStat => parser.goto(396),
            TokenType::Stat => parser.goto(420),
            TokenType::Label => parser.goto(623),
            TokenType::Varlist => parser.goto(624),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(628),
            TokenType::Functioncall => parser.goto(625),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1014> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1316),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1015> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1305),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1016> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<7>(),
            TokenType::Break => parser.reduce::<7>(),
            TokenType::Do => parser.reduce::<7>(),
            TokenType::Else => parser.reduce::<7>(),
            TokenType::Elseif => parser.reduce::<7>(),
            TokenType::End => parser.reduce::<7>(),
            TokenType::For => parser.reduce::<7>(),
            TokenType::Function => parser.reduce::<7>(),
            TokenType::Goto => parser.reduce::<7>(),
            TokenType::If => parser.reduce::<7>(),
            TokenType::Local => parser.reduce::<7>(),
            TokenType::Repeat => parser.reduce::<7>(),
            TokenType::Return => parser.reduce::<7>(),
            TokenType::While => parser.reduce::<7>(),
            TokenType::LParen => parser.reduce::<7>(),
            TokenType::DoubleColon => parser.reduce::<7>(),
            TokenType::SemiColon => parser.reduce::<7>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1017> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Then => parser.shift(1217),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(252),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1018> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::RCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1019> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::Else => parser.reduce::<48>(),
            TokenType::Elseif => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1020> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Do => parser.reduce::<21>(),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Comma => parser.shift(1254),
            TokenType::Concat => parser.shift(320),
            TokenType::StatForexp => parser.goto(1193),
            TokenType::Binop => parser.goto(780),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1021> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1213),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1022> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1224),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1023> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            TokenType::Eof => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1024> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<12>(),
            TokenType::Break => parser.reduce::<12>(),
            TokenType::Do => parser.reduce::<12>(),
            TokenType::Else => parser.reduce::<12>(),
            TokenType::Elseif => parser.reduce::<12>(),
            TokenType::End => parser.reduce::<12>(),
            TokenType::For => parser.reduce::<12>(),
            TokenType::Function => parser.reduce::<12>(),
            TokenType::Goto => parser.reduce::<12>(),
            TokenType::If => parser.reduce::<12>(),
            TokenType::Local => parser.reduce::<12>(),
            TokenType::Repeat => parser.reduce::<12>(),
            TokenType::Return => parser.reduce::<12>(),
            TokenType::While => parser.reduce::<12>(),
            TokenType::LParen => parser.reduce::<12>(),
            TokenType::DoubleColon => parser.reduce::<12>(),
            TokenType::SemiColon => parser.reduce::<12>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1025> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(416),
            TokenType::String(_) => parser.shift(519),
            TokenType::Integer(_) => parser.shift(520),
            TokenType::Float(_) => parser.shift(521),
            TokenType::False => parser.shift(523),
            TokenType::Function => parser.shift(650),
            TokenType::Nil => parser.shift(524),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(525),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(636),
            TokenType::LCurly => parser.shift(651),
            TokenType::Dots => parser.shift(527),
            TokenType::Var => parser.goto(648),
            TokenType::Explist => parser.goto(1195),
            TokenType::Exp => parser.goto(518),
            TokenType::Prefixexp => parser.goto(429),
            TokenType::Functioncall => parser.goto(649),
            TokenType::Functiondef => parser.goto(595),
            TokenType::Tableconstructor => parser.goto(596),
            TokenType::Unop => parser.goto(599),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1026> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1027> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1028> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(880),
            TokenType::LParen => parser.shift(882),
            TokenType::LCurly => parser.shift(930),
            TokenType::Args => parser.goto(1199),
            TokenType::Tableconstructor => parser.goto(929),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1029> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(846),
            TokenType::LParen => parser.shift(852),
            TokenType::LCurly => parser.shift(903),
            TokenType::Args => parser.goto(1197),
            TokenType::Tableconstructor => parser.goto(897),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1030> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(416),
            TokenType::String(_) => parser.shift(519),
            TokenType::Integer(_) => parser.shift(520),
            TokenType::Float(_) => parser.shift(521),
            TokenType::False => parser.shift(523),
            TokenType::Function => parser.shift(650),
            TokenType::Nil => parser.shift(524),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(525),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(636),
            TokenType::LCurly => parser.shift(651),
            TokenType::Dots => parser.shift(527),
            TokenType::Var => parser.goto(648),
            TokenType::Exp => parser.goto(1228),
            TokenType::Prefixexp => parser.goto(429),
            TokenType::Functioncall => parser.goto(649),
            TokenType::Functiondef => parser.goto(595),
            TokenType::Tableconstructor => parser.goto(596),
            TokenType::Unop => parser.goto(599),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1031> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(416),
            TokenType::String(_) => parser.shift(519),
            TokenType::Integer(_) => parser.shift(520),
            TokenType::Float(_) => parser.shift(521),
            TokenType::False => parser.shift(523),
            TokenType::Function => parser.shift(650),
            TokenType::Nil => parser.shift(524),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(525),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(636),
            TokenType::LCurly => parser.shift(651),
            TokenType::Dots => parser.shift(527),
            TokenType::Var => parser.goto(648),
            TokenType::Exp => parser.goto(1218),
            TokenType::Prefixexp => parser.goto(429),
            TokenType::Functioncall => parser.goto(649),
            TokenType::Functiondef => parser.goto(595),
            TokenType::Tableconstructor => parser.goto(596),
            TokenType::Unop => parser.goto(599),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1032> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(832),
            TokenType::String(_) => parser.shift(860),
            TokenType::Integer(_) => parser.shift(861),
            TokenType::Float(_) => parser.shift(862),
            TokenType::False => parser.shift(863),
            TokenType::Function => parser.shift(971),
            TokenType::Nil => parser.shift(864),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(865),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(957),
            TokenType::LCurly => parser.shift(972),
            TokenType::Dots => parser.shift(866),
            TokenType::Var => parser.goto(968),
            TokenType::Exp => parser.goto(1282),
            TokenType::Prefixexp => parser.goto(833),
            TokenType::Functioncall => parser.goto(969),
            TokenType::Functiondef => parser.goto(919),
            TokenType::Tableconstructor => parser.goto(921),
            TokenType::Unop => parser.goto(927),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1033> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1198),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1034> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::Until => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1035> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1019),
            TokenType::String(_) => parser.shift(1118),
            TokenType::Integer(_) => parser.shift(1120),
            TokenType::Float(_) => parser.shift(1121),
            TokenType::False => parser.shift(1122),
            TokenType::Function => parser.shift(1182),
            TokenType::Nil => parser.shift(1123),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1124),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1179),
            TokenType::LCurly => parser.shift(1183),
            TokenType::Dots => parser.shift(1125),
            TokenType::Var => parser.goto(1180),
            TokenType::Explist => parser.goto(1214),
            TokenType::Exp => parser.goto(1105),
            TokenType::Prefixexp => parser.goto(1042),
            TokenType::Functioncall => parser.goto(1181),
            TokenType::Functiondef => parser.goto(1149),
            TokenType::Tableconstructor => parser.goto(1150),
            TokenType::Unop => parser.goto(1152),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1036> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1299),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Else => parser.reduce::<65>(),
            TokenType::Elseif => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.shift(1300),
            TokenType::LSquare => parser.shift(1257),
            TokenType::LCurly => parser.shift(1319),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Colon => parser.shift(1297),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Dot => parser.shift(1296),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(1298),
            TokenType::Tableconstructor => parser.goto(1318),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1037> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(490),
            TokenType::String(_) => parser.shift(536),
            TokenType::Integer(_) => parser.shift(538),
            TokenType::Float(_) => parser.shift(539),
            TokenType::False => parser.shift(542),
            TokenType::Function => parser.shift(657),
            TokenType::Nil => parser.shift(544),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(546),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(646),
            TokenType::LCurly => parser.shift(658),
            TokenType::Dots => parser.shift(547),
            TokenType::Var => parser.goto(655),
            TokenType::Exp => parser.goto(1249),
            TokenType::Prefixexp => parser.goto(494),
            TokenType::Functioncall => parser.goto(656),
            TokenType::Functiondef => parser.goto(600),
            TokenType::Tableconstructor => parser.goto(601),
            TokenType::Unop => parser.goto(607),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1038> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1039> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(847),
            TokenType::String(_) => parser.shift(867),
            TokenType::Integer(_) => parser.shift(868),
            TokenType::Float(_) => parser.shift(869),
            TokenType::False => parser.shift(870),
            TokenType::Function => parser.shift(967),
            TokenType::Nil => parser.shift(871),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(872),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(955),
            TokenType::LCurly => parser.shift(970),
            TokenType::Dots => parser.shift(873),
            TokenType::Var => parser.goto(965),
            TokenType::Exp => parser.goto(1285),
            TokenType::Prefixexp => parser.goto(849),
            TokenType::Functioncall => parser.goto(966),
            TokenType::Functiondef => parser.goto(917),
            TokenType::Tableconstructor => parser.goto(918),
            TokenType::Unop => parser.goto(925),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1040> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(1227),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1041> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(888),
            TokenType::LParen => parser.shift(889),
            TokenType::LCurly => parser.shift(939),
            TokenType::Args => parser.goto(1266),
            TokenType::Tableconstructor => parser.goto(938),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1042> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::String(_) => parser.shift(1311),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::Else => parser.reduce::<65>(),
            TokenType::Elseif => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            // Shift(1314)-Reduce(65)
            TokenType::LParen => parser.shift(1314),
            TokenType::LSquare => parser.shift(1255),
            TokenType::LCurly => parser.shift(1327),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Colon => parser.shift(1308),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Dot => parser.shift(1307),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(1309),
            TokenType::Tableconstructor => parser.goto(1326),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1043> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(901),
            TokenType::LParen => parser.shift(910),
            TokenType::LCurly => parser.shift(937),
            TokenType::Args => parser.goto(1201),
            TokenType::Tableconstructor => parser.goto(936),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1044> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            TokenType::Eof => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1045> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::RSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1046> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1047> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::RCurly => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1048> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(1272),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1049> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1050> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            TokenType::Eof => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1051> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1207),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1052> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1219),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1053> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Until => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1054> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::Until => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1055> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1056> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(1210),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1057> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::RParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1058> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Eof => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1059> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1060> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::RSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1061> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1204),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1062> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(924),
            TokenType::LParen => parser.shift(926),
            TokenType::LCurly => parser.shift(948),
            TokenType::Args => parser.goto(1202),
            TokenType::Tableconstructor => parser.goto(947),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1063> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::Until => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1064> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<13>(),
            TokenType::Break => parser.reduce::<13>(),
            TokenType::Do => parser.reduce::<13>(),
            TokenType::End => parser.reduce::<13>(),
            TokenType::For => parser.reduce::<13>(),
            TokenType::Function => parser.reduce::<13>(),
            TokenType::Goto => parser.reduce::<13>(),
            TokenType::If => parser.reduce::<13>(),
            TokenType::Local => parser.reduce::<13>(),
            TokenType::Repeat => parser.reduce::<13>(),
            TokenType::Return => parser.reduce::<13>(),
            TokenType::While => parser.reduce::<13>(),
            TokenType::LParen => parser.reduce::<13>(),
            TokenType::DoubleColon => parser.reduce::<13>(),
            TokenType::SemiColon => parser.reduce::<13>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1065> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(1274),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1066> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.shift(1015),
            TokenType::End => parser.reduce::<18>(),
            TokenType::StatElse => parser.goto(1203),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1067> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            TokenType::Eof => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1068> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1069> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1070> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1071> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            TokenType::Eof => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1072> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1073> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::End => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1074> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.shift(1015),
            TokenType::End => parser.reduce::<18>(),
            TokenType::StatElse => parser.goto(1215),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1075> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1076> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<13>(),
            TokenType::Break => parser.reduce::<13>(),
            TokenType::Do => parser.reduce::<13>(),
            TokenType::For => parser.reduce::<13>(),
            TokenType::Function => parser.reduce::<13>(),
            TokenType::Goto => parser.reduce::<13>(),
            TokenType::If => parser.reduce::<13>(),
            TokenType::Local => parser.reduce::<13>(),
            TokenType::Repeat => parser.reduce::<13>(),
            TokenType::Return => parser.reduce::<13>(),
            TokenType::Until => parser.reduce::<13>(),
            TokenType::While => parser.reduce::<13>(),
            TokenType::LParen => parser.reduce::<13>(),
            TokenType::DoubleColon => parser.reduce::<13>(),
            TokenType::SemiColon => parser.reduce::<13>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1077> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(914),
            TokenType::LParen => parser.shift(915),
            TokenType::LCurly => parser.shift(941),
            TokenType::Args => parser.goto(1206),
            TokenType::Tableconstructor => parser.goto(940),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1078> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::End => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1079> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1208),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1080> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(908),
            TokenType::LParen => parser.shift(912),
            TokenType::LCurly => parser.shift(934),
            TokenType::Args => parser.goto(1200),
            TokenType::Tableconstructor => parser.goto(931),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1081> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Until => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1082> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1221),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1083> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1222),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1084> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            TokenType::Eof => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1085> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1223),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1086> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            TokenType::Eof => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1087> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(894),
            TokenType::LParen => parser.shift(896),
            TokenType::LCurly => parser.shift(933),
            TokenType::Args => parser.goto(1225),
            TokenType::Tableconstructor => parser.goto(932),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1088> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(432),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LCurly => parser.shift(359),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(1277),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1089> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1220),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1090> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1091> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1279),
            TokenType::String(_) => parser.shift(1286),
            TokenType::Integer(_) => parser.shift(1287),
            TokenType::Float(_) => parser.shift(1288),
            TokenType::False => parser.shift(1289),
            TokenType::Function => parser.shift(1333),
            TokenType::Nil => parser.shift(1290),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1291),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1330),
            TokenType::LCurly => parser.shift(1334),
            TokenType::Dots => parser.shift(1292),
            TokenType::Var => parser.goto(1331),
            TokenType::Exp => parser.goto(1253),
            TokenType::Prefixexp => parser.goto(1281),
            TokenType::Functioncall => parser.goto(1332),
            TokenType::Functiondef => parser.goto(1310),
            TokenType::Tableconstructor => parser.goto(1312),
            TokenType::Unop => parser.goto(1315),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1092> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::End => parser.reduce::<55>(),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(763),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(1262),
            TokenType::Binop => parser.goto(783),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1093> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Do => parser.reduce::<55>(),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Comma => parser.shift(771),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(1261),
            TokenType::Binop => parser.goto(780),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1094> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(1293),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1095> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Do, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Comma, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(780),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1096> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Until, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::SemiColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Comma, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(817),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1097> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::End, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::SemiColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Comma, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(783),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1098> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Until => parser.reduce::<55>(),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(776),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(1263),
            TokenType::Binop => parser.goto(817),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1099> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Else => parser.reduce::<55>(),
            TokenType::Elseif => parser.reduce::<55>(),
            TokenType::End => parser.reduce::<55>(),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(1260),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(1226),
            TokenType::Binop => parser.goto(1271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1100> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<55>(),
            TokenType::And => parser.shift(300),
            TokenType::Break => parser.reduce::<55>(),
            TokenType::Do => parser.reduce::<55>(),
            TokenType::For => parser.reduce::<55>(),
            TokenType::Function => parser.reduce::<55>(),
            TokenType::Goto => parser.reduce::<55>(),
            TokenType::If => parser.reduce::<55>(),
            TokenType::Local => parser.reduce::<55>(),
            TokenType::Or => parser.shift(301),
            TokenType::Repeat => parser.reduce::<55>(),
            TokenType::Return => parser.reduce::<55>(),
            TokenType::Until => parser.reduce::<55>(),
            TokenType::While => parser.reduce::<55>(),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::LParen => parser.reduce::<55>(),
            TokenType::DoubleColon => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(824),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(1304),
            TokenType::Binop => parser.goto(895),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1101> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(1295),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1102> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(1039),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1103> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Else => parser.reduce::<60>(),
            TokenType::Elseif => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1104> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<55>(),
            TokenType::And => parser.shift(300),
            TokenType::Break => parser.reduce::<55>(),
            TokenType::Do => parser.reduce::<55>(),
            TokenType::End => parser.reduce::<55>(),
            TokenType::For => parser.reduce::<55>(),
            TokenType::Function => parser.reduce::<55>(),
            TokenType::Goto => parser.reduce::<55>(),
            TokenType::If => parser.reduce::<55>(),
            TokenType::Local => parser.reduce::<55>(),
            TokenType::Or => parser.shift(301),
            TokenType::Repeat => parser.reduce::<55>(),
            TokenType::Return => parser.reduce::<55>(),
            TokenType::While => parser.reduce::<55>(),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::LParen => parser.reduce::<55>(),
            TokenType::DoubleColon => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(826),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(1294),
            TokenType::Binop => parser.goto(905),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1105> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<55>(),
            TokenType::And => parser.shift(300),
            TokenType::Break => parser.reduce::<55>(),
            TokenType::Do => parser.reduce::<55>(),
            TokenType::Else => parser.reduce::<55>(),
            TokenType::Elseif => parser.reduce::<55>(),
            TokenType::End => parser.reduce::<55>(),
            TokenType::For => parser.reduce::<55>(),
            TokenType::Function => parser.reduce::<55>(),
            TokenType::Goto => parser.reduce::<55>(),
            TokenType::If => parser.reduce::<55>(),
            TokenType::Local => parser.reduce::<55>(),
            TokenType::Or => parser.shift(301),
            TokenType::Repeat => parser.reduce::<55>(),
            TokenType::Return => parser.reduce::<55>(),
            TokenType::While => parser.reduce::<55>(),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::LParen => parser.reduce::<55>(),
            TokenType::DoubleColon => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(1269),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(1252),
            TokenType::Binop => parser.goto(1303),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1106> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Else => parser.reduce::<61>(),
            TokenType::Elseif => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1107> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Else => parser.reduce::<62>(),
            TokenType::Elseif => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1108> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Else => parser.reduce::<58>(),
            TokenType::Elseif => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1109> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Comma, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(858),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1110> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Else => parser.reduce::<57>(),
            TokenType::Elseif => parser.reduce::<57>(),
            TokenType::End => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1111> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Else => parser.reduce::<59>(),
            TokenType::Elseif => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1112> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Else => parser.reduce::<63>(),
            TokenType::Elseif => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1113> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::Name(_), Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Break, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Do, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::For, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Function, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Goto, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::If, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Local, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Repeat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Return, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::While, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::LParen, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::DoubleColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::SemiColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eof, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(814),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1114> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::Until => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(1032),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1115> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1116> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::Name(_), Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Break, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Do, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::For, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Function, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Goto, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::If, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Local, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Repeat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Return, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Until, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::While, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::LParen, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::DoubleColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::SemiColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Comma, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(895),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1117> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::Name(_), Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Break, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Do, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::End, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::For, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Function, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Goto, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::If, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Local, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Repeat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Return, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::While, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::LParen, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::DoubleColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::SemiColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Comma, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(905),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1118> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::Else => parser.reduce::<60>(),
            TokenType::Elseif => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1119> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1240),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1120> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::Else => parser.reduce::<61>(),
            TokenType::Elseif => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1121> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::Else => parser.reduce::<62>(),
            TokenType::Elseif => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1122> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::Else => parser.reduce::<58>(),
            TokenType::Elseif => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1123> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::Else => parser.reduce::<57>(),
            TokenType::Elseif => parser.reduce::<57>(),
            TokenType::End => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1124> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::Else => parser.reduce::<59>(),
            TokenType::Elseif => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1125> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::Else => parser.reduce::<63>(),
            TokenType::Elseif => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1126> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1127> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<56>(),
            TokenType::Break => parser.reduce::<56>(),
            TokenType::Do => parser.reduce::<56>(),
            TokenType::For => parser.reduce::<56>(),
            TokenType::Function => parser.reduce::<56>(),
            TokenType::Goto => parser.reduce::<56>(),
            TokenType::If => parser.reduce::<56>(),
            TokenType::Local => parser.reduce::<56>(),
            TokenType::Repeat => parser.reduce::<56>(),
            TokenType::Return => parser.reduce::<56>(),
            TokenType::While => parser.reduce::<56>(),
            TokenType::LParen => parser.reduce::<56>(),
            TokenType::DoubleColon => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Eof => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1128> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Else => parser.reduce::<64>(),
            TokenType::Elseif => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1129> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Else => parser.reduce::<66>(),
            TokenType::Elseif => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1130> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1009),
            TokenType::String(_) => parser.shift(1103),
            TokenType::Integer(_) => parser.shift(1106),
            TokenType::Float(_) => parser.shift(1107),
            TokenType::False => parser.shift(1108),
            TokenType::Function => parser.shift(1166),
            TokenType::Nil => parser.shift(1110),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1111),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1153),
            TokenType::LCurly => parser.shift(1167),
            TokenType::Dots => parser.shift(1112),
            TokenType::Var => parser.goto(1164),
            TokenType::Exp => parser.goto(1280),
            TokenType::Prefixexp => parser.goto(1036),
            TokenType::Functioncall => parser.goto(1165),
            TokenType::Functiondef => parser.goto(1128),
            TokenType::Tableconstructor => parser.goto(1129),
            TokenType::Unop => parser.goto(1130),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1131> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Until => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1132> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1133> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1247),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1134> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1270),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1135> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::Until => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1136> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::Until => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1137> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::Until => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1138> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1139> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(1321),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1140> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Eof => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1141> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1238),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1142> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1239),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1143> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1233),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1144> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1268),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1145> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1259),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1146> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1147> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1148> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(1325),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1149> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::Else => parser.reduce::<64>(),
            TokenType::Elseif => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1150> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::Else => parser.reduce::<66>(),
            TokenType::Elseif => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1151> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1264),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1152> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1019),
            TokenType::String(_) => parser.shift(1118),
            TokenType::Integer(_) => parser.shift(1120),
            TokenType::Float(_) => parser.shift(1121),
            TokenType::False => parser.shift(1122),
            TokenType::Function => parser.shift(1182),
            TokenType::Nil => parser.shift(1123),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1124),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1179),
            TokenType::LCurly => parser.shift(1183),
            TokenType::Dots => parser.shift(1125),
            TokenType::Var => parser.goto(1180),
            TokenType::Exp => parser.goto(1284),
            TokenType::Prefixexp => parser.goto(1042),
            TokenType::Functioncall => parser.goto(1181),
            TokenType::Functiondef => parser.goto(1149),
            TokenType::Tableconstructor => parser.goto(1150),
            TokenType::Unop => parser.goto(1152),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1153> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(1273),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1154> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1245),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1155> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1242),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1156> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1244),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1157> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1158> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::Until => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1159> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1329),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1160> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1248),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1161> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1229),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1162> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1230),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1163> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1236),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1164> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Else => parser.reduce::<69>(),
            TokenType::Elseif => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1165> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Else => parser.reduce::<70>(),
            TokenType::Elseif => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1166> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1258),
            TokenType::Funcbody => parser.goto(1251),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1167> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1323),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1168> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1246),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1169> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1170> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1328),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1171> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1250),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1172> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1237),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1173> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1241),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1174> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1235),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1175> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1234),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1176> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1267),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1177> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1178> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1232),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1179> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(1276),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1180> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::Else => parser.reduce::<69>(),
            TokenType::Elseif => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1181> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::Else => parser.reduce::<70>(),
            TokenType::Elseif => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1182> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1256),
            TokenType::Funcbody => parser.goto(1243),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1183> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1324),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1184> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<25>(),
            TokenType::Break => parser.reduce::<25>(),
            TokenType::Do => parser.reduce::<25>(),
            TokenType::Else => parser.reduce::<25>(),
            TokenType::Elseif => parser.reduce::<25>(),
            TokenType::End => parser.reduce::<25>(),
            TokenType::For => parser.reduce::<25>(),
            TokenType::Function => parser.reduce::<25>(),
            TokenType::Goto => parser.reduce::<25>(),
            TokenType::If => parser.reduce::<25>(),
            TokenType::Local => parser.reduce::<25>(),
            TokenType::Repeat => parser.reduce::<25>(),
            TokenType::Return => parser.reduce::<25>(),
            TokenType::While => parser.reduce::<25>(),
            TokenType::LParen => parser.reduce::<25>(),
            TokenType::DoubleColon => parser.reduce::<25>(),
            TokenType::SemiColon => parser.reduce::<25>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1185> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1186> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::Until => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(730),
            TokenType::AttnamelistCont => parser.goto(1341),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1187> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::End => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(726),
            TokenType::AttnamelistCont => parser.goto(1342),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1188> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<15>(),
            TokenType::Break => parser.reduce::<15>(),
            TokenType::Do => parser.reduce::<15>(),
            TokenType::For => parser.reduce::<15>(),
            TokenType::Function => parser.reduce::<15>(),
            TokenType::Goto => parser.reduce::<15>(),
            TokenType::If => parser.reduce::<15>(),
            TokenType::Local => parser.reduce::<15>(),
            TokenType::Repeat => parser.reduce::<15>(),
            TokenType::Return => parser.reduce::<15>(),
            TokenType::While => parser.reduce::<15>(),
            TokenType::LParen => parser.reduce::<15>(),
            TokenType::DoubleColon => parser.reduce::<15>(),
            TokenType::SemiColon => parser.reduce::<15>(),
            TokenType::Eof => parser.reduce::<15>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1189> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<34>(),
            TokenType::Elseif => parser.reduce::<34>(),
            TokenType::End => parser.reduce::<34>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1190> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::Else => parser.reduce::<29>(),
            TokenType::Elseif => parser.reduce::<29>(),
            TokenType::End => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1191> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<38>(),
            TokenType::Elseif => parser.reduce::<38>(),
            TokenType::End => parser.reduce::<38>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1192> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1348),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1193> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(1377),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1194> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1337),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1195> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(1360),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1196> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            TokenType::Eof => parser.reduce::<31>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1197> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::Else => parser.reduce::<73>(),
            TokenType::Elseif => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1198> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Greater => parser.shift(1336),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1199> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1200> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Until => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1201> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1202> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1203> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1335),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1204> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Until => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1205> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1397),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1206> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            TokenType::Eof => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1207> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1208> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            TokenType::Eof => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1209> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1401),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1210> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1356),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1211> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1391),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1212> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1399),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1213> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1402),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1214> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<28>(),
            TokenType::Break => parser.reduce::<28>(),
            TokenType::Do => parser.reduce::<28>(),
            TokenType::Else => parser.reduce::<28>(),
            TokenType::Elseif => parser.reduce::<28>(),
            TokenType::End => parser.reduce::<28>(),
            TokenType::For => parser.reduce::<28>(),
            TokenType::Function => parser.reduce::<28>(),
            TokenType::Goto => parser.reduce::<28>(),
            TokenType::If => parser.reduce::<28>(),
            TokenType::Local => parser.reduce::<28>(),
            TokenType::Repeat => parser.reduce::<28>(),
            TokenType::Return => parser.reduce::<28>(),
            TokenType::While => parser.reduce::<28>(),
            TokenType::LParen => parser.reduce::<28>(),
            TokenType::DoubleColon => parser.reduce::<28>(),
            TokenType::SemiColon => parser.reduce::<28>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1215> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1338),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1216> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1400),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1217> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(468),
            TokenType::Do => parser.shift(484),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(502),
            TokenType::Function => parser.shift(505),
            TokenType::Goto => parser.shift(506),
            TokenType::If => parser.shift(528),
            TokenType::Local => parser.shift(578),
            TokenType::Repeat => parser.shift(582),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(597),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(626),
            TokenType::SemiColon => parser.shift(622),
            TokenType::Block => parser.goto(1398),
            TokenType::BlockStat => parser.goto(396),
            TokenType::Stat => parser.goto(420),
            TokenType::Label => parser.goto(623),
            TokenType::Varlist => parser.goto(624),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(628),
            TokenType::Functioncall => parser.goto(625),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1218> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Do => parser.reduce::<21>(),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Comma => parser.shift(1254),
            TokenType::Concat => parser.shift(320),
            TokenType::StatForexp => parser.goto(1339),
            TokenType::Binop => parser.goto(780),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1219> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1220> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1221> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<23>(),
            TokenType::Break => parser.reduce::<23>(),
            TokenType::Do => parser.reduce::<23>(),
            TokenType::For => parser.reduce::<23>(),
            TokenType::Function => parser.reduce::<23>(),
            TokenType::Goto => parser.reduce::<23>(),
            TokenType::If => parser.reduce::<23>(),
            TokenType::Local => parser.reduce::<23>(),
            TokenType::Repeat => parser.reduce::<23>(),
            TokenType::Return => parser.reduce::<23>(),
            TokenType::While => parser.reduce::<23>(),
            TokenType::LParen => parser.reduce::<23>(),
            TokenType::DoubleColon => parser.reduce::<23>(),
            TokenType::SemiColon => parser.reduce::<23>(),
            TokenType::Eof => parser.reduce::<23>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1222> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::Until => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1223> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1224> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1403),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1225> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1226> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<54>(),
            TokenType::Elseif => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1227> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1357),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1228> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Do => parser.reduce::<21>(),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Comma => parser.shift(1254),
            TokenType::Concat => parser.shift(320),
            TokenType::StatForexp => parser.goto(1340),
            TokenType::Binop => parser.goto(780),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1229> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::End => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1230> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1231> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            TokenType::Eof => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1232> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1233> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1234> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1235> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::Until => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1236> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::Else => parser.reduce::<88>(),
            TokenType::Elseif => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1237> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1238> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Then => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1239> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Eof => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1240> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1241> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Until => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1242> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1243> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::Else => parser.reduce::<79>(),
            TokenType::Elseif => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1244> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::End => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1245> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Until => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1246> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1247> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::Until => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1248> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::Until => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1249> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Comma => parser.shift(1372),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(858),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1250> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::Until => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1251> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Else => parser.reduce::<79>(),
            TokenType::Elseif => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1252> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::Else => parser.reduce::<54>(),
            TokenType::Elseif => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1253> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<14>(),
            TokenType::And => parser.shift(300),
            TokenType::Break => parser.reduce::<14>(),
            TokenType::Do => parser.reduce::<14>(),
            TokenType::Else => parser.reduce::<14>(),
            TokenType::Elseif => parser.reduce::<14>(),
            TokenType::End => parser.reduce::<14>(),
            TokenType::For => parser.reduce::<14>(),
            TokenType::Function => parser.reduce::<14>(),
            TokenType::Goto => parser.reduce::<14>(),
            TokenType::If => parser.reduce::<14>(),
            TokenType::Local => parser.reduce::<14>(),
            TokenType::Or => parser.shift(301),
            TokenType::Repeat => parser.reduce::<14>(),
            TokenType::Return => parser.reduce::<14>(),
            TokenType::While => parser.reduce::<14>(),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::LParen => parser.reduce::<14>(),
            TokenType::DoubleColon => parser.reduce::<14>(),
            TokenType::SemiColon => parser.reduce::<14>(),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(1376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1254> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(67),
            TokenType::String(_) => parser.shift(77),
            TokenType::Integer(_) => parser.shift(78),
            TokenType::Float(_) => parser.shift(79),
            TokenType::False => parser.shift(80),
            TokenType::Function => parser.shift(133),
            TokenType::Nil => parser.shift(81),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(82),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(122),
            TokenType::LCurly => parser.shift(135),
            TokenType::Dots => parser.shift(83),
            TokenType::Var => parser.goto(129),
            TokenType::Exp => parser.goto(1364),
            TokenType::Prefixexp => parser.goto(68),
            TokenType::Functioncall => parser.goto(130),
            TokenType::Functiondef => parser.goto(94),
            TokenType::Tableconstructor => parser.goto(95),
            TokenType::Unop => parser.goto(101),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1255> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(1382),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1256> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(1345),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1257> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(1379),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1258> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(1343),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1259> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1147),
            TokenType::LParen => parser.shift(1148),
            TokenType::LCurly => parser.shift(1170),
            TokenType::Args => parser.goto(1344),
            TokenType::Tableconstructor => parser.goto(1169),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1260> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1009),
            TokenType::String(_) => parser.shift(1103),
            TokenType::Integer(_) => parser.shift(1106),
            TokenType::Float(_) => parser.shift(1107),
            TokenType::False => parser.shift(1108),
            TokenType::Function => parser.shift(1166),
            TokenType::Nil => parser.shift(1110),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1111),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1153),
            TokenType::LCurly => parser.shift(1167),
            TokenType::Dots => parser.shift(1112),
            TokenType::Var => parser.goto(1164),
            TokenType::Exp => parser.goto(1384),
            TokenType::Prefixexp => parser.goto(1036),
            TokenType::Functioncall => parser.goto(1165),
            TokenType::Functiondef => parser.goto(1128),
            TokenType::Tableconstructor => parser.goto(1129),
            TokenType::Unop => parser.goto(1130),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1261> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1262> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1263> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1264> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::Else => parser.reduce::<74>(),
            TokenType::Elseif => parser.reduce::<74>(),
            TokenType::End => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1265> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1266> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::Until => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1267> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            TokenType::Eof => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1268> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::End => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1269> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1019),
            TokenType::String(_) => parser.shift(1118),
            TokenType::Integer(_) => parser.shift(1120),
            TokenType::Float(_) => parser.shift(1121),
            TokenType::False => parser.shift(1122),
            TokenType::Function => parser.shift(1182),
            TokenType::Nil => parser.shift(1123),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1124),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1179),
            TokenType::LCurly => parser.shift(1183),
            TokenType::Dots => parser.shift(1125),
            TokenType::Var => parser.goto(1180),
            TokenType::Exp => parser.goto(1387),
            TokenType::Prefixexp => parser.goto(1042),
            TokenType::Functioncall => parser.goto(1181),
            TokenType::Functiondef => parser.goto(1149),
            TokenType::Tableconstructor => parser.goto(1150),
            TokenType::Unop => parser.goto(1152),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1270> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1137),
            TokenType::LParen => parser.shift(1139),
            TokenType::LCurly => parser.shift(1159),
            TokenType::Args => parser.goto(1346),
            TokenType::Tableconstructor => parser.goto(1158),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1271> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1009),
            TokenType::String(_) => parser.shift(1103),
            TokenType::Integer(_) => parser.shift(1106),
            TokenType::Float(_) => parser.shift(1107),
            TokenType::False => parser.shift(1108),
            TokenType::Function => parser.shift(1166),
            TokenType::Nil => parser.shift(1110),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1111),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1153),
            TokenType::LCurly => parser.shift(1167),
            TokenType::Dots => parser.shift(1112),
            TokenType::Var => parser.goto(1164),
            TokenType::Exp => parser.goto(1385),
            TokenType::Prefixexp => parser.goto(1036),
            TokenType::Functioncall => parser.goto(1165),
            TokenType::Functiondef => parser.goto(1128),
            TokenType::Tableconstructor => parser.goto(1129),
            TokenType::Unop => parser.goto(1130),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1272> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1347),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1273> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(1389),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1274> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1353),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1275> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1351),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1276> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(1390),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1277> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RCurly => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Comma => parser.reduce::<95>(),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(481),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1278> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1375),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1279> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::Else => parser.reduce::<48>(),
            TokenType::Elseif => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1280> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Else => parser.reduce::<68>(),
            TokenType::Elseif => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(1271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1281> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::String(_) => parser.shift(1395),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::Else => parser.reduce::<65>(),
            TokenType::Elseif => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            // Shift(1396)-Reduce(65)
            TokenType::LParen => parser.shift(1396),
            TokenType::LSquare => parser.shift(1370),
            TokenType::LCurly => parser.shift(1406),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Colon => parser.shift(1393),
            TokenType::Dot => parser.shift(1392),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Args => parser.goto(1394),
            TokenType::Tableconstructor => parser.goto(1405),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1282> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::Name(_), Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Break, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Do, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::For, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Function, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Goto, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::If, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Local, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Repeat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Return, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Until, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::While, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::LParen, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::DoubleColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::SemiColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(1032),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1283> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<16>(),
            TokenType::Elseif => parser.shift(808),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatElseif => parser.goto(1366),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1284> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::Else => parser.reduce::<68>(),
            TokenType::Elseif => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(1303),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1285> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::Name(_), Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Break, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Do, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::End, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::For, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Function, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Goto, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::If, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Local, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Repeat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Return, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::While, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::LParen, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::DoubleColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::SemiColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(1039),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1286> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::Else => parser.reduce::<60>(),
            TokenType::Elseif => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1287> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::Else => parser.reduce::<61>(),
            TokenType::Elseif => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1288> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::Else => parser.reduce::<62>(),
            TokenType::Elseif => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1289> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::Else => parser.reduce::<58>(),
            TokenType::Elseif => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1290> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::Else => parser.reduce::<57>(),
            TokenType::Elseif => parser.reduce::<57>(),
            TokenType::End => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1291> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::Else => parser.reduce::<59>(),
            TokenType::Elseif => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1292> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::Else => parser.reduce::<63>(),
            TokenType::Elseif => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1293> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::Until => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1294> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<56>(),
            TokenType::Break => parser.reduce::<56>(),
            TokenType::Do => parser.reduce::<56>(),
            TokenType::End => parser.reduce::<56>(),
            TokenType::For => parser.reduce::<56>(),
            TokenType::Function => parser.reduce::<56>(),
            TokenType::Goto => parser.reduce::<56>(),
            TokenType::If => parser.reduce::<56>(),
            TokenType::Local => parser.reduce::<56>(),
            TokenType::Repeat => parser.reduce::<56>(),
            TokenType::Return => parser.reduce::<56>(),
            TokenType::While => parser.reduce::<56>(),
            TokenType::LParen => parser.reduce::<56>(),
            TokenType::DoubleColon => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1295> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1296> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1349),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1297> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1373),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1298> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Else => parser.reduce::<72>(),
            TokenType::Elseif => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1299> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Else => parser.reduce::<78>(),
            TokenType::Elseif => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1300> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(1407),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1301> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1350),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1302> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1355),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1303> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1019),
            TokenType::String(_) => parser.shift(1118),
            TokenType::Integer(_) => parser.shift(1120),
            TokenType::Float(_) => parser.shift(1121),
            TokenType::False => parser.shift(1122),
            TokenType::Function => parser.shift(1182),
            TokenType::Nil => parser.shift(1123),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1124),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1179),
            TokenType::LCurly => parser.shift(1183),
            TokenType::Dots => parser.shift(1125),
            TokenType::Var => parser.goto(1180),
            TokenType::Exp => parser.goto(1388),
            TokenType::Prefixexp => parser.goto(1042),
            TokenType::Functioncall => parser.goto(1181),
            TokenType::Functiondef => parser.goto(1149),
            TokenType::Tableconstructor => parser.goto(1150),
            TokenType::Unop => parser.goto(1152),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1304> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<56>(),
            TokenType::Break => parser.reduce::<56>(),
            TokenType::Do => parser.reduce::<56>(),
            TokenType::For => parser.reduce::<56>(),
            TokenType::Function => parser.reduce::<56>(),
            TokenType::Goto => parser.reduce::<56>(),
            TokenType::If => parser.reduce::<56>(),
            TokenType::Local => parser.reduce::<56>(),
            TokenType::Repeat => parser.reduce::<56>(),
            TokenType::Return => parser.reduce::<56>(),
            TokenType::Until => parser.reduce::<56>(),
            TokenType::While => parser.reduce::<56>(),
            TokenType::LParen => parser.reduce::<56>(),
            TokenType::DoubleColon => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1305> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<19>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1306> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1358),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1307> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1354),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1308> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1365),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1309> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::Else => parser.reduce::<72>(),
            TokenType::Elseif => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1310> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::Else => parser.reduce::<64>(),
            TokenType::Elseif => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1311> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::Else => parser.reduce::<78>(),
            TokenType::Elseif => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1312> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::Else => parser.reduce::<66>(),
            TokenType::Elseif => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1313> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1363),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1314> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(1404),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1315> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1279),
            TokenType::String(_) => parser.shift(1286),
            TokenType::Integer(_) => parser.shift(1287),
            TokenType::Float(_) => parser.shift(1288),
            TokenType::False => parser.shift(1289),
            TokenType::Function => parser.shift(1333),
            TokenType::Nil => parser.shift(1290),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1291),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1330),
            TokenType::LCurly => parser.shift(1334),
            TokenType::Dots => parser.shift(1292),
            TokenType::Var => parser.goto(1331),
            TokenType::Exp => parser.goto(1386),
            TokenType::Prefixexp => parser.goto(1281),
            TokenType::Functioncall => parser.goto(1332),
            TokenType::Functiondef => parser.goto(1310),
            TokenType::Tableconstructor => parser.goto(1312),
            TokenType::Unop => parser.goto(1315),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1316> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1378),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1317> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1352),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1318> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Else => parser.reduce::<77>(),
            TokenType::Elseif => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1319> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1408),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1320> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1368),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1321> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1369),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1322> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1367),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1323> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1371),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1324> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1359),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1325> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1362),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1326> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::Else => parser.reduce::<77>(),
            TokenType::Elseif => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1327> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1409),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1328> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1380),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1329> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1374),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1330> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(126),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(1383),
            TokenType::Prefixexp => parser.goto(38),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1331> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::Else => parser.reduce::<69>(),
            TokenType::Elseif => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1332> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::Else => parser.reduce::<70>(),
            TokenType::Elseif => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1333> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1381),
            TokenType::Funcbody => parser.goto(1361),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1334> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1410),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1335> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<15>(),
            TokenType::Break => parser.reduce::<15>(),
            TokenType::Do => parser.reduce::<15>(),
            TokenType::For => parser.reduce::<15>(),
            TokenType::Function => parser.reduce::<15>(),
            TokenType::Goto => parser.reduce::<15>(),
            TokenType::If => parser.reduce::<15>(),
            TokenType::Local => parser.reduce::<15>(),
            TokenType::Repeat => parser.reduce::<15>(),
            TokenType::Return => parser.reduce::<15>(),
            TokenType::Until => parser.reduce::<15>(),
            TokenType::While => parser.reduce::<15>(),
            TokenType::LParen => parser.reduce::<15>(),
            TokenType::DoubleColon => parser.reduce::<15>(),
            TokenType::SemiColon => parser.reduce::<15>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1336> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<33>(),
            TokenType::Break => parser.reduce::<33>(),
            TokenType::Do => parser.reduce::<33>(),
            TokenType::Else => parser.reduce::<33>(),
            TokenType::Elseif => parser.reduce::<33>(),
            TokenType::End => parser.reduce::<33>(),
            TokenType::For => parser.reduce::<33>(),
            TokenType::Function => parser.reduce::<33>(),
            TokenType::Goto => parser.reduce::<33>(),
            TokenType::If => parser.reduce::<33>(),
            TokenType::Local => parser.reduce::<33>(),
            TokenType::Repeat => parser.reduce::<33>(),
            TokenType::Return => parser.reduce::<33>(),
            TokenType::While => parser.reduce::<33>(),
            TokenType::Assign => parser.reduce::<33>(),
            TokenType::LParen => parser.reduce::<33>(),
            TokenType::DoubleColon => parser.reduce::<33>(),
            TokenType::SemiColon => parser.reduce::<33>(),
            TokenType::Comma => parser.reduce::<33>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1337> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::Else => parser.reduce::<32>(),
            TokenType::Elseif => parser.reduce::<32>(),
            TokenType::End => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(1033),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(1411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1338> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<15>(),
            TokenType::Break => parser.reduce::<15>(),
            TokenType::Do => parser.reduce::<15>(),
            TokenType::End => parser.reduce::<15>(),
            TokenType::For => parser.reduce::<15>(),
            TokenType::Function => parser.reduce::<15>(),
            TokenType::Goto => parser.reduce::<15>(),
            TokenType::If => parser.reduce::<15>(),
            TokenType::Local => parser.reduce::<15>(),
            TokenType::Repeat => parser.reduce::<15>(),
            TokenType::Return => parser.reduce::<15>(),
            TokenType::While => parser.reduce::<15>(),
            TokenType::LParen => parser.reduce::<15>(),
            TokenType::DoubleColon => parser.reduce::<15>(),
            TokenType::SemiColon => parser.reduce::<15>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1339> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(1434),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1340> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(1435),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1341> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::Until => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1342> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::End => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1343> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1344> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1345> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1432),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1346> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::Until => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1347> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::Until => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1348> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1447),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1349> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Else => parser.reduce::<50>(),
            TokenType::Elseif => parser.reduce::<50>(),
            TokenType::End => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1350> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1351> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<23>(),
            TokenType::Break => parser.reduce::<23>(),
            TokenType::Do => parser.reduce::<23>(),
            TokenType::For => parser.reduce::<23>(),
            TokenType::Function => parser.reduce::<23>(),
            TokenType::Goto => parser.reduce::<23>(),
            TokenType::If => parser.reduce::<23>(),
            TokenType::Local => parser.reduce::<23>(),
            TokenType::Repeat => parser.reduce::<23>(),
            TokenType::Return => parser.reduce::<23>(),
            TokenType::Until => parser.reduce::<23>(),
            TokenType::While => parser.reduce::<23>(),
            TokenType::LParen => parser.reduce::<23>(),
            TokenType::DoubleColon => parser.reduce::<23>(),
            TokenType::SemiColon => parser.reduce::<23>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1352> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::Until => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1353> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1354> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::Else => parser.reduce::<50>(),
            TokenType::Elseif => parser.reduce::<50>(),
            TokenType::End => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1355> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::End => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1356> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1444),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1357> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1445),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1358> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::RCurly => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1359> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::Else => parser.reduce::<88>(),
            TokenType::Elseif => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1360> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1440),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1361> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::Else => parser.reduce::<79>(),
            TokenType::Elseif => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1362> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::End => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1363> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            TokenType::Eof => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1364> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Do => parser.reduce::<22>(),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(250),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1365> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1311),
            TokenType::LParen => parser.shift(1314),
            TokenType::LCurly => parser.shift(1327),
            TokenType::Args => parser.goto(1412),
            TokenType::Tableconstructor => parser.goto(1326),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1366> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.shift(1015),
            TokenType::End => parser.reduce::<18>(),
            TokenType::StatElse => parser.goto(1413),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1367> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            TokenType::Eof => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1368> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::RSquare => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1369> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::Until => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1370> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            TokenType::String(_) => parser.shift(253),
            TokenType::Integer(_) => parser.shift(254),
            TokenType::Float(_) => parser.shift(256),
            TokenType::False => parser.shift(257),
            TokenType::Function => parser.shift(356),
            TokenType::Nil => parser.shift(258),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(259),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(336),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(260),
            TokenType::Var => parser.goto(352),
            TokenType::Exp => parser.goto(1438),
            TokenType::Prefixexp => parser.goto(176),
            TokenType::Functioncall => parser.goto(353),
            TokenType::Functiondef => parser.goto(284),
            TokenType::Tableconstructor => parser.goto(285),
            TokenType::Unop => parser.goto(286),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1371> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Else => parser.reduce::<88>(),
            TokenType::Elseif => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1372> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(416),
            TokenType::String(_) => parser.shift(519),
            TokenType::Integer(_) => parser.shift(520),
            TokenType::Float(_) => parser.shift(521),
            TokenType::False => parser.shift(523),
            TokenType::Function => parser.shift(650),
            TokenType::Nil => parser.shift(524),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(525),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(636),
            TokenType::LCurly => parser.shift(651),
            TokenType::Dots => parser.shift(527),
            TokenType::Var => parser.goto(648),
            TokenType::Exp => parser.goto(1436),
            TokenType::Prefixexp => parser.goto(429),
            TokenType::Functioncall => parser.goto(649),
            TokenType::Functiondef => parser.goto(595),
            TokenType::Tableconstructor => parser.goto(596),
            TokenType::Unop => parser.goto(599),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1373> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1299),
            TokenType::LParen => parser.shift(1300),
            TokenType::LCurly => parser.shift(1319),
            TokenType::Args => parser.goto(1414),
            TokenType::Tableconstructor => parser.goto(1318),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1374> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::Until => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1375> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<23>(),
            TokenType::Break => parser.reduce::<23>(),
            TokenType::Do => parser.reduce::<23>(),
            TokenType::End => parser.reduce::<23>(),
            TokenType::For => parser.reduce::<23>(),
            TokenType::Function => parser.reduce::<23>(),
            TokenType::Goto => parser.reduce::<23>(),
            TokenType::If => parser.reduce::<23>(),
            TokenType::Local => parser.reduce::<23>(),
            TokenType::Repeat => parser.reduce::<23>(),
            TokenType::Return => parser.reduce::<23>(),
            TokenType::While => parser.reduce::<23>(),
            TokenType::LParen => parser.reduce::<23>(),
            TokenType::DoubleColon => parser.reduce::<23>(),
            TokenType::SemiColon => parser.reduce::<23>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1376> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1279),
            TokenType::String(_) => parser.shift(1286),
            TokenType::Integer(_) => parser.shift(1287),
            TokenType::Float(_) => parser.shift(1288),
            TokenType::False => parser.shift(1289),
            TokenType::Function => parser.shift(1333),
            TokenType::Nil => parser.shift(1290),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1291),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1330),
            TokenType::LCurly => parser.shift(1334),
            TokenType::Dots => parser.shift(1292),
            TokenType::Var => parser.goto(1331),
            TokenType::Exp => parser.goto(1442),
            TokenType::Prefixexp => parser.goto(1281),
            TokenType::Functioncall => parser.goto(1332),
            TokenType::Functiondef => parser.goto(1310),
            TokenType::Tableconstructor => parser.goto(1312),
            TokenType::Unop => parser.goto(1315),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1377> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1439),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1378> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<13>(),
            TokenType::Break => parser.reduce::<13>(),
            TokenType::Do => parser.reduce::<13>(),
            TokenType::Else => parser.reduce::<13>(),
            TokenType::Elseif => parser.reduce::<13>(),
            TokenType::End => parser.reduce::<13>(),
            TokenType::For => parser.reduce::<13>(),
            TokenType::Function => parser.reduce::<13>(),
            TokenType::Goto => parser.reduce::<13>(),
            TokenType::If => parser.reduce::<13>(),
            TokenType::Local => parser.reduce::<13>(),
            TokenType::Repeat => parser.reduce::<13>(),
            TokenType::Return => parser.reduce::<13>(),
            TokenType::While => parser.reduce::<13>(),
            TokenType::LParen => parser.reduce::<13>(),
            TokenType::DoubleColon => parser.reduce::<13>(),
            TokenType::SemiColon => parser.reduce::<13>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1379> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1416),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1380> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1381> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(394),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Dots => parser.shift(398),
            TokenType::FuncbodyParlist => parser.goto(1417),
            TokenType::Parlist => parser.goto(393),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1382> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1415),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1383> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RParen => parser.shift(1443),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(204),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1384> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Else => parser.reduce::<55>(),
            TokenType::Elseif => parser.reduce::<55>(),
            TokenType::End => parser.reduce::<55>(),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(1260),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(1441),
            TokenType::Binop => parser.goto(1271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1385> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Else, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Elseif, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::End, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::SemiColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Comma, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(1271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1386> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::Else => parser.reduce::<68>(),
            TokenType::Elseif => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Binop => parser.goto(1376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1387> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<55>(),
            TokenType::And => parser.shift(300),
            TokenType::Break => parser.reduce::<55>(),
            TokenType::Do => parser.reduce::<55>(),
            TokenType::Else => parser.reduce::<55>(),
            TokenType::Elseif => parser.reduce::<55>(),
            TokenType::End => parser.reduce::<55>(),
            TokenType::For => parser.reduce::<55>(),
            TokenType::Function => parser.reduce::<55>(),
            TokenType::Goto => parser.reduce::<55>(),
            TokenType::If => parser.reduce::<55>(),
            TokenType::Local => parser.reduce::<55>(),
            TokenType::Or => parser.shift(301),
            TokenType::Repeat => parser.reduce::<55>(),
            TokenType::Return => parser.reduce::<55>(),
            TokenType::While => parser.reduce::<55>(),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::LParen => parser.reduce::<55>(),
            TokenType::DoubleColon => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Comma => parser.shift(1269),
            TokenType::Concat => parser.shift(320),
            TokenType::ExplistCont => parser.goto(1446),
            TokenType::Binop => parser.goto(1303),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1388> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::Name(_), Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Break, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Do, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Else, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Elseif, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::End, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::For, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Function, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Goto, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::If, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Local, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Repeat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Return, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::While, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::LParen, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::DoubleColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::SemiColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Comma, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(1303),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1389> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Else => parser.reduce::<71>(),
            TokenType::Elseif => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1390> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::Else => parser.reduce::<71>(),
            TokenType::Elseif => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1391> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1418),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1392> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1420),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1393> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1424),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1394> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::Else => parser.reduce::<72>(),
            TokenType::Elseif => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1395> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::String(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::Else => parser.reduce::<78>(),
            TokenType::Elseif => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::LSquare => parser.reduce::<78>(),
            TokenType::LCurly => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Colon => parser.reduce::<78>(),
            TokenType::Dot => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1396> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::String(_) => parser.shift(215),
            TokenType::Integer(_) => parser.shift(217),
            TokenType::Float(_) => parser.shift(218),
            TokenType::False => parser.shift(219),
            TokenType::Function => parser.shift(350),
            TokenType::Nil => parser.shift(220),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(222),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(223),
            TokenType::Var => parser.goto(346),
            TokenType::Explist => parser.goto(349),
            TokenType::Exp => parser.goto(214),
            TokenType::Prefixexp => parser.goto(172),
            TokenType::Functioncall => parser.goto(347),
            TokenType::ArgsExplist => parser.goto(1448),
            TokenType::Functiondef => parser.goto(267),
            TokenType::Tableconstructor => parser.goto(268),
            TokenType::Unop => parser.goto(271),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1397> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1431),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1398> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<16>(),
            TokenType::Elseif => parser.shift(808),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatElseif => parser.goto(1437),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1399> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1419),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1400> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1423),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1401> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1425),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1402> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1422),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1403> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1430),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1404> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1421),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1405> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::Else => parser.reduce::<77>(),
            TokenType::Elseif => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1406> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(177),
            TokenType::String(_) => parser.shift(226),
            TokenType::Integer(_) => parser.shift(227),
            TokenType::Float(_) => parser.shift(229),
            TokenType::False => parser.shift(230),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(231),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(232),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(337),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::Dots => parser.shift(233),
            TokenType::Var => parser.goto(354),
            TokenType::Exp => parser.goto(234),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(355),
            TokenType::Functiondef => parser.goto(269),
            TokenType::Tableconstructor => parser.goto(270),
            TokenType::TableconstructorFieldlist => parser.goto(1449),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1407> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1426),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1408> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1433),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1409> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1428),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1410> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1429),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1411> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::Else => parser.reduce::<30>(),
            TokenType::Elseif => parser.reduce::<30>(),
            TokenType::End => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(1194),
            TokenType::AttnamelistCont => parser.goto(1461),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1412> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::Else => parser.reduce::<73>(),
            TokenType::Elseif => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1413> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1450),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1414> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Else => parser.reduce::<73>(),
            TokenType::Elseif => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1415> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::Else => parser.reduce::<49>(),
            TokenType::Elseif => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1416> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Else => parser.reduce::<49>(),
            TokenType::Elseif => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1417> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1462),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1418> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1419> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Until => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1420> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::Else => parser.reduce::<50>(),
            TokenType::Elseif => parser.reduce::<50>(),
            TokenType::End => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1421> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::Else => parser.reduce::<74>(),
            TokenType::Elseif => parser.reduce::<74>(),
            TokenType::End => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1422> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<80>(),
            TokenType::End => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1423> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::Until => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1424> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1395),
            TokenType::LParen => parser.shift(1396),
            TokenType::LCurly => parser.shift(1406),
            TokenType::Args => parser.goto(1451),
            TokenType::Tableconstructor => parser.goto(1405),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1425> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::End => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1426> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Else => parser.reduce::<74>(),
            TokenType::Elseif => parser.reduce::<74>(),
            TokenType::End => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1427> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1465),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1428> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::Else => parser.reduce::<88>(),
            TokenType::Elseif => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1429> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::Else => parser.reduce::<88>(),
            TokenType::Elseif => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1430> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            TokenType::Eof => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1431> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1432> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1466),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1433> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Else => parser.reduce::<88>(),
            TokenType::Elseif => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1434> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1463),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1435> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1464),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1436> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Do => parser.reduce::<21>(),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::Comma => parser.shift(1254),
            TokenType::Concat => parser.shift(320),
            TokenType::StatForexp => parser.goto(1453),
            TokenType::Binop => parser.goto(780),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1437> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<17>(),
            TokenType::End => parser.reduce::<17>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1438> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(300),
            TokenType::Or => parser.shift(301),
            TokenType::Add => parser.shift(302),
            TokenType::Sub => parser.shift(303),
            TokenType::Mul => parser.shift(304),
            TokenType::Div => parser.shift(305),
            TokenType::Idiv => parser.shift(306),
            TokenType::Mod => parser.shift(307),
            TokenType::Pow => parser.shift(308),
            TokenType::BitAnd => parser.shift(309),
            TokenType::BitXor => parser.shift(310),
            TokenType::BitOr => parser.shift(311),
            TokenType::ShiftL => parser.shift(312),
            TokenType::ShiftR => parser.shift(313),
            TokenType::Eq => parser.shift(314),
            TokenType::Neq => parser.shift(315),
            TokenType::Leq => parser.shift(316),
            TokenType::Geq => parser.shift(317),
            TokenType::Less => parser.shift(318),
            TokenType::Greater => parser.shift(319),
            TokenType::RSquare => parser.shift(1455),
            TokenType::Concat => parser.shift(320),
            TokenType::Binop => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1439> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1452),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1440> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1454),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1441> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<56>(),
            TokenType::Elseif => parser.reduce::<56>(),
            TokenType::End => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1442> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match (lookahead, precedence) {
            (TokenType::Name(_), Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::And, Precedence::Shift) => parser.shift(300),
            (TokenType::And, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Break, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Do, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Else, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Elseif, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::End, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::For, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Function, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Goto, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::If, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Local, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Or, Precedence::Shift) => parser.shift(301),
            (TokenType::Or, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Repeat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Return, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::While, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Add, Precedence::Shift) => parser.shift(302),
            (TokenType::Add, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Sub, Precedence::Shift) => parser.shift(303),
            (TokenType::Sub, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mul, Precedence::Shift) => parser.shift(304),
            (TokenType::Mul, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Div, Precedence::Shift) => parser.shift(305),
            (TokenType::Div, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Idiv, Precedence::Shift) => parser.shift(306),
            (TokenType::Idiv, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Mod, Precedence::Shift) => parser.shift(307),
            (TokenType::Mod, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Pow, Precedence::Shift) => parser.shift(308),
            (TokenType::Pow, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitAnd, Precedence::Shift) => parser.shift(309),
            (TokenType::BitAnd, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitXor, Precedence::Shift) => parser.shift(310),
            (TokenType::BitXor, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::BitOr, Precedence::Shift) => parser.shift(311),
            (TokenType::BitOr, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftL, Precedence::Shift) => parser.shift(312),
            (TokenType::ShiftL, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::ShiftR, Precedence::Shift) => parser.shift(313),
            (TokenType::ShiftR, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Eq, Precedence::Shift) => parser.shift(314),
            (TokenType::Eq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Neq, Precedence::Shift) => parser.shift(315),
            (TokenType::Neq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Leq, Precedence::Shift) => parser.shift(316),
            (TokenType::Leq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Geq, Precedence::Shift) => parser.shift(317),
            (TokenType::Geq, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Less, Precedence::Shift) => parser.shift(318),
            (TokenType::Less, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Greater, Precedence::Shift) => parser.shift(319),
            (TokenType::Greater, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::LParen, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::DoubleColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::SemiColon, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Concat, Precedence::Shift) => parser.shift(320),
            (TokenType::Concat, Precedence::Reduce) => parser.reduce::<67>(),
            (TokenType::Binop, _) => parser.goto(1376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1443> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::Else => parser.reduce::<71>(),
            TokenType::Elseif => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1444> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1456),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1445> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1458),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1446> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<56>(),
            TokenType::Break => parser.reduce::<56>(),
            TokenType::Do => parser.reduce::<56>(),
            TokenType::Else => parser.reduce::<56>(),
            TokenType::Elseif => parser.reduce::<56>(),
            TokenType::End => parser.reduce::<56>(),
            TokenType::For => parser.reduce::<56>(),
            TokenType::Function => parser.reduce::<56>(),
            TokenType::Goto => parser.reduce::<56>(),
            TokenType::If => parser.reduce::<56>(),
            TokenType::Local => parser.reduce::<56>(),
            TokenType::Repeat => parser.reduce::<56>(),
            TokenType::Return => parser.reduce::<56>(),
            TokenType::While => parser.reduce::<56>(),
            TokenType::LParen => parser.reduce::<56>(),
            TokenType::DoubleColon => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1447> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1457),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1448> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1460),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1449> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1450> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<15>(),
            TokenType::Break => parser.reduce::<15>(),
            TokenType::Do => parser.reduce::<15>(),
            TokenType::Else => parser.reduce::<15>(),
            TokenType::Elseif => parser.reduce::<15>(),
            TokenType::End => parser.reduce::<15>(),
            TokenType::For => parser.reduce::<15>(),
            TokenType::Function => parser.reduce::<15>(),
            TokenType::Goto => parser.reduce::<15>(),
            TokenType::If => parser.reduce::<15>(),
            TokenType::Local => parser.reduce::<15>(),
            TokenType::Repeat => parser.reduce::<15>(),
            TokenType::Return => parser.reduce::<15>(),
            TokenType::While => parser.reduce::<15>(),
            TokenType::LParen => parser.reduce::<15>(),
            TokenType::DoubleColon => parser.reduce::<15>(),
            TokenType::SemiColon => parser.reduce::<15>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1451> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::Else => parser.reduce::<73>(),
            TokenType::Elseif => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1452> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<20>(),
            TokenType::Break => parser.reduce::<20>(),
            TokenType::Do => parser.reduce::<20>(),
            TokenType::For => parser.reduce::<20>(),
            TokenType::Function => parser.reduce::<20>(),
            TokenType::Goto => parser.reduce::<20>(),
            TokenType::If => parser.reduce::<20>(),
            TokenType::Local => parser.reduce::<20>(),
            TokenType::Repeat => parser.reduce::<20>(),
            TokenType::Return => parser.reduce::<20>(),
            TokenType::While => parser.reduce::<20>(),
            TokenType::LParen => parser.reduce::<20>(),
            TokenType::DoubleColon => parser.reduce::<20>(),
            TokenType::SemiColon => parser.reduce::<20>(),
            TokenType::Eof => parser.reduce::<20>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1453> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(1471),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1454> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<23>(),
            TokenType::Break => parser.reduce::<23>(),
            TokenType::Do => parser.reduce::<23>(),
            TokenType::Else => parser.reduce::<23>(),
            TokenType::Elseif => parser.reduce::<23>(),
            TokenType::End => parser.reduce::<23>(),
            TokenType::For => parser.reduce::<23>(),
            TokenType::Function => parser.reduce::<23>(),
            TokenType::Goto => parser.reduce::<23>(),
            TokenType::If => parser.reduce::<23>(),
            TokenType::Local => parser.reduce::<23>(),
            TokenType::Repeat => parser.reduce::<23>(),
            TokenType::Return => parser.reduce::<23>(),
            TokenType::While => parser.reduce::<23>(),
            TokenType::LParen => parser.reduce::<23>(),
            TokenType::DoubleColon => parser.reduce::<23>(),
            TokenType::SemiColon => parser.reduce::<23>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1455> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::Else => parser.reduce::<49>(),
            TokenType::Elseif => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1456> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::Until => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1457> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::Else => parser.reduce::<80>(),
            TokenType::Elseif => parser.reduce::<80>(),
            TokenType::End => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1458> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::End => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1459> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::String(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::Else => parser.reduce::<88>(),
            TokenType::Elseif => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.reduce::<88>(),
            TokenType::Div => parser.reduce::<88>(),
            TokenType::Idiv => parser.reduce::<88>(),
            TokenType::Mod => parser.reduce::<88>(),
            TokenType::Pow => parser.reduce::<88>(),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::LSquare => parser.reduce::<88>(),
            TokenType::LCurly => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Colon => parser.reduce::<88>(),
            TokenType::Dot => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1460> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::String(_) => parser.reduce::<74>(),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::Else => parser.reduce::<74>(),
            TokenType::Elseif => parser.reduce::<74>(),
            TokenType::End => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::LSquare => parser.reduce::<74>(),
            TokenType::LCurly => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Colon => parser.reduce::<74>(),
            TokenType::Dot => parser.reduce::<74>(),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1461> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::Else => parser.reduce::<31>(),
            TokenType::Elseif => parser.reduce::<31>(),
            TokenType::End => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1462> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1472),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1463> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1470),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1464> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1465> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1469),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1466> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1468),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1467> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<20>(),
            TokenType::Break => parser.reduce::<20>(),
            TokenType::Do => parser.reduce::<20>(),
            TokenType::End => parser.reduce::<20>(),
            TokenType::For => parser.reduce::<20>(),
            TokenType::Function => parser.reduce::<20>(),
            TokenType::Goto => parser.reduce::<20>(),
            TokenType::If => parser.reduce::<20>(),
            TokenType::Local => parser.reduce::<20>(),
            TokenType::Repeat => parser.reduce::<20>(),
            TokenType::Return => parser.reduce::<20>(),
            TokenType::While => parser.reduce::<20>(),
            TokenType::LParen => parser.reduce::<20>(),
            TokenType::DoubleColon => parser.reduce::<20>(),
            TokenType::SemiColon => parser.reduce::<20>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1468> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::Else => parser.reduce::<80>(),
            TokenType::Elseif => parser.reduce::<80>(),
            TokenType::End => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1469> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<80>(),
            TokenType::Else => parser.reduce::<80>(),
            TokenType::Elseif => parser.reduce::<80>(),
            TokenType::End => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1470> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<20>(),
            TokenType::Break => parser.reduce::<20>(),
            TokenType::Do => parser.reduce::<20>(),
            TokenType::For => parser.reduce::<20>(),
            TokenType::Function => parser.reduce::<20>(),
            TokenType::Goto => parser.reduce::<20>(),
            TokenType::If => parser.reduce::<20>(),
            TokenType::Local => parser.reduce::<20>(),
            TokenType::Repeat => parser.reduce::<20>(),
            TokenType::Return => parser.reduce::<20>(),
            TokenType::Until => parser.reduce::<20>(),
            TokenType::While => parser.reduce::<20>(),
            TokenType::LParen => parser.reduce::<20>(),
            TokenType::DoubleColon => parser.reduce::<20>(),
            TokenType::SemiColon => parser.reduce::<20>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1471> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(63),
            TokenType::Function => parser.shift(64),
            TokenType::Goto => parser.shift(65),
            TokenType::If => parser.shift(69),
            TokenType::Local => parser.shift(99),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(1474),
            TokenType::BlockStat => parser.goto(25),
            TokenType::Stat => parser.goto(41),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1472> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1473),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1473> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::Else => parser.reduce::<80>(),
            TokenType::Elseif => parser.reduce::<80>(),
            TokenType::End => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1474> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1475),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1475> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<20>(),
            TokenType::Break => parser.reduce::<20>(),
            TokenType::Do => parser.reduce::<20>(),
            TokenType::Else => parser.reduce::<20>(),
            TokenType::Elseif => parser.reduce::<20>(),
            TokenType::End => parser.reduce::<20>(),
            TokenType::For => parser.reduce::<20>(),
            TokenType::Function => parser.reduce::<20>(),
            TokenType::Goto => parser.reduce::<20>(),
            TokenType::If => parser.reduce::<20>(),
            TokenType::Local => parser.reduce::<20>(),
            TokenType::Repeat => parser.reduce::<20>(),
            TokenType::Return => parser.reduce::<20>(),
            TokenType::While => parser.reduce::<20>(),
            TokenType::LParen => parser.reduce::<20>(),
            TokenType::DoubleColon => parser.reduce::<20>(),
            TokenType::SemiColon => parser.reduce::<20>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}
