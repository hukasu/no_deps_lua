use super::{Error, Parser, TokenType};

pub struct State<const N: usize>;

impl<const N: usize> State<N> {
    fn unimplemented_lookahead() -> Result<(), Error> {
        log::error!("State {N} has unimplemented lookahead.");
        Err(Error::Unimplemented)
    }
}

pub trait StateProcessor {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error>;
}

impl StateProcessor for State<0> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(4),
            TokenType::Do => parser.shift(5),
            TokenType::For => parser.shift(6),
            TokenType::Function => parser.shift(7),
            TokenType::Goto => parser.shift(8),
            TokenType::If => parser.shift(9),
            TokenType::Local => parser.shift(10),
            TokenType::Repeat => parser.shift(11),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(12),
            TokenType::LParen => parser.shift(20),
            TokenType::DoubleColon => parser.shift(17),
            TokenType::SemiColon => parser.shift(13),
            TokenType::Eof => parser.reduce::<2>(),
            TokenType::Block => parser.goto(1),
            TokenType::BlockStat => parser.goto(2),
            TokenType::Stat => parser.goto(3),
            TokenType::Label => parser.goto(14),
            TokenType::Varlist => parser.goto(15),
            TokenType::Var => parser.goto(18),
            TokenType::Functioncall => parser.goto(16),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<0>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Return => parser.shift(49),
            TokenType::Eof => parser.reduce::<4>(),
            TokenType::BlockRetstat => parser.goto(21),
            TokenType::Retstat => parser.goto(22),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<3> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(4),
            TokenType::Do => parser.shift(5),
            TokenType::For => parser.shift(6),
            TokenType::Function => parser.shift(7),
            TokenType::Goto => parser.shift(8),
            TokenType::If => parser.shift(9),
            TokenType::Local => parser.shift(10),
            TokenType::Repeat => parser.shift(11),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(12),
            TokenType::LParen => parser.shift(20),
            TokenType::DoubleColon => parser.shift(17),
            TokenType::SemiColon => parser.shift(13),
            TokenType::Eof => parser.reduce::<2>(),
            TokenType::BlockStat => parser.goto(42),
            TokenType::Stat => parser.goto(3),
            TokenType::Label => parser.goto(14),
            TokenType::Varlist => parser.goto(15),
            TokenType::Var => parser.goto(18),
            TokenType::Functioncall => parser.goto(16),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<4> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<10>(),
            TokenType::Break => parser.reduce::<10>(),
            TokenType::Do => parser.reduce::<10>(),
            TokenType::For => parser.reduce::<10>(),
            TokenType::Function => parser.reduce::<10>(),
            TokenType::Goto => parser.reduce::<10>(),
            TokenType::If => parser.reduce::<10>(),
            TokenType::Local => parser.reduce::<10>(),
            TokenType::Repeat => parser.reduce::<10>(),
            TokenType::Return => parser.reduce::<10>(),
            TokenType::While => parser.reduce::<10>(),
            TokenType::LParen => parser.reduce::<10>(),
            TokenType::DoubleColon => parser.reduce::<10>(),
            TokenType::SemiColon => parser.reduce::<10>(),
            TokenType::Eof => parser.reduce::<10>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<5> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(56),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<6> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(24),
            TokenType::Namelist => parser.goto(30),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<7> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(34),
            TokenType::Funcname => parser.goto(26),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<8> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(25),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<9> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(29),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<10> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(38),
            TokenType::Function => parser.shift(27),
            TokenType::Attnamelist => parser.goto(31),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<11> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(44),
            TokenType::Do => parser.shift(47),
            TokenType::For => parser.shift(55),
            TokenType::Function => parser.shift(58),
            TokenType::Goto => parser.shift(60),
            TokenType::If => parser.shift(62),
            TokenType::Local => parser.shift(72),
            TokenType::Repeat => parser.shift(73),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(77),
            TokenType::LParen => parser.shift(87),
            TokenType::DoubleColon => parser.shift(84),
            TokenType::SemiColon => parser.shift(80),
            TokenType::Block => parser.goto(76),
            TokenType::BlockStat => parser.goto(28),
            TokenType::Stat => parser.goto(40),
            TokenType::Label => parser.goto(81),
            TokenType::Varlist => parser.goto(82),
            TokenType::Var => parser.goto(85),
            TokenType::Functioncall => parser.goto(83),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<12> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(37),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<13> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<6>(),
            TokenType::Break => parser.reduce::<6>(),
            TokenType::Do => parser.reduce::<6>(),
            TokenType::For => parser.reduce::<6>(),
            TokenType::Function => parser.reduce::<6>(),
            TokenType::Goto => parser.reduce::<6>(),
            TokenType::If => parser.reduce::<6>(),
            TokenType::Local => parser.reduce::<6>(),
            TokenType::Repeat => parser.reduce::<6>(),
            TokenType::Return => parser.reduce::<6>(),
            TokenType::While => parser.reduce::<6>(),
            TokenType::LParen => parser.reduce::<6>(),
            TokenType::DoubleColon => parser.reduce::<6>(),
            TokenType::SemiColon => parser.reduce::<6>(),
            TokenType::Eof => parser.reduce::<6>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<14> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<9>(),
            TokenType::Break => parser.reduce::<9>(),
            TokenType::Do => parser.reduce::<9>(),
            TokenType::For => parser.reduce::<9>(),
            TokenType::Function => parser.reduce::<9>(),
            TokenType::Goto => parser.reduce::<9>(),
            TokenType::If => parser.reduce::<9>(),
            TokenType::Local => parser.reduce::<9>(),
            TokenType::Repeat => parser.reduce::<9>(),
            TokenType::Return => parser.reduce::<9>(),
            TokenType::While => parser.reduce::<9>(),
            TokenType::LParen => parser.reduce::<9>(),
            TokenType::DoubleColon => parser.reduce::<9>(),
            TokenType::SemiColon => parser.reduce::<9>(),
            TokenType::Eof => parser.reduce::<9>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<15> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(54),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<16> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<8>(),
            TokenType::String(_) => parser.shift(67),
            TokenType::Break => parser.reduce::<8>(),
            TokenType::Do => parser.reduce::<8>(),
            TokenType::For => parser.reduce::<8>(),
            TokenType::Function => parser.reduce::<8>(),
            TokenType::Goto => parser.reduce::<8>(),
            TokenType::If => parser.reduce::<8>(),
            TokenType::Local => parser.reduce::<8>(),
            TokenType::Repeat => parser.reduce::<8>(),
            TokenType::Return => parser.reduce::<8>(),
            TokenType::While => parser.reduce::<8>(),
            // Shift(71)-Reduce(8)
            TokenType::LParen => parser.shift(71),
            TokenType::LSquare => parser.shift(52),
            TokenType::LCurly => parser.shift(88),
            TokenType::DoubleColon => parser.reduce::<8>(),
            TokenType::SemiColon => parser.reduce::<8>(),
            TokenType::Colon => parser.shift(69),
            TokenType::Dot => parser.shift(68),
            TokenType::Eof => parser.reduce::<8>(),
            TokenType::Args => parser.goto(70),
            TokenType::Tableconstructor => parser.goto(86),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<17> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(32),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<18> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(67),
            TokenType::Assign => parser.reduce::<46>(),
            TokenType::LParen => parser.shift(71),
            TokenType::LSquare => parser.shift(48),
            TokenType::LCurly => parser.shift(88),
            TokenType::Colon => parser.shift(65),
            TokenType::Comma => parser.shift(36),
            TokenType::Dot => parser.shift(64),
            TokenType::VarlistCont => parser.goto(33),
            TokenType::Args => parser.goto(66),
            TokenType::Tableconstructor => parser.goto(86),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<19> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::Assign => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<20> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(78),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<21> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<1>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<22> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<5>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<23> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<4>(),
            TokenType::Return => parser.shift(196),
            TokenType::BlockRetstat => parser.goto(147),
            TokenType::Retstat => parser.goto(148),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<24> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<56>(),
            TokenType::Assign => parser.shift(193),
            TokenType::Comma => parser.shift(235),
            TokenType::NamelistCont => parser.goto(234),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<25> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<11>(),
            TokenType::Break => parser.reduce::<11>(),
            TokenType::Do => parser.reduce::<11>(),
            TokenType::For => parser.reduce::<11>(),
            TokenType::Function => parser.reduce::<11>(),
            TokenType::Goto => parser.reduce::<11>(),
            TokenType::If => parser.reduce::<11>(),
            TokenType::Local => parser.reduce::<11>(),
            TokenType::Repeat => parser.reduce::<11>(),
            TokenType::Return => parser.reduce::<11>(),
            TokenType::While => parser.reduce::<11>(),
            TokenType::LParen => parser.reduce::<11>(),
            TokenType::DoubleColon => parser.reduce::<11>(),
            TokenType::SemiColon => parser.reduce::<11>(),
            TokenType::Eof => parser.reduce::<11>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<26> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(153),
            TokenType::Funcbody => parser.goto(151),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<27> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(152),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<28> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Return => parser.shift(197),
            TokenType::Until => parser.reduce::<4>(),
            TokenType::BlockRetstat => parser.goto(149),
            TokenType::Retstat => parser.goto(150),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<29> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::Or => parser.shift(281),
            TokenType::Then => parser.shift(171),
            TokenType::Add => parser.shift(328),
            TokenType::Sub => parser.shift(337),
            TokenType::Mul => parser.shift(356),
            TokenType::Div => parser.shift(365),
            TokenType::Idiv => parser.shift(370),
            TokenType::Mod => parser.shift(376),
            TokenType::Pow => parser.shift(385),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitOr => parser.shift(402),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftR => parser.shift(418),
            TokenType::Eq => parser.shift(424),
            TokenType::Neq => parser.shift(428),
            TokenType::Leq => parser.shift(433),
            TokenType::Geq => parser.shift(436),
            TokenType::Less => parser.shift(439),
            TokenType::Greater => parser.shift(443),
            TokenType::Concat => parser.shift(448),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<30> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.shift(194),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<31> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<27>(),
            TokenType::Break => parser.reduce::<27>(),
            TokenType::Do => parser.reduce::<27>(),
            TokenType::For => parser.reduce::<27>(),
            TokenType::Function => parser.reduce::<27>(),
            TokenType::Goto => parser.reduce::<27>(),
            TokenType::If => parser.reduce::<27>(),
            TokenType::Local => parser.reduce::<27>(),
            TokenType::Repeat => parser.reduce::<27>(),
            TokenType::Return => parser.reduce::<27>(),
            TokenType::While => parser.reduce::<27>(),
            TokenType::Assign => parser.shift(204),
            TokenType::LParen => parser.reduce::<27>(),
            TokenType::DoubleColon => parser.reduce::<27>(),
            TokenType::SemiColon => parser.reduce::<27>(),
            TokenType::Eof => parser.reduce::<27>(),
            TokenType::StatAttexplist => parser.goto(154),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<32> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::DoubleColon => parser.shift(155),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<33> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.reduce::<45>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<34> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<41>(),
            TokenType::Colon => parser.reduce::<41>(),
            TokenType::Dot => parser.shift(157),
            TokenType::FuncnameCont => parser.goto(156),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<35> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::RParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<36> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::LParen => parser.shift(195),
            TokenType::Var => parser.goto(158),
            TokenType::Functioncall => parser.goto(243),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<37> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::Do => parser.shift(170),
            TokenType::Or => parser.shift(257),
            TokenType::Add => parser.shift(290),
            TokenType::Sub => parser.shift(329),
            TokenType::Mul => parser.shift(352),
            TokenType::Div => parser.shift(362),
            TokenType::Idiv => parser.shift(373),
            TokenType::Mod => parser.shift(383),
            TokenType::Pow => parser.shift(389),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitOr => parser.shift(417),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftR => parser.shift(432),
            TokenType::Eq => parser.shift(437),
            TokenType::Neq => parser.shift(440),
            TokenType::Leq => parser.shift(444),
            TokenType::Geq => parser.shift(450),
            TokenType::Less => parser.shift(452),
            TokenType::Greater => parser.shift(454),
            TokenType::Concat => parser.shift(455),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<38> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(166),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Eof => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(159),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<39> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::BlockStat => parser.goto(173),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<40> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(44),
            TokenType::Do => parser.shift(47),
            TokenType::For => parser.shift(55),
            TokenType::Function => parser.shift(58),
            TokenType::Goto => parser.shift(60),
            TokenType::If => parser.shift(62),
            TokenType::Local => parser.shift(72),
            TokenType::Repeat => parser.shift(73),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(77),
            TokenType::LParen => parser.shift(87),
            TokenType::DoubleColon => parser.shift(84),
            TokenType::SemiColon => parser.shift(80),
            TokenType::BlockStat => parser.goto(172),
            TokenType::Stat => parser.goto(40),
            TokenType::Label => parser.goto(81),
            TokenType::Varlist => parser.goto(82),
            TokenType::Var => parser.goto(85),
            TokenType::Functioncall => parser.goto(83),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<41> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Then => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<42> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Return => parser.reduce::<3>(),
            TokenType::Eof => parser.reduce::<3>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<43> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<10>(),
            TokenType::Break => parser.reduce::<10>(),
            TokenType::Do => parser.reduce::<10>(),
            TokenType::End => parser.reduce::<10>(),
            TokenType::For => parser.reduce::<10>(),
            TokenType::Function => parser.reduce::<10>(),
            TokenType::Goto => parser.reduce::<10>(),
            TokenType::If => parser.reduce::<10>(),
            TokenType::Local => parser.reduce::<10>(),
            TokenType::Repeat => parser.reduce::<10>(),
            TokenType::Return => parser.reduce::<10>(),
            TokenType::While => parser.reduce::<10>(),
            TokenType::LParen => parser.reduce::<10>(),
            TokenType::DoubleColon => parser.reduce::<10>(),
            TokenType::SemiColon => parser.reduce::<10>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<44> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<10>(),
            TokenType::Break => parser.reduce::<10>(),
            TokenType::Do => parser.reduce::<10>(),
            TokenType::For => parser.reduce::<10>(),
            TokenType::Function => parser.reduce::<10>(),
            TokenType::Goto => parser.reduce::<10>(),
            TokenType::If => parser.reduce::<10>(),
            TokenType::Local => parser.reduce::<10>(),
            TokenType::Repeat => parser.reduce::<10>(),
            TokenType::Return => parser.reduce::<10>(),
            TokenType::Until => parser.reduce::<10>(),
            TokenType::While => parser.reduce::<10>(),
            TokenType::LParen => parser.reduce::<10>(),
            TokenType::DoubleColon => parser.reduce::<10>(),
            TokenType::SemiColon => parser.reduce::<10>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<45> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<46> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(208),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<47> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(212),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<48> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(320),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<49> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::SemiColon => parser.reduce::<35>(),
            TokenType::Dots => parser.shift(401),
            TokenType::Eof => parser.reduce::<35>(),
            TokenType::RetstatExplist => parser.goto(161),
            TokenType::Var => parser.goto(289),
            TokenType::Explist => parser.goto(162),
            TokenType::Exp => parser.goto(295),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<50> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(271),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<51> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(272),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<52> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(313),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<53> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(256),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<54> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Explist => parser.goto(167),
            TokenType::Exp => parser.goto(336),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<55> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(164),
            TokenType::Namelist => parser.goto(168),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<56> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(165),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<57> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(174),
            TokenType::Namelist => parser.goto(177),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<58> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(34),
            TokenType::Funcname => parser.goto(175),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<59> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(34),
            TokenType::Funcname => parser.goto(180),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<60> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(176),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<61> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(179),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<62> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(178),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<63> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(184),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<64> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(181),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<65> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(199),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<66> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<98>(),
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::Break => parser.reduce::<98>(),
            TokenType::Do => parser.reduce::<98>(),
            TokenType::For => parser.reduce::<98>(),
            TokenType::Function => parser.reduce::<98>(),
            TokenType::Goto => parser.reduce::<98>(),
            TokenType::If => parser.reduce::<98>(),
            TokenType::Local => parser.reduce::<98>(),
            TokenType::Repeat => parser.reduce::<98>(),
            TokenType::Return => parser.reduce::<98>(),
            TokenType::While => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::DoubleColon => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Eof => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<67> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<108>(),
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::Break => parser.reduce::<108>(),
            TokenType::Do => parser.reduce::<108>(),
            TokenType::For => parser.reduce::<108>(),
            TokenType::Function => parser.reduce::<108>(),
            TokenType::Goto => parser.reduce::<108>(),
            TokenType::If => parser.reduce::<108>(),
            TokenType::Local => parser.reduce::<108>(),
            TokenType::Repeat => parser.reduce::<108>(),
            TokenType::Return => parser.reduce::<108>(),
            TokenType::While => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::DoubleColon => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Eof => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<68> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(203),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<69> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(186),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<70> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<99>(),
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::Break => parser.reduce::<99>(),
            TokenType::Do => parser.reduce::<99>(),
            TokenType::For => parser.reduce::<99>(),
            TokenType::Function => parser.reduce::<99>(),
            TokenType::Goto => parser.reduce::<99>(),
            TokenType::If => parser.reduce::<99>(),
            TokenType::Local => parser.reduce::<99>(),
            TokenType::Repeat => parser.reduce::<99>(),
            TokenType::Return => parser.reduce::<99>(),
            TokenType::While => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::DoubleColon => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Eof => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<71> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(404),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<72> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::Function => parser.shift(183),
            TokenType::Attnamelist => parser.goto(185),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<73> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(44),
            TokenType::Do => parser.shift(47),
            TokenType::For => parser.shift(55),
            TokenType::Function => parser.shift(58),
            TokenType::Goto => parser.shift(60),
            TokenType::If => parser.shift(62),
            TokenType::Local => parser.shift(72),
            TokenType::Repeat => parser.shift(73),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(77),
            TokenType::LParen => parser.shift(87),
            TokenType::DoubleColon => parser.shift(84),
            TokenType::SemiColon => parser.shift(80),
            TokenType::Block => parser.goto(242),
            TokenType::BlockStat => parser.goto(28),
            TokenType::Stat => parser.goto(40),
            TokenType::Label => parser.goto(81),
            TokenType::Varlist => parser.goto(82),
            TokenType::Var => parser.goto(85),
            TokenType::Functioncall => parser.goto(83),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<74> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(190),
            TokenType::Function => parser.shift(188),
            TokenType::Attnamelist => parser.goto(189),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<75> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(44),
            TokenType::Do => parser.shift(47),
            TokenType::For => parser.shift(55),
            TokenType::Function => parser.shift(58),
            TokenType::Goto => parser.shift(60),
            TokenType::If => parser.shift(62),
            TokenType::Local => parser.shift(72),
            TokenType::Repeat => parser.shift(73),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(77),
            TokenType::LParen => parser.shift(87),
            TokenType::DoubleColon => parser.shift(84),
            TokenType::SemiColon => parser.shift(80),
            TokenType::Block => parser.goto(246),
            TokenType::BlockStat => parser.goto(28),
            TokenType::Stat => parser.goto(40),
            TokenType::Label => parser.goto(81),
            TokenType::Varlist => parser.goto(82),
            TokenType::Var => parser.goto(85),
            TokenType::Functioncall => parser.goto(83),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<76> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.shift(209),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<77> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(191),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<78> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(198),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<79> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(200),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<80> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<6>(),
            TokenType::Break => parser.reduce::<6>(),
            TokenType::Do => parser.reduce::<6>(),
            TokenType::For => parser.reduce::<6>(),
            TokenType::Function => parser.reduce::<6>(),
            TokenType::Goto => parser.reduce::<6>(),
            TokenType::If => parser.reduce::<6>(),
            TokenType::Local => parser.reduce::<6>(),
            TokenType::Repeat => parser.reduce::<6>(),
            TokenType::Return => parser.reduce::<6>(),
            TokenType::Until => parser.reduce::<6>(),
            TokenType::While => parser.reduce::<6>(),
            TokenType::LParen => parser.reduce::<6>(),
            TokenType::DoubleColon => parser.reduce::<6>(),
            TokenType::SemiColon => parser.reduce::<6>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<81> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<9>(),
            TokenType::Break => parser.reduce::<9>(),
            TokenType::Do => parser.reduce::<9>(),
            TokenType::For => parser.reduce::<9>(),
            TokenType::Function => parser.reduce::<9>(),
            TokenType::Goto => parser.reduce::<9>(),
            TokenType::If => parser.reduce::<9>(),
            TokenType::Local => parser.reduce::<9>(),
            TokenType::Repeat => parser.reduce::<9>(),
            TokenType::Return => parser.reduce::<9>(),
            TokenType::Until => parser.reduce::<9>(),
            TokenType::While => parser.reduce::<9>(),
            TokenType::LParen => parser.reduce::<9>(),
            TokenType::DoubleColon => parser.reduce::<9>(),
            TokenType::SemiColon => parser.reduce::<9>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<82> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(220),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<83> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<8>(),
            TokenType::String(_) => parser.shift(224),
            TokenType::Break => parser.reduce::<8>(),
            TokenType::Do => parser.reduce::<8>(),
            TokenType::For => parser.reduce::<8>(),
            TokenType::Function => parser.reduce::<8>(),
            TokenType::Goto => parser.reduce::<8>(),
            TokenType::If => parser.reduce::<8>(),
            TokenType::Local => parser.reduce::<8>(),
            TokenType::Repeat => parser.reduce::<8>(),
            TokenType::Return => parser.reduce::<8>(),
            TokenType::Until => parser.reduce::<8>(),
            TokenType::While => parser.reduce::<8>(),
            // Shift(225)-Reduce(8)
            TokenType::LParen => parser.shift(225),
            TokenType::LSquare => parser.shift(52),
            TokenType::LCurly => parser.shift(248),
            TokenType::DoubleColon => parser.reduce::<8>(),
            TokenType::SemiColon => parser.reduce::<8>(),
            TokenType::Colon => parser.shift(222),
            TokenType::Dot => parser.shift(68),
            TokenType::Args => parser.goto(223),
            TokenType::Tableconstructor => parser.goto(247),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<84> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(213),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<85> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(224),
            TokenType::Assign => parser.reduce::<46>(),
            TokenType::LParen => parser.shift(225),
            TokenType::LSquare => parser.shift(48),
            TokenType::LCurly => parser.shift(248),
            TokenType::Colon => parser.shift(236),
            TokenType::Comma => parser.shift(36),
            TokenType::Dot => parser.shift(64),
            TokenType::VarlistCont => parser.goto(33),
            TokenType::Args => parser.goto(237),
            TokenType::Tableconstructor => parser.goto(247),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<86> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<107>(),
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::Break => parser.reduce::<107>(),
            TokenType::Do => parser.reduce::<107>(),
            TokenType::For => parser.reduce::<107>(),
            TokenType::Function => parser.reduce::<107>(),
            TokenType::Goto => parser.reduce::<107>(),
            TokenType::If => parser.reduce::<107>(),
            TokenType::Local => parser.reduce::<107>(),
            TokenType::Repeat => parser.reduce::<107>(),
            TokenType::Return => parser.reduce::<107>(),
            TokenType::While => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::DoubleColon => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Eof => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<87> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(276),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<88> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(421),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<89> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<6>(),
            TokenType::Break => parser.reduce::<6>(),
            TokenType::Do => parser.reduce::<6>(),
            TokenType::End => parser.reduce::<6>(),
            TokenType::For => parser.reduce::<6>(),
            TokenType::Function => parser.reduce::<6>(),
            TokenType::Goto => parser.reduce::<6>(),
            TokenType::If => parser.reduce::<6>(),
            TokenType::Local => parser.reduce::<6>(),
            TokenType::Repeat => parser.reduce::<6>(),
            TokenType::Return => parser.reduce::<6>(),
            TokenType::While => parser.reduce::<6>(),
            TokenType::LParen => parser.reduce::<6>(),
            TokenType::DoubleColon => parser.reduce::<6>(),
            TokenType::SemiColon => parser.reduce::<6>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<90> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<9>(),
            TokenType::Break => parser.reduce::<9>(),
            TokenType::Do => parser.reduce::<9>(),
            TokenType::End => parser.reduce::<9>(),
            TokenType::For => parser.reduce::<9>(),
            TokenType::Function => parser.reduce::<9>(),
            TokenType::Goto => parser.reduce::<9>(),
            TokenType::If => parser.reduce::<9>(),
            TokenType::Local => parser.reduce::<9>(),
            TokenType::Repeat => parser.reduce::<9>(),
            TokenType::Return => parser.reduce::<9>(),
            TokenType::While => parser.reduce::<9>(),
            TokenType::LParen => parser.reduce::<9>(),
            TokenType::DoubleColon => parser.reduce::<9>(),
            TokenType::SemiColon => parser.reduce::<9>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<91> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(218),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<92> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<8>(),
            TokenType::String(_) => parser.shift(240),
            TokenType::Break => parser.reduce::<8>(),
            TokenType::Do => parser.reduce::<8>(),
            TokenType::End => parser.reduce::<8>(),
            TokenType::For => parser.reduce::<8>(),
            TokenType::Function => parser.reduce::<8>(),
            TokenType::Goto => parser.reduce::<8>(),
            TokenType::If => parser.reduce::<8>(),
            TokenType::Local => parser.reduce::<8>(),
            TokenType::Repeat => parser.reduce::<8>(),
            TokenType::Return => parser.reduce::<8>(),
            TokenType::While => parser.reduce::<8>(),
            // Shift(241)-Reduce(8)
            TokenType::LParen => parser.shift(241),
            TokenType::LSquare => parser.shift(52),
            TokenType::LCurly => parser.shift(270),
            TokenType::DoubleColon => parser.reduce::<8>(),
            TokenType::SemiColon => parser.reduce::<8>(),
            TokenType::Colon => parser.shift(238),
            TokenType::Dot => parser.shift(68),
            TokenType::Args => parser.goto(239),
            TokenType::Tableconstructor => parser.goto(268),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<93> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(226),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<94> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(240),
            TokenType::Assign => parser.reduce::<46>(),
            TokenType::LParen => parser.shift(241),
            TokenType::LSquare => parser.shift(48),
            TokenType::LCurly => parser.shift(270),
            TokenType::Colon => parser.shift(244),
            TokenType::Comma => parser.shift(36),
            TokenType::Dot => parser.shift(64),
            TokenType::VarlistCont => parser.goto(33),
            TokenType::Args => parser.goto(245),
            TokenType::Tableconstructor => parser.goto(268),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<95> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(282),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<96> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(266),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.shift(267),
            TokenType::RParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.shift(233),
            TokenType::LCurly => parser.shift(284),
            TokenType::Colon => parser.shift(278),
            TokenType::Dot => parser.shift(277),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(279),
            TokenType::Tableconstructor => parser.goto(283),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<97> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(266),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.shift(267),
            TokenType::RParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.shift(231),
            TokenType::LCurly => parser.shift(284),
            TokenType::Colon => parser.shift(264),
            TokenType::Dot => parser.shift(263),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(265),
            TokenType::Tableconstructor => parser.goto(283),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<98> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::RParen => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<99> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::RParen => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<100> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::RParen => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<101> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::RParen => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<102> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::RParen => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<103> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(335),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<104> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(262),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.shift(269),
            TokenType::LSquare => parser.shift(219),
            TokenType::LCurly => parser.shift(288),
            TokenType::Colon => parser.shift(260),
            TokenType::Dot => parser.shift(259),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(261),
            TokenType::Tableconstructor => parser.goto(287),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<105> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(262),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.shift(269),
            TokenType::LSquare => parser.shift(221),
            TokenType::LCurly => parser.shift(288),
            TokenType::Colon => parser.shift(274),
            TokenType::Dot => parser.shift(273),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(275),
            TokenType::Tableconstructor => parser.goto(287),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<106> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<107> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<108> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<109> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<110> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<111> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(355),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<112> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::RParen => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<113> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(311),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<114> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(253),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Then => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.shift(258),
            TokenType::LSquare => parser.shift(215),
            TokenType::LCurly => parser.shift(286),
            TokenType::Colon => parser.shift(254),
            TokenType::Dot => parser.shift(249),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(255),
            TokenType::Tableconstructor => parser.goto(285),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<115> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(253),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Then => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.shift(258),
            TokenType::LSquare => parser.shift(216),
            TokenType::LCurly => parser.shift(286),
            TokenType::Colon => parser.shift(251),
            TokenType::Dot => parser.shift(250),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(252),
            TokenType::Tableconstructor => parser.goto(285),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<116> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<117> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(368),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<118> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Then => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<119> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Then => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<120> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Then => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<121> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Then => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<122> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Then => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<123> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(353),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<124> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(351),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<125> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(359),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<126> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Then => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<127> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(330),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<128> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(360),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<129> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(380),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<130> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(357),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<131> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(369),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<132> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::RParen => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<133> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<134> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<135> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<136> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::RParen => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<137> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::RParen => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<138> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Then => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<139> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Then => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<140> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Then => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<141> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(228),
            TokenType::Funcbody => parser.goto(227),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<142> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(409),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<143> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(211),
            TokenType::Funcbody => parser.goto(210),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<144> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(427),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<145> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(230),
            TokenType::Funcbody => parser.goto(229),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<146> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(435),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<147> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<1>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<148> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<5>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<149> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<1>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<150> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<5>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<151> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<24>(),
            TokenType::Break => parser.reduce::<24>(),
            TokenType::Do => parser.reduce::<24>(),
            TokenType::For => parser.reduce::<24>(),
            TokenType::Function => parser.reduce::<24>(),
            TokenType::Goto => parser.reduce::<24>(),
            TokenType::If => parser.reduce::<24>(),
            TokenType::Local => parser.reduce::<24>(),
            TokenType::Repeat => parser.reduce::<24>(),
            TokenType::Return => parser.reduce::<24>(),
            TokenType::While => parser.reduce::<24>(),
            TokenType::LParen => parser.reduce::<24>(),
            TokenType::DoubleColon => parser.reduce::<24>(),
            TokenType::SemiColon => parser.reduce::<24>(),
            TokenType::Eof => parser.reduce::<24>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<152> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(153),
            TokenType::Funcbody => parser.goto(459),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<153> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(464),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<154> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<26>(),
            TokenType::Break => parser.reduce::<26>(),
            TokenType::Do => parser.reduce::<26>(),
            TokenType::For => parser.reduce::<26>(),
            TokenType::Function => parser.reduce::<26>(),
            TokenType::Goto => parser.reduce::<26>(),
            TokenType::If => parser.reduce::<26>(),
            TokenType::Local => parser.reduce::<26>(),
            TokenType::Repeat => parser.reduce::<26>(),
            TokenType::Return => parser.reduce::<26>(),
            TokenType::While => parser.reduce::<26>(),
            TokenType::LParen => parser.reduce::<26>(),
            TokenType::DoubleColon => parser.reduce::<26>(),
            TokenType::SemiColon => parser.reduce::<26>(),
            TokenType::Eof => parser.reduce::<26>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<155> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<39>(),
            TokenType::Break => parser.reduce::<39>(),
            TokenType::Do => parser.reduce::<39>(),
            TokenType::For => parser.reduce::<39>(),
            TokenType::Function => parser.reduce::<39>(),
            TokenType::Goto => parser.reduce::<39>(),
            TokenType::If => parser.reduce::<39>(),
            TokenType::Local => parser.reduce::<39>(),
            TokenType::Repeat => parser.reduce::<39>(),
            TokenType::Return => parser.reduce::<39>(),
            TokenType::While => parser.reduce::<39>(),
            TokenType::LParen => parser.reduce::<39>(),
            TokenType::DoubleColon => parser.reduce::<39>(),
            TokenType::SemiColon => parser.reduce::<39>(),
            TokenType::Eof => parser.reduce::<39>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<156> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<43>(),
            TokenType::Colon => parser.shift(462),
            TokenType::FuncnameEnd => parser.goto(461),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<157> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(476),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<158> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(545),
            TokenType::Assign => parser.reduce::<46>(),
            TokenType::LParen => parser.shift(547),
            TokenType::LSquare => parser.shift(48),
            TokenType::LCurly => parser.shift(575),
            TokenType::Colon => parser.shift(543),
            TokenType::Comma => parser.shift(36),
            TokenType::Dot => parser.shift(64),
            TokenType::VarlistCont => parser.goto(460),
            TokenType::Args => parser.goto(544),
            TokenType::Tableconstructor => parser.goto(573),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<159> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(474),
            TokenType::Eof => parser.reduce::<30>(),
            TokenType::AttnamelistCont => parser.goto(465),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<160> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::RSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<161> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::SemiColon => parser.shift(472),
            TokenType::Eof => parser.reduce::<37>(),
            TokenType::RetstatEnd => parser.goto(471),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<162> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::SemiColon => parser.reduce::<36>(),
            TokenType::Eof => parser.reduce::<36>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<163> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            TokenType::Eof => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<164> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<56>(),
            TokenType::Assign => parser.shift(525),
            TokenType::Comma => parser.shift(235),
            TokenType::NamelistCont => parser.goto(234),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<165> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<12>(),
            TokenType::Break => parser.reduce::<12>(),
            TokenType::Do => parser.reduce::<12>(),
            TokenType::For => parser.reduce::<12>(),
            TokenType::Function => parser.reduce::<12>(),
            TokenType::Goto => parser.reduce::<12>(),
            TokenType::If => parser.reduce::<12>(),
            TokenType::Local => parser.reduce::<12>(),
            TokenType::Repeat => parser.reduce::<12>(),
            TokenType::Return => parser.reduce::<12>(),
            TokenType::While => parser.reduce::<12>(),
            TokenType::LParen => parser.reduce::<12>(),
            TokenType::DoubleColon => parser.reduce::<12>(),
            TokenType::SemiColon => parser.reduce::<12>(),
            TokenType::Eof => parser.reduce::<12>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<166> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(458),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<167> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<7>(),
            TokenType::Break => parser.reduce::<7>(),
            TokenType::Do => parser.reduce::<7>(),
            TokenType::For => parser.reduce::<7>(),
            TokenType::Function => parser.reduce::<7>(),
            TokenType::Goto => parser.reduce::<7>(),
            TokenType::If => parser.reduce::<7>(),
            TokenType::Local => parser.reduce::<7>(),
            TokenType::Repeat => parser.reduce::<7>(),
            TokenType::Return => parser.reduce::<7>(),
            TokenType::While => parser.reduce::<7>(),
            TokenType::LParen => parser.reduce::<7>(),
            TokenType::DoubleColon => parser.reduce::<7>(),
            TokenType::SemiColon => parser.reduce::<7>(),
            TokenType::Eof => parser.reduce::<7>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<168> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.shift(518),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<169> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            TokenType::Eof => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<170> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(649),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<171> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(511),
            TokenType::Do => parser.shift(517),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(532),
            TokenType::Function => parser.shift(533),
            TokenType::Goto => parser.shift(535),
            TokenType::If => parser.shift(551),
            TokenType::Local => parser.shift(615),
            TokenType::Repeat => parser.shift(616),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(618),
            TokenType::LParen => parser.shift(652),
            TokenType::DoubleColon => parser.shift(648),
            TokenType::SemiColon => parser.shift(644),
            TokenType::Block => parser.goto(608),
            TokenType::BlockStat => parser.goto(466),
            TokenType::Stat => parser.goto(498),
            TokenType::Label => parser.goto(645),
            TokenType::Varlist => parser.goto(646),
            TokenType::Var => parser.goto(650),
            TokenType::Functioncall => parser.goto(647),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<172> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Return => parser.reduce::<3>(),
            TokenType::Until => parser.reduce::<3>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<173> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<3>(),
            TokenType::Return => parser.reduce::<3>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<174> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<56>(),
            TokenType::Assign => parser.shift(514),
            TokenType::Comma => parser.shift(235),
            TokenType::NamelistCont => parser.goto(234),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<175> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(473),
            TokenType::Funcbody => parser.goto(468),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<176> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<11>(),
            TokenType::Break => parser.reduce::<11>(),
            TokenType::Do => parser.reduce::<11>(),
            TokenType::For => parser.reduce::<11>(),
            TokenType::Function => parser.reduce::<11>(),
            TokenType::Goto => parser.reduce::<11>(),
            TokenType::If => parser.reduce::<11>(),
            TokenType::Local => parser.reduce::<11>(),
            TokenType::Repeat => parser.reduce::<11>(),
            TokenType::Return => parser.reduce::<11>(),
            TokenType::Until => parser.reduce::<11>(),
            TokenType::While => parser.reduce::<11>(),
            TokenType::LParen => parser.reduce::<11>(),
            TokenType::DoubleColon => parser.reduce::<11>(),
            TokenType::SemiColon => parser.reduce::<11>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<177> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.shift(516),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<178> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::Or => parser.shift(281),
            TokenType::Then => parser.shift(502),
            TokenType::Add => parser.shift(328),
            TokenType::Sub => parser.shift(337),
            TokenType::Mul => parser.shift(356),
            TokenType::Div => parser.shift(365),
            TokenType::Idiv => parser.shift(370),
            TokenType::Mod => parser.shift(376),
            TokenType::Pow => parser.shift(385),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitOr => parser.shift(402),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftR => parser.shift(418),
            TokenType::Eq => parser.shift(424),
            TokenType::Neq => parser.shift(428),
            TokenType::Leq => parser.shift(433),
            TokenType::Geq => parser.shift(436),
            TokenType::Less => parser.shift(439),
            TokenType::Greater => parser.shift(443),
            TokenType::Concat => parser.shift(448),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<179> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<11>(),
            TokenType::Break => parser.reduce::<11>(),
            TokenType::Do => parser.reduce::<11>(),
            TokenType::End => parser.reduce::<11>(),
            TokenType::For => parser.reduce::<11>(),
            TokenType::Function => parser.reduce::<11>(),
            TokenType::Goto => parser.reduce::<11>(),
            TokenType::If => parser.reduce::<11>(),
            TokenType::Local => parser.reduce::<11>(),
            TokenType::Repeat => parser.reduce::<11>(),
            TokenType::Return => parser.reduce::<11>(),
            TokenType::While => parser.reduce::<11>(),
            TokenType::LParen => parser.reduce::<11>(),
            TokenType::DoubleColon => parser.reduce::<11>(),
            TokenType::SemiColon => parser.reduce::<11>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<180> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(478),
            TokenType::Funcbody => parser.goto(475),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<181> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::Assign => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Comma => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<182> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::RParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<183> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(477),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<184> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::Or => parser.shift(281),
            TokenType::Then => parser.shift(501),
            TokenType::Add => parser.shift(328),
            TokenType::Sub => parser.shift(337),
            TokenType::Mul => parser.shift(356),
            TokenType::Div => parser.shift(365),
            TokenType::Idiv => parser.shift(370),
            TokenType::Mod => parser.shift(376),
            TokenType::Pow => parser.shift(385),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitOr => parser.shift(402),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftR => parser.shift(418),
            TokenType::Eq => parser.shift(424),
            TokenType::Neq => parser.shift(428),
            TokenType::Leq => parser.shift(433),
            TokenType::Geq => parser.shift(436),
            TokenType::Less => parser.shift(439),
            TokenType::Greater => parser.shift(443),
            TokenType::Concat => parser.shift(448),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<185> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<27>(),
            TokenType::Break => parser.reduce::<27>(),
            TokenType::Do => parser.reduce::<27>(),
            TokenType::For => parser.reduce::<27>(),
            TokenType::Function => parser.reduce::<27>(),
            TokenType::Goto => parser.reduce::<27>(),
            TokenType::If => parser.reduce::<27>(),
            TokenType::Local => parser.reduce::<27>(),
            TokenType::Repeat => parser.reduce::<27>(),
            TokenType::Return => parser.reduce::<27>(),
            TokenType::Until => parser.reduce::<27>(),
            TokenType::While => parser.reduce::<27>(),
            TokenType::Assign => parser.shift(531),
            TokenType::LParen => parser.reduce::<27>(),
            TokenType::DoubleColon => parser.reduce::<27>(),
            TokenType::SemiColon => parser.reduce::<27>(),
            TokenType::StatAttexplist => parser.goto(479),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<186> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(67),
            TokenType::LParen => parser.shift(71),
            TokenType::LCurly => parser.shift(88),
            TokenType::Args => parser.goto(480),
            TokenType::Tableconstructor => parser.goto(86),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<187> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::Until => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(496),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(483),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<188> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(481),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<189> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<27>(),
            TokenType::Break => parser.reduce::<27>(),
            TokenType::Do => parser.reduce::<27>(),
            TokenType::End => parser.reduce::<27>(),
            TokenType::For => parser.reduce::<27>(),
            TokenType::Function => parser.reduce::<27>(),
            TokenType::Goto => parser.reduce::<27>(),
            TokenType::If => parser.reduce::<27>(),
            TokenType::Local => parser.reduce::<27>(),
            TokenType::Repeat => parser.reduce::<27>(),
            TokenType::Return => parser.reduce::<27>(),
            TokenType::While => parser.reduce::<27>(),
            TokenType::Assign => parser.shift(524),
            TokenType::LParen => parser.reduce::<27>(),
            TokenType::DoubleColon => parser.reduce::<27>(),
            TokenType::SemiColon => parser.reduce::<27>(),
            TokenType::StatAttexplist => parser.goto(482),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<190> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::End => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(510),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(484),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<191> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::Do => parser.shift(499),
            TokenType::Or => parser.shift(257),
            TokenType::Add => parser.shift(290),
            TokenType::Sub => parser.shift(329),
            TokenType::Mul => parser.shift(352),
            TokenType::Div => parser.shift(362),
            TokenType::Idiv => parser.shift(373),
            TokenType::Mod => parser.shift(383),
            TokenType::Pow => parser.shift(389),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitOr => parser.shift(417),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftR => parser.shift(432),
            TokenType::Eq => parser.shift(437),
            TokenType::Neq => parser.shift(440),
            TokenType::Leq => parser.shift(444),
            TokenType::Geq => parser.shift(450),
            TokenType::Less => parser.shift(452),
            TokenType::Greater => parser.shift(454),
            TokenType::Concat => parser.shift(455),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<192> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::Assign => parser.shift(521),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::RCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<193> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(493),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<194> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Explist => parser.goto(485),
            TokenType::Exp => parser.goto(710),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<195> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(643),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<196> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::End => parser.reduce::<35>(),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::SemiColon => parser.reduce::<35>(),
            TokenType::Dots => parser.shift(895),
            TokenType::RetstatExplist => parser.goto(486),
            TokenType::Var => parser.goto(719),
            TokenType::Explist => parser.goto(488),
            TokenType::Exp => parser.goto(722),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<197> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Until => parser.reduce::<35>(),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::SemiColon => parser.reduce::<35>(),
            TokenType::Dots => parser.shift(886),
            TokenType::RetstatExplist => parser.goto(487),
            TokenType::Var => parser.goto(692),
            TokenType::Explist => parser.goto(490),
            TokenType::Exp => parser.goto(699),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<198> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(67),
            TokenType::LParen => parser.shift(71),
            TokenType::LSquare => parser.shift(515),
            TokenType::LCurly => parser.shift(88),
            TokenType::Colon => parser.shift(557),
            TokenType::Dot => parser.shift(556),
            TokenType::Args => parser.goto(558),
            TokenType::Tableconstructor => parser.goto(86),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<199> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(67),
            TokenType::LParen => parser.shift(71),
            TokenType::LCurly => parser.shift(88),
            TokenType::Args => parser.goto(491),
            TokenType::Tableconstructor => parser.goto(86),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<200> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::Do => parser.shift(500),
            TokenType::Or => parser.shift(257),
            TokenType::Add => parser.shift(290),
            TokenType::Sub => parser.shift(329),
            TokenType::Mul => parser.shift(352),
            TokenType::Div => parser.shift(362),
            TokenType::Idiv => parser.shift(373),
            TokenType::Mod => parser.shift(383),
            TokenType::Pow => parser.shift(389),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitOr => parser.shift(417),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftR => parser.shift(432),
            TokenType::Eq => parser.shift(437),
            TokenType::Neq => parser.shift(440),
            TokenType::Leq => parser.shift(444),
            TokenType::Geq => parser.shift(450),
            TokenType::Less => parser.shift(452),
            TokenType::Greater => parser.shift(454),
            TokenType::Concat => parser.shift(455),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<201> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(634),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<202> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(651),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<203> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::Assign => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Comma => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<204> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Explist => parser.goto(509),
            TokenType::Exp => parser.goto(336),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<205> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(636),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<206> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(623),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<207> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(637),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<208> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(495),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<209> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(508),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<210> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::RParen => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<211> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(520),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<212> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(505),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<213> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::DoubleColon => parser.shift(497),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<214> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(798),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<215> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(688),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<216> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(689),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<217> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(834),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<218> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Explist => parser.goto(512),
            TokenType::Exp => parser.goto(757),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<219> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(690),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<220> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Explist => parser.goto(506),
            TokenType::Exp => parser.goto(771),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<221> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(683),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<222> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(503),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<223> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<99>(),
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::Break => parser.reduce::<99>(),
            TokenType::Do => parser.reduce::<99>(),
            TokenType::For => parser.reduce::<99>(),
            TokenType::Function => parser.reduce::<99>(),
            TokenType::Goto => parser.reduce::<99>(),
            TokenType::If => parser.reduce::<99>(),
            TokenType::Local => parser.reduce::<99>(),
            TokenType::Repeat => parser.reduce::<99>(),
            TokenType::Return => parser.reduce::<99>(),
            TokenType::Until => parser.reduce::<99>(),
            TokenType::While => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::DoubleColon => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<224> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<108>(),
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::Break => parser.reduce::<108>(),
            TokenType::Do => parser.reduce::<108>(),
            TokenType::For => parser.reduce::<108>(),
            TokenType::Function => parser.reduce::<108>(),
            TokenType::Goto => parser.reduce::<108>(),
            TokenType::If => parser.reduce::<108>(),
            TokenType::Local => parser.reduce::<108>(),
            TokenType::Repeat => parser.reduce::<108>(),
            TokenType::Return => parser.reduce::<108>(),
            TokenType::Until => parser.reduce::<108>(),
            TokenType::While => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::DoubleColon => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<225> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(926),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<226> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::DoubleColon => parser.shift(528),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<227> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<109>(),
            TokenType::Do => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<228> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(527),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<229> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Then => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<230> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(529),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<231> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(667),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<232> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(806),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<233> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(721),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<234> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<55>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<235> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(549),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<236> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(550),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<237> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<98>(),
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::Break => parser.reduce::<98>(),
            TokenType::Do => parser.reduce::<98>(),
            TokenType::For => parser.reduce::<98>(),
            TokenType::Function => parser.reduce::<98>(),
            TokenType::Goto => parser.reduce::<98>(),
            TokenType::If => parser.reduce::<98>(),
            TokenType::Local => parser.reduce::<98>(),
            TokenType::Repeat => parser.reduce::<98>(),
            TokenType::Return => parser.reduce::<98>(),
            TokenType::Until => parser.reduce::<98>(),
            TokenType::While => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::DoubleColon => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<238> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(536),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<239> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<99>(),
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::Break => parser.reduce::<99>(),
            TokenType::Do => parser.reduce::<99>(),
            TokenType::End => parser.reduce::<99>(),
            TokenType::For => parser.reduce::<99>(),
            TokenType::Function => parser.reduce::<99>(),
            TokenType::Goto => parser.reduce::<99>(),
            TokenType::If => parser.reduce::<99>(),
            TokenType::Local => parser.reduce::<99>(),
            TokenType::Repeat => parser.reduce::<99>(),
            TokenType::Return => parser.reduce::<99>(),
            TokenType::While => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::DoubleColon => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<240> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<108>(),
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::Break => parser.reduce::<108>(),
            TokenType::Do => parser.reduce::<108>(),
            TokenType::End => parser.reduce::<108>(),
            TokenType::For => parser.reduce::<108>(),
            TokenType::Function => parser.reduce::<108>(),
            TokenType::Goto => parser.reduce::<108>(),
            TokenType::If => parser.reduce::<108>(),
            TokenType::Local => parser.reduce::<108>(),
            TokenType::Repeat => parser.reduce::<108>(),
            TokenType::Return => parser.reduce::<108>(),
            TokenType::While => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::DoubleColon => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<241> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(917),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<242> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.shift(546),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<243> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(545),
            TokenType::LParen => parser.shift(547),
            TokenType::LSquare => parser.shift(52),
            TokenType::LCurly => parser.shift(575),
            TokenType::Colon => parser.shift(593),
            TokenType::Dot => parser.shift(68),
            TokenType::Args => parser.goto(594),
            TokenType::Tableconstructor => parser.goto(573),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<244> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(569),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<245> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<98>(),
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::Break => parser.reduce::<98>(),
            TokenType::Do => parser.reduce::<98>(),
            TokenType::End => parser.reduce::<98>(),
            TokenType::For => parser.reduce::<98>(),
            TokenType::Function => parser.reduce::<98>(),
            TokenType::Goto => parser.reduce::<98>(),
            TokenType::If => parser.reduce::<98>(),
            TokenType::Local => parser.reduce::<98>(),
            TokenType::Repeat => parser.reduce::<98>(),
            TokenType::Return => parser.reduce::<98>(),
            TokenType::While => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::DoubleColon => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<246> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.shift(542),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<247> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<107>(),
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::Break => parser.reduce::<107>(),
            TokenType::Do => parser.reduce::<107>(),
            TokenType::For => parser.reduce::<107>(),
            TokenType::Function => parser.reduce::<107>(),
            TokenType::Goto => parser.reduce::<107>(),
            TokenType::If => parser.reduce::<107>(),
            TokenType::Local => parser.reduce::<107>(),
            TokenType::Repeat => parser.reduce::<107>(),
            TokenType::Return => parser.reduce::<107>(),
            TokenType::Until => parser.reduce::<107>(),
            TokenType::While => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::DoubleColon => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<248> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(934),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<249> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(540),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<250> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(538),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<251> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(548),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<252> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Then => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<253> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Then => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<254> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(541),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<255> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Then => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<256> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(553),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<257> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(800),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<258> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(931),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<259> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(554),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<260> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(572),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<261> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Do => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<262> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Do => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<263> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(555),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<264> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(539),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<265> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::RParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<266> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::RParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<267> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(922),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<268> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<107>(),
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::Break => parser.reduce::<107>(),
            TokenType::Do => parser.reduce::<107>(),
            TokenType::End => parser.reduce::<107>(),
            TokenType::For => parser.reduce::<107>(),
            TokenType::Function => parser.reduce::<107>(),
            TokenType::Goto => parser.reduce::<107>(),
            TokenType::If => parser.reduce::<107>(),
            TokenType::Local => parser.reduce::<107>(),
            TokenType::Repeat => parser.reduce::<107>(),
            TokenType::Return => parser.reduce::<107>(),
            TokenType::While => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::DoubleColon => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<269> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(911),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<270> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(914),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<271> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(560),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<272> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(561),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<273> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(588),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<274> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(562),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<275> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Do => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<276> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(559),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<277> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(590),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<278> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(563),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<279> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::RParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<280> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(857),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<281> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(816),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<282> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(565),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<283> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::RParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<284> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(930),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<285> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Then => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<286> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(912),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<287> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Do => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<288> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(938),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<289> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(628),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.shift(629),
            TokenType::LSquare => parser.shift(580),
            TokenType::LCurly => parser.shift(686),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.shift(641),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.shift(640),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Eof => parser.reduce::<69>(),
            TokenType::Args => parser.goto(642),
            TokenType::Tableconstructor => parser.goto(684),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<290> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(822),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<291> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(622),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.shift(627),
            TokenType::RParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.shift(591),
            TokenType::LCurly => parser.shift(677),
            TokenType::Colon => parser.shift(662),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.shift(661),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(663),
            TokenType::Tableconstructor => parser.goto(671),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<292> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(628),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.shift(629),
            TokenType::LSquare => parser.shift(566),
            TokenType::LCurly => parser.shift(686),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.shift(625),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.shift(624),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Eof => parser.reduce::<70>(),
            TokenType::Args => parser.goto(626),
            TokenType::Tableconstructor => parser.goto(684),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<293> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(622),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.shift(627),
            TokenType::RParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.shift(574),
            TokenType::LCurly => parser.shift(677),
            TokenType::Colon => parser.shift(620),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.shift(619),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(621),
            TokenType::Tableconstructor => parser.goto(671),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<294> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(875),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<295> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::Or => parser.shift(670),
            TokenType::Add => parser.shift(728),
            TokenType::Sub => parser.shift(755),
            TokenType::Mul => parser.shift(788),
            TokenType::Div => parser.shift(802),
            TokenType::Idiv => parser.shift(852),
            TokenType::Mod => parser.shift(891),
            TokenType::Pow => parser.shift(903),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitOr => parser.shift(942),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftR => parser.shift(955),
            TokenType::Eq => parser.shift(961),
            TokenType::Neq => parser.shift(969),
            TokenType::Leq => parser.shift(976),
            TokenType::Geq => parser.shift(981),
            TokenType::Less => parser.shift(989),
            TokenType::Greater => parser.shift(992),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(599),
            TokenType::Concat => parser.shift(994),
            TokenType::Eof => parser.reduce::<59>(),
            TokenType::ExplistCont => parser.goto(571),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<296> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Eof => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<297> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Eof => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<298> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            TokenType::Eof => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<299> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            TokenType::Eof => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<300> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            TokenType::Eof => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<301> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(656),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.shift(660),
            TokenType::LSquare => parser.shift(579),
            TokenType::RSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.shift(682),
            TokenType::Colon => parser.shift(654),
            TokenType::Dot => parser.shift(653),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(655),
            TokenType::Tableconstructor => parser.goto(681),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<302> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::Or => parser.shift(639),
            TokenType::Add => parser.shift(694),
            TokenType::Sub => parser.shift(734),
            TokenType::Mul => parser.shift(763),
            TokenType::Div => parser.shift(784),
            TokenType::Idiv => parser.shift(793),
            TokenType::Mod => parser.shift(810),
            TokenType::Pow => parser.shift(874),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitOr => parser.shift(915),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftR => parser.shift(936),
            TokenType::Eq => parser.shift(948),
            TokenType::Neq => parser.shift(954),
            TokenType::Leq => parser.shift(962),
            TokenType::Geq => parser.shift(970),
            TokenType::Less => parser.shift(974),
            TokenType::Greater => parser.shift(977),
            TokenType::RParen => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(581),
            TokenType::Concat => parser.shift(987),
            TokenType::ExplistCont => parser.goto(576),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<303> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::RParen => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<304> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::RParen => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<305> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::RParen => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<306> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(768),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<307> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::RParen => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<308> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::RParen => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<309> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(633),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.shift(635),
            TokenType::LSquare => parser.shift(600),
            TokenType::LCurly => parser.shift(687),
            TokenType::RCurly => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.shift(631),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.shift(630),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(632),
            TokenType::Tableconstructor => parser.goto(685),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<310> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(656),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.shift(660),
            TokenType::LSquare => parser.shift(601),
            TokenType::RSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.shift(682),
            TokenType::Colon => parser.shift(658),
            TokenType::Dot => parser.shift(657),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(659),
            TokenType::Tableconstructor => parser.goto(681),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<311> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::RParen => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<312> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(748),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<313> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(578),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<314> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::RSquare => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<315> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::RSquare => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<316> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::RSquare => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<317> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::RSquare => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<318> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::RSquare => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<319> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(633),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.shift(635),
            TokenType::LSquare => parser.shift(598),
            TokenType::LCurly => parser.shift(687),
            TokenType::RCurly => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.shift(665),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.shift(664),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(666),
            TokenType::Tableconstructor => parser.goto(685),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<320> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(595),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<321> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(737),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<322> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::RCurly => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<323> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::RCurly => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<324> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::RCurly => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<325> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::RCurly => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<326> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::RCurly => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<327> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(744),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<328> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(853),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<329> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(844),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<330> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Then => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(385),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<331> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::RSquare => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<332> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(778),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<333> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.shift(675),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            // Shift(676)-Reduce(69)
            TokenType::LParen => parser.shift(676),
            TokenType::LSquare => parser.shift(611),
            TokenType::LCurly => parser.shift(731),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.shift(679),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.shift(678),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Eof => parser.reduce::<69>(),
            TokenType::Args => parser.goto(680),
            TokenType::Tableconstructor => parser.goto(730),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<334> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.shift(675),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            // Shift(676)-Reduce(70)
            TokenType::LParen => parser.shift(676),
            TokenType::LSquare => parser.shift(613),
            TokenType::LCurly => parser.shift(731),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.shift(673),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.shift(672),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Eof => parser.reduce::<70>(),
            TokenType::Args => parser.goto(674),
            TokenType::Tableconstructor => parser.goto(730),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<335> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::RParen => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<336> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.shift(669),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.shift(770),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.shift(831),
            TokenType::Sub => parser.shift(909),
            TokenType::Mul => parser.shift(939),
            TokenType::Div => parser.shift(959),
            TokenType::Idiv => parser.shift(972),
            TokenType::Mod => parser.shift(990),
            TokenType::Pow => parser.shift(1000),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitOr => parser.shift(1003),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::Eq => parser.shift(1006),
            TokenType::Neq => parser.shift(1007),
            TokenType::Leq => parser.shift(1008),
            TokenType::Geq => parser.shift(1009),
            TokenType::Less => parser.shift(1010),
            TokenType::Greater => parser.shift(1011),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(617),
            TokenType::Concat => parser.shift(1012),
            TokenType::Eof => parser.reduce::<59>(),
            TokenType::ExplistCont => parser.goto(605),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<337> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(855),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<338> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::RParen => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<339> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Eof => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<340> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Eof => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<341> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            TokenType::Eof => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<342> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            TokenType::Eof => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<343> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            TokenType::Eof => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<344> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(782),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<345> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            TokenType::Eof => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<346> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(849),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<347> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(791),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<348> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::RCurly => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<349> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(881),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<350> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(790),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<351> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::RParen => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<352> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(883),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<353> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Then => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(385),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<354> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(794),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<355> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<93>(),
            TokenType::Do => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(389),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<356> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(872),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<357> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Then => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(385),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<358> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(825),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<359> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<94>(),
            TokenType::Do => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(389),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<360> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::RParen => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<361> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(785),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<362> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(845),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<363> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(827),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<364> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(821),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<365> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(823),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<366> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(837),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<367> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(801),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<368> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<95>(),
            TokenType::Do => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(389),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<369> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Then => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(385),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<370> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(865),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<371> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            TokenType::Eof => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<372> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(908),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<373> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(804),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<374> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(807),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<375> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(805),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<376> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(860),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<377> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::RCurly => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<378> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::RParen => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<379> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::Or => parser.shift(668),
            TokenType::Add => parser.shift(732),
            TokenType::Sub => parser.shift(766),
            TokenType::Mul => parser.shift(786),
            TokenType::Div => parser.shift(799),
            TokenType::Idiv => parser.shift(838),
            TokenType::Mod => parser.shift(890),
            TokenType::Pow => parser.shift(897),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitOr => parser.shift(932),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftR => parser.shift(957),
            TokenType::Eq => parser.shift(963),
            TokenType::Neq => parser.shift(973),
            TokenType::Leq => parser.shift(980),
            TokenType::Geq => parser.shift(988),
            TokenType::Less => parser.shift(991),
            TokenType::Greater => parser.shift(993),
            TokenType::RCurly => parser.reduce::<126>(),
            TokenType::SemiColon => parser.reduce::<126>(),
            TokenType::Comma => parser.reduce::<126>(),
            TokenType::Concat => parser.shift(997),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<380> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<96>(),
            TokenType::Do => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(389),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<381> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::RCurly => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<382> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::RCurly => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<383> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(854),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<384> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(869),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<385> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(811),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<386> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(863),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<387> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::RParen => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<388> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::RParen => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<389> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(813),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<390> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(829),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<391> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(826),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<392> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::RSquare => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<393> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(828),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<394> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(880),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<395> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(937),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<396> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(835),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<397> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::RSquare => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<398> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::RSquare => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<399> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(567),
            TokenType::Funcbody => parser.goto(564),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<400> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(924),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<401> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Eof => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<402> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(814),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<403> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(871),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<404> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(582),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<405> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(873),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<406> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<106>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<407> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(592),
            TokenType::Funcbody => parser.goto(587),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<408> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(952),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<409> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(570),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<410> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<119>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<411> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<121>(),
            TokenType::SemiColon => parser.shift(602),
            TokenType::Comma => parser.shift(603),
            TokenType::FieldlistCont => parser.goto(586),
            TokenType::Fieldsep => parser.goto(597),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<412> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(817),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<413> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(820),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<414> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Eof => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<415> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            TokenType::Eof => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<416> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(878),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<417> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(867),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<418> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(836),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<419> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(861),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<420> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(585),
            TokenType::Funcbody => parser.goto(584),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<421> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(568),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<422> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(929),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<423> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(953),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<424> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(847),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<425> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(866),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<426> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(856),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<427> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(606),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<428> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(815),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<429> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(612),
            TokenType::Funcbody => parser.goto(607),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<430> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(943),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<431> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(887),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<432> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(830),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<433> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(885),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<434> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(870),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<435> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(614),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<436> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(833),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<437> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(879),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<438> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(848),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<439> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(819),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<440> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(868),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<441> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(818),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<442> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Eof => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<443> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(851),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<444> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(846),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<445> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(859),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<446> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Eof => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<447> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            TokenType::Eof => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<448> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(842),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<449> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(884),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<450> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(839),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<451> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(862),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<452> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(840),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<453> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(882),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<454> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(824),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<455> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(876),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<456> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(610),
            TokenType::Funcbody => parser.goto(609),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<457> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(958),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<458> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Greater => parser.shift(1013),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<459> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<25>(),
            TokenType::Break => parser.reduce::<25>(),
            TokenType::Do => parser.reduce::<25>(),
            TokenType::For => parser.reduce::<25>(),
            TokenType::Function => parser.reduce::<25>(),
            TokenType::Goto => parser.reduce::<25>(),
            TokenType::If => parser.reduce::<25>(),
            TokenType::Local => parser.reduce::<25>(),
            TokenType::Repeat => parser.reduce::<25>(),
            TokenType::Return => parser.reduce::<25>(),
            TokenType::While => parser.reduce::<25>(),
            TokenType::LParen => parser.reduce::<25>(),
            TokenType::DoubleColon => parser.reduce::<25>(),
            TokenType::SemiColon => parser.reduce::<25>(),
            TokenType::Eof => parser.reduce::<25>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<460> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<461> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<40>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<462> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1014),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<463> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<56>(),
            TokenType::Comma => parser.shift(1023),
            TokenType::Comma => parser.reduce::<56>(),
            TokenType::NamelistCont => parser.goto(1019),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<464> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1053),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<465> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            TokenType::Eof => parser.reduce::<29>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<466> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<4>(),
            TokenType::Elseif => parser.reduce::<4>(),
            TokenType::End => parser.reduce::<4>(),
            TokenType::Return => parser.shift(1073),
            TokenType::BlockRetstat => parser.goto(1016),
            TokenType::Retstat => parser.goto(1018),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<467> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<112>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<468> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<24>(),
            TokenType::Break => parser.reduce::<24>(),
            TokenType::Do => parser.reduce::<24>(),
            TokenType::For => parser.reduce::<24>(),
            TokenType::Function => parser.reduce::<24>(),
            TokenType::Goto => parser.reduce::<24>(),
            TokenType::If => parser.reduce::<24>(),
            TokenType::Local => parser.reduce::<24>(),
            TokenType::Repeat => parser.reduce::<24>(),
            TokenType::Return => parser.reduce::<24>(),
            TokenType::Until => parser.reduce::<24>(),
            TokenType::While => parser.reduce::<24>(),
            TokenType::LParen => parser.reduce::<24>(),
            TokenType::DoubleColon => parser.reduce::<24>(),
            TokenType::SemiColon => parser.reduce::<24>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<469> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<116>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<470> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<114>(),
            TokenType::Comma => parser.shift(1017),
            TokenType::ParlistCont => parser.goto(1015),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<471> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<34>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<472> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<38>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<473> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(1020),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<474> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1024),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<475> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<24>(),
            TokenType::Break => parser.reduce::<24>(),
            TokenType::Do => parser.reduce::<24>(),
            TokenType::End => parser.reduce::<24>(),
            TokenType::For => parser.reduce::<24>(),
            TokenType::Function => parser.reduce::<24>(),
            TokenType::Goto => parser.reduce::<24>(),
            TokenType::If => parser.reduce::<24>(),
            TokenType::Local => parser.reduce::<24>(),
            TokenType::Repeat => parser.reduce::<24>(),
            TokenType::Return => parser.reduce::<24>(),
            TokenType::While => parser.reduce::<24>(),
            TokenType::LParen => parser.reduce::<24>(),
            TokenType::DoubleColon => parser.reduce::<24>(),
            TokenType::SemiColon => parser.reduce::<24>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<476> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<41>(),
            TokenType::Colon => parser.reduce::<41>(),
            TokenType::Dot => parser.shift(157),
            TokenType::FuncnameCont => parser.goto(1025),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<477> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(473),
            TokenType::Funcbody => parser.goto(1022),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<478> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(1021),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<479> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<26>(),
            TokenType::Break => parser.reduce::<26>(),
            TokenType::Do => parser.reduce::<26>(),
            TokenType::For => parser.reduce::<26>(),
            TokenType::Function => parser.reduce::<26>(),
            TokenType::Goto => parser.reduce::<26>(),
            TokenType::If => parser.reduce::<26>(),
            TokenType::Local => parser.reduce::<26>(),
            TokenType::Repeat => parser.reduce::<26>(),
            TokenType::Return => parser.reduce::<26>(),
            TokenType::Until => parser.reduce::<26>(),
            TokenType::While => parser.reduce::<26>(),
            TokenType::LParen => parser.reduce::<26>(),
            TokenType::DoubleColon => parser.reduce::<26>(),
            TokenType::SemiColon => parser.reduce::<26>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<480> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<102>(),
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::Break => parser.reduce::<102>(),
            TokenType::Do => parser.reduce::<102>(),
            TokenType::For => parser.reduce::<102>(),
            TokenType::Function => parser.reduce::<102>(),
            TokenType::Goto => parser.reduce::<102>(),
            TokenType::If => parser.reduce::<102>(),
            TokenType::Local => parser.reduce::<102>(),
            TokenType::Repeat => parser.reduce::<102>(),
            TokenType::Return => parser.reduce::<102>(),
            TokenType::While => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::DoubleColon => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Eof => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<481> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(478),
            TokenType::Funcbody => parser.goto(1026),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<482> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<26>(),
            TokenType::Break => parser.reduce::<26>(),
            TokenType::Do => parser.reduce::<26>(),
            TokenType::End => parser.reduce::<26>(),
            TokenType::For => parser.reduce::<26>(),
            TokenType::Function => parser.reduce::<26>(),
            TokenType::Goto => parser.reduce::<26>(),
            TokenType::If => parser.reduce::<26>(),
            TokenType::Local => parser.reduce::<26>(),
            TokenType::Repeat => parser.reduce::<26>(),
            TokenType::Return => parser.reduce::<26>(),
            TokenType::While => parser.reduce::<26>(),
            TokenType::LParen => parser.reduce::<26>(),
            TokenType::DoubleColon => parser.reduce::<26>(),
            TokenType::SemiColon => parser.reduce::<26>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<483> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::Until => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(1034),
            TokenType::AttnamelistCont => parser.goto(1027),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<484> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::End => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(1036),
            TokenType::AttnamelistCont => parser.goto(1028),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<485> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(1057),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<486> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<37>(),
            TokenType::SemiColon => parser.shift(1033),
            TokenType::RetstatEnd => parser.goto(1032),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<487> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<37>(),
            TokenType::SemiColon => parser.shift(1030),
            TokenType::RetstatEnd => parser.goto(1029),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<488> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<36>(),
            TokenType::SemiColon => parser.reduce::<36>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<489> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<490> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<36>(),
            TokenType::SemiColon => parser.reduce::<36>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<491> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<101>(),
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::Break => parser.reduce::<101>(),
            TokenType::Do => parser.reduce::<101>(),
            TokenType::For => parser.reduce::<101>(),
            TokenType::Function => parser.reduce::<101>(),
            TokenType::Goto => parser.reduce::<101>(),
            TokenType::If => parser.reduce::<101>(),
            TokenType::Local => parser.reduce::<101>(),
            TokenType::Repeat => parser.reduce::<101>(),
            TokenType::Return => parser.reduce::<101>(),
            TokenType::While => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::DoubleColon => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Eof => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<492> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Until => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<493> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::Or => parser.shift(1286),
            TokenType::Add => parser.shift(1313),
            TokenType::Sub => parser.shift(1321),
            TokenType::Mul => parser.shift(1345),
            TokenType::Div => parser.shift(1352),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Mod => parser.shift(1399),
            TokenType::Pow => parser.shift(1439),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitOr => parser.shift(1490),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::Eq => parser.shift(1522),
            TokenType::Neq => parser.shift(1531),
            TokenType::Leq => parser.shift(1547),
            TokenType::Geq => parser.shift(1567),
            TokenType::Less => parser.shift(1572),
            TokenType::Greater => parser.shift(1577),
            TokenType::Comma => parser.shift(1059),
            TokenType::Concat => parser.shift(1583),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<494> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<495> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<12>(),
            TokenType::Break => parser.reduce::<12>(),
            TokenType::Do => parser.reduce::<12>(),
            TokenType::End => parser.reduce::<12>(),
            TokenType::For => parser.reduce::<12>(),
            TokenType::Function => parser.reduce::<12>(),
            TokenType::Goto => parser.reduce::<12>(),
            TokenType::If => parser.reduce::<12>(),
            TokenType::Local => parser.reduce::<12>(),
            TokenType::Repeat => parser.reduce::<12>(),
            TokenType::Return => parser.reduce::<12>(),
            TokenType::While => parser.reduce::<12>(),
            TokenType::LParen => parser.reduce::<12>(),
            TokenType::DoubleColon => parser.reduce::<12>(),
            TokenType::SemiColon => parser.reduce::<12>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<496> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1031),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<497> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<39>(),
            TokenType::Break => parser.reduce::<39>(),
            TokenType::Do => parser.reduce::<39>(),
            TokenType::For => parser.reduce::<39>(),
            TokenType::Function => parser.reduce::<39>(),
            TokenType::Goto => parser.reduce::<39>(),
            TokenType::If => parser.reduce::<39>(),
            TokenType::Local => parser.reduce::<39>(),
            TokenType::Repeat => parser.reduce::<39>(),
            TokenType::Return => parser.reduce::<39>(),
            TokenType::Until => parser.reduce::<39>(),
            TokenType::While => parser.reduce::<39>(),
            TokenType::LParen => parser.reduce::<39>(),
            TokenType::DoubleColon => parser.reduce::<39>(),
            TokenType::SemiColon => parser.reduce::<39>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<498> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(511),
            TokenType::Do => parser.shift(517),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(532),
            TokenType::Function => parser.shift(533),
            TokenType::Goto => parser.shift(535),
            TokenType::If => parser.shift(551),
            TokenType::Local => parser.shift(615),
            TokenType::Repeat => parser.shift(616),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(618),
            TokenType::LParen => parser.shift(652),
            TokenType::DoubleColon => parser.shift(648),
            TokenType::SemiColon => parser.shift(644),
            TokenType::BlockStat => parser.goto(1058),
            TokenType::Stat => parser.goto(498),
            TokenType::Label => parser.goto(645),
            TokenType::Varlist => parser.goto(646),
            TokenType::Var => parser.goto(650),
            TokenType::Functioncall => parser.goto(647),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<499> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(1270),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<500> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(1265),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<501> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(511),
            TokenType::Do => parser.shift(517),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(532),
            TokenType::Function => parser.shift(533),
            TokenType::Goto => parser.shift(535),
            TokenType::If => parser.shift(551),
            TokenType::Local => parser.shift(615),
            TokenType::Repeat => parser.shift(616),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(618),
            TokenType::LParen => parser.shift(652),
            TokenType::DoubleColon => parser.shift(648),
            TokenType::SemiColon => parser.shift(644),
            TokenType::Block => parser.goto(1195),
            TokenType::BlockStat => parser.goto(466),
            TokenType::Stat => parser.goto(498),
            TokenType::Label => parser.goto(645),
            TokenType::Varlist => parser.goto(646),
            TokenType::Var => parser.goto(650),
            TokenType::Functioncall => parser.goto(647),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<502> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(511),
            TokenType::Do => parser.shift(517),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(532),
            TokenType::Function => parser.shift(533),
            TokenType::Goto => parser.shift(535),
            TokenType::If => parser.shift(551),
            TokenType::Local => parser.shift(615),
            TokenType::Repeat => parser.shift(616),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(618),
            TokenType::LParen => parser.shift(652),
            TokenType::DoubleColon => parser.shift(648),
            TokenType::SemiColon => parser.shift(644),
            TokenType::Block => parser.goto(1208),
            TokenType::BlockStat => parser.goto(466),
            TokenType::Stat => parser.goto(498),
            TokenType::Label => parser.goto(645),
            TokenType::Varlist => parser.goto(646),
            TokenType::Var => parser.goto(650),
            TokenType::Functioncall => parser.goto(647),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<503> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(224),
            TokenType::LParen => parser.shift(225),
            TokenType::LCurly => parser.shift(248),
            TokenType::Args => parser.goto(1035),
            TokenType::Tableconstructor => parser.goto(247),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<504> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<505> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<12>(),
            TokenType::Break => parser.reduce::<12>(),
            TokenType::Do => parser.reduce::<12>(),
            TokenType::For => parser.reduce::<12>(),
            TokenType::Function => parser.reduce::<12>(),
            TokenType::Goto => parser.reduce::<12>(),
            TokenType::If => parser.reduce::<12>(),
            TokenType::Local => parser.reduce::<12>(),
            TokenType::Repeat => parser.reduce::<12>(),
            TokenType::Return => parser.reduce::<12>(),
            TokenType::Until => parser.reduce::<12>(),
            TokenType::While => parser.reduce::<12>(),
            TokenType::LParen => parser.reduce::<12>(),
            TokenType::DoubleColon => parser.reduce::<12>(),
            TokenType::SemiColon => parser.reduce::<12>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<506> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<7>(),
            TokenType::Break => parser.reduce::<7>(),
            TokenType::Do => parser.reduce::<7>(),
            TokenType::For => parser.reduce::<7>(),
            TokenType::Function => parser.reduce::<7>(),
            TokenType::Goto => parser.reduce::<7>(),
            TokenType::If => parser.reduce::<7>(),
            TokenType::Local => parser.reduce::<7>(),
            TokenType::Repeat => parser.reduce::<7>(),
            TokenType::Return => parser.reduce::<7>(),
            TokenType::Until => parser.reduce::<7>(),
            TokenType::While => parser.reduce::<7>(),
            TokenType::LParen => parser.reduce::<7>(),
            TokenType::DoubleColon => parser.reduce::<7>(),
            TokenType::SemiColon => parser.reduce::<7>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<507> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::Until => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<508> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<14>(),
            TokenType::And => parser.shift(1099),
            TokenType::Break => parser.reduce::<14>(),
            TokenType::Do => parser.reduce::<14>(),
            TokenType::For => parser.reduce::<14>(),
            TokenType::Function => parser.reduce::<14>(),
            TokenType::Goto => parser.reduce::<14>(),
            TokenType::If => parser.reduce::<14>(),
            TokenType::Local => parser.reduce::<14>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Repeat => parser.reduce::<14>(),
            TokenType::Return => parser.reduce::<14>(),
            TokenType::While => parser.reduce::<14>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Sub => parser.shift(1383),
            TokenType::Mul => parser.shift(1476),
            TokenType::Div => parser.shift(1503),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Mod => parser.shift(1556),
            TokenType::Pow => parser.shift(1574),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitOr => parser.shift(1604),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::Eq => parser.shift(1611),
            TokenType::Neq => parser.shift(1616),
            TokenType::Leq => parser.shift(1619),
            TokenType::Geq => parser.shift(1622),
            TokenType::Less => parser.shift(1625),
            TokenType::Greater => parser.shift(1628),
            TokenType::LParen => parser.reduce::<14>(),
            TokenType::DoubleColon => parser.reduce::<14>(),
            TokenType::SemiColon => parser.reduce::<14>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Eof => parser.reduce::<14>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<509> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<28>(),
            TokenType::Break => parser.reduce::<28>(),
            TokenType::Do => parser.reduce::<28>(),
            TokenType::For => parser.reduce::<28>(),
            TokenType::Function => parser.reduce::<28>(),
            TokenType::Goto => parser.reduce::<28>(),
            TokenType::If => parser.reduce::<28>(),
            TokenType::Local => parser.reduce::<28>(),
            TokenType::Repeat => parser.reduce::<28>(),
            TokenType::Return => parser.reduce::<28>(),
            TokenType::While => parser.reduce::<28>(),
            TokenType::LParen => parser.reduce::<28>(),
            TokenType::DoubleColon => parser.reduce::<28>(),
            TokenType::SemiColon => parser.reduce::<28>(),
            TokenType::Eof => parser.reduce::<28>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<510> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1037),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<511> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<10>(),
            TokenType::Break => parser.reduce::<10>(),
            TokenType::Do => parser.reduce::<10>(),
            TokenType::Else => parser.reduce::<10>(),
            TokenType::Elseif => parser.reduce::<10>(),
            TokenType::End => parser.reduce::<10>(),
            TokenType::For => parser.reduce::<10>(),
            TokenType::Function => parser.reduce::<10>(),
            TokenType::Goto => parser.reduce::<10>(),
            TokenType::If => parser.reduce::<10>(),
            TokenType::Local => parser.reduce::<10>(),
            TokenType::Repeat => parser.reduce::<10>(),
            TokenType::Return => parser.reduce::<10>(),
            TokenType::While => parser.reduce::<10>(),
            TokenType::LParen => parser.reduce::<10>(),
            TokenType::DoubleColon => parser.reduce::<10>(),
            TokenType::SemiColon => parser.reduce::<10>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<512> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<7>(),
            TokenType::Break => parser.reduce::<7>(),
            TokenType::Do => parser.reduce::<7>(),
            TokenType::End => parser.reduce::<7>(),
            TokenType::For => parser.reduce::<7>(),
            TokenType::Function => parser.reduce::<7>(),
            TokenType::Goto => parser.reduce::<7>(),
            TokenType::If => parser.reduce::<7>(),
            TokenType::Local => parser.reduce::<7>(),
            TokenType::Repeat => parser.reduce::<7>(),
            TokenType::Return => parser.reduce::<7>(),
            TokenType::While => parser.reduce::<7>(),
            TokenType::LParen => parser.reduce::<7>(),
            TokenType::DoubleColon => parser.reduce::<7>(),
            TokenType::SemiColon => parser.reduce::<7>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<513> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<514> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1040),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<515> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1251),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<516> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Explist => parser.goto(1038),
            TokenType::Exp => parser.goto(710),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<517> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(1190),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<518> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Explist => parser.goto(1039),
            TokenType::Exp => parser.goto(710),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<519> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            TokenType::Eof => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<520> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1046),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<521> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1433),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<522> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(1263),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<523> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(1253),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<524> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Explist => parser.goto(1041),
            TokenType::Exp => parser.goto(757),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<525> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1052),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<526> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(1256),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<527> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1047),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<528> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<39>(),
            TokenType::Break => parser.reduce::<39>(),
            TokenType::Do => parser.reduce::<39>(),
            TokenType::End => parser.reduce::<39>(),
            TokenType::For => parser.reduce::<39>(),
            TokenType::Function => parser.reduce::<39>(),
            TokenType::Goto => parser.reduce::<39>(),
            TokenType::If => parser.reduce::<39>(),
            TokenType::Local => parser.reduce::<39>(),
            TokenType::Repeat => parser.reduce::<39>(),
            TokenType::Return => parser.reduce::<39>(),
            TokenType::While => parser.reduce::<39>(),
            TokenType::LParen => parser.reduce::<39>(),
            TokenType::DoubleColon => parser.reduce::<39>(),
            TokenType::SemiColon => parser.reduce::<39>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<529> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1048),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<530> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(1252),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<531> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Explist => parser.goto(1042),
            TokenType::Exp => parser.goto(771),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<532> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1043),
            TokenType::Namelist => parser.goto(1044),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<533> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(34),
            TokenType::Funcname => parser.goto(1045),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<534> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(1257),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<535> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1070),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<536> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(240),
            TokenType::LParen => parser.shift(241),
            TokenType::LCurly => parser.shift(270),
            TokenType::Args => parser.goto(1051),
            TokenType::Tableconstructor => parser.goto(268),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<537> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(1222),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<538> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Then => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<539> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(266),
            TokenType::LParen => parser.shift(267),
            TokenType::LCurly => parser.shift(284),
            TokenType::Args => parser.goto(1055),
            TokenType::Tableconstructor => parser.goto(283),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<540> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Then => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<541> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(253),
            TokenType::LParen => parser.shift(258),
            TokenType::LCurly => parser.shift(286),
            TokenType::Args => parser.goto(1049),
            TokenType::Tableconstructor => parser.goto(285),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<542> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(1060),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<543> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1065),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<544> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<545> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<546> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(1056),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<547> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(1491),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<548> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(253),
            TokenType::LParen => parser.shift(258),
            TokenType::LCurly => parser.shift(286),
            TokenType::Args => parser.goto(1050),
            TokenType::Tableconstructor => parser.goto(285),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<549> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<56>(),
            TokenType::Comma => parser.shift(235),
            TokenType::NamelistCont => parser.goto(1069),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<550> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(224),
            TokenType::LParen => parser.shift(225),
            TokenType::LCurly => parser.shift(248),
            TokenType::Args => parser.goto(1054),
            TokenType::Tableconstructor => parser.goto(247),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<551> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(1071),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<552> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(1250),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<553> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(262),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.shift(269),
            TokenType::LSquare => parser.shift(1068),
            TokenType::LCurly => parser.shift(288),
            TokenType::Colon => parser.shift(1225),
            TokenType::Dot => parser.shift(1224),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(1226),
            TokenType::Tableconstructor => parser.goto(287),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<554> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Do => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<555> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::RParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<556> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1066),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<557> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1067),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<558> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<100>(),
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::Break => parser.reduce::<100>(),
            TokenType::Do => parser.reduce::<100>(),
            TokenType::For => parser.reduce::<100>(),
            TokenType::Function => parser.reduce::<100>(),
            TokenType::Goto => parser.reduce::<100>(),
            TokenType::If => parser.reduce::<100>(),
            TokenType::Local => parser.reduce::<100>(),
            TokenType::Repeat => parser.reduce::<100>(),
            TokenType::Return => parser.reduce::<100>(),
            TokenType::While => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::DoubleColon => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Eof => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<559> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(224),
            TokenType::LParen => parser.shift(225),
            TokenType::LSquare => parser.shift(515),
            TokenType::LCurly => parser.shift(248),
            TokenType::Colon => parser.shift(1183),
            TokenType::Dot => parser.shift(556),
            TokenType::Args => parser.goto(1185),
            TokenType::Tableconstructor => parser.goto(247),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<560> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(266),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.shift(267),
            TokenType::RParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.shift(1106),
            TokenType::LCurly => parser.shift(284),
            TokenType::Colon => parser.shift(1237),
            TokenType::Dot => parser.shift(1229),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(1238),
            TokenType::Tableconstructor => parser.goto(283),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<561> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(253),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Then => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.shift(258),
            TokenType::LSquare => parser.shift(1084),
            TokenType::LCurly => parser.shift(286),
            TokenType::Colon => parser.shift(1209),
            TokenType::Dot => parser.shift(1207),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(1210),
            TokenType::Tableconstructor => parser.goto(285),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<562> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(262),
            TokenType::LParen => parser.shift(269),
            TokenType::LCurly => parser.shift(288),
            TokenType::Args => parser.goto(1064),
            TokenType::Tableconstructor => parser.goto(287),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<563> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(266),
            TokenType::LParen => parser.shift(267),
            TokenType::LCurly => parser.shift(284),
            TokenType::Args => parser.goto(1062),
            TokenType::Tableconstructor => parser.goto(283),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<564> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::RCurly => parser.reduce::<109>(),
            TokenType::SemiColon => parser.reduce::<109>(),
            TokenType::Comma => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<565> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(240),
            TokenType::LParen => parser.shift(241),
            TokenType::LSquare => parser.shift(515),
            TokenType::LCurly => parser.shift(270),
            TokenType::Colon => parser.shift(1193),
            TokenType::Dot => parser.shift(556),
            TokenType::Args => parser.goto(1194),
            TokenType::Tableconstructor => parser.goto(268),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<566> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1302),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<567> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(1086),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<568> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Eof => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<569> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(240),
            TokenType::LParen => parser.shift(241),
            TokenType::LCurly => parser.shift(270),
            TokenType::Args => parser.goto(1079),
            TokenType::Tableconstructor => parser.goto(268),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<570> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<571> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Eof => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<572> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(262),
            TokenType::LParen => parser.shift(269),
            TokenType::LCurly => parser.shift(288),
            TokenType::Args => parser.goto(1061),
            TokenType::Tableconstructor => parser.goto(287),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<573> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<574> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1306),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<575> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1510),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<576> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<577> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1435),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<578> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::Assign => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<579> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1305),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<580> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1297),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<581> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1307),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<582> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<104>(),
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::Break => parser.reduce::<104>(),
            TokenType::Do => parser.reduce::<104>(),
            TokenType::For => parser.reduce::<104>(),
            TokenType::Function => parser.reduce::<104>(),
            TokenType::Goto => parser.reduce::<104>(),
            TokenType::If => parser.reduce::<104>(),
            TokenType::Local => parser.reduce::<104>(),
            TokenType::Repeat => parser.reduce::<104>(),
            TokenType::Return => parser.reduce::<104>(),
            TokenType::While => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::DoubleColon => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Eof => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<583> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1393),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<584> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::RSquare => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<585> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(1072),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<586> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<120>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<587> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::RParen => parser.reduce::<109>(),
            TokenType::Comma => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<588> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Do => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<589> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::RCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<590> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::RParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<591> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1290),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<592> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(1075),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<593> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1074),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<594> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<595> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::Assign => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<596> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1423),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<597> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<123>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::Field => parser.goto(1497),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<598> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1296),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<599> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1314),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<600> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1303),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<601> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1291),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<602> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<128>(),
            TokenType::String(_) => parser.reduce::<128>(),
            TokenType::Integer(_) => parser.reduce::<128>(),
            TokenType::Float(_) => parser.reduce::<128>(),
            TokenType::False => parser.reduce::<128>(),
            TokenType::Function => parser.reduce::<128>(),
            TokenType::Nil => parser.reduce::<128>(),
            TokenType::Not => parser.reduce::<128>(),
            TokenType::True => parser.reduce::<128>(),
            TokenType::Sub => parser.reduce::<128>(),
            TokenType::Len => parser.reduce::<128>(),
            TokenType::BitXor => parser.reduce::<128>(),
            TokenType::LParen => parser.reduce::<128>(),
            TokenType::LSquare => parser.reduce::<128>(),
            TokenType::LCurly => parser.reduce::<128>(),
            TokenType::RCurly => parser.reduce::<128>(),
            TokenType::Dots => parser.reduce::<128>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<603> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<127>(),
            TokenType::String(_) => parser.reduce::<127>(),
            TokenType::Integer(_) => parser.reduce::<127>(),
            TokenType::Float(_) => parser.reduce::<127>(),
            TokenType::False => parser.reduce::<127>(),
            TokenType::Function => parser.reduce::<127>(),
            TokenType::Nil => parser.reduce::<127>(),
            TokenType::Not => parser.reduce::<127>(),
            TokenType::True => parser.reduce::<127>(),
            TokenType::Sub => parser.reduce::<127>(),
            TokenType::Len => parser.reduce::<127>(),
            TokenType::BitXor => parser.reduce::<127>(),
            TokenType::LParen => parser.reduce::<127>(),
            TokenType::LSquare => parser.reduce::<127>(),
            TokenType::LCurly => parser.reduce::<127>(),
            TokenType::RCurly => parser.reduce::<127>(),
            TokenType::Dots => parser.reduce::<127>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<604> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1456),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<605> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Eof => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<606> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::RParen => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<607> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::SemiColon => parser.reduce::<109>(),
            TokenType::Comma => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            TokenType::Eof => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<608> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<16>(),
            TokenType::Elseif => parser.shift(1147),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatElseif => parser.goto(1077),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<609> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<109>(),
            TokenType::And => parser.reduce::<109>(),
            TokenType::Break => parser.reduce::<109>(),
            TokenType::Do => parser.reduce::<109>(),
            TokenType::For => parser.reduce::<109>(),
            TokenType::Function => parser.reduce::<109>(),
            TokenType::Goto => parser.reduce::<109>(),
            TokenType::If => parser.reduce::<109>(),
            TokenType::Local => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Repeat => parser.reduce::<109>(),
            TokenType::Return => parser.reduce::<109>(),
            TokenType::While => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::LParen => parser.reduce::<109>(),
            TokenType::DoubleColon => parser.reduce::<109>(),
            TokenType::SemiColon => parser.reduce::<109>(),
            TokenType::Comma => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            TokenType::Eof => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<610> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(1082),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<611> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1300),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<612> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(1140),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<613> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1301),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<614> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Then => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<615> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1136),
            TokenType::Function => parser.shift(1080),
            TokenType::Attnamelist => parser.goto(1135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<616> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(44),
            TokenType::Do => parser.shift(47),
            TokenType::For => parser.shift(55),
            TokenType::Function => parser.shift(58),
            TokenType::Goto => parser.shift(60),
            TokenType::If => parser.shift(62),
            TokenType::Local => parser.shift(72),
            TokenType::Repeat => parser.shift(73),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(77),
            TokenType::LParen => parser.shift(87),
            TokenType::DoubleColon => parser.shift(84),
            TokenType::SemiColon => parser.shift(80),
            TokenType::Block => parser.goto(1217),
            TokenType::BlockStat => parser.goto(28),
            TokenType::Stat => parser.goto(40),
            TokenType::Label => parser.goto(81),
            TokenType::Varlist => parser.goto(82),
            TokenType::Var => parser.goto(85),
            TokenType::Functioncall => parser.goto(83),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<617> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1328),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<618> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(1087),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<619> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<620> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1115),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<621> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::RParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Comma => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<622> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::RParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Comma => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<623> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(1139),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<624> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1081),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<625> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1110),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<626> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Comma => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            TokenType::Eof => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<627> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(1494),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<628> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Comma => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            TokenType::Eof => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<629> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(1487),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<630> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1078),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<631> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1102),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<632> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::RCurly => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Comma => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<633> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::RCurly => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Comma => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<634> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(1111),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<635> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(1492),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<636> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(1148),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<637> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(1094),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<638> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1386),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<639> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1368),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<640> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1090),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<641> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1096),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<642> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Comma => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            TokenType::Eof => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<643> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(1105),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<644> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<6>(),
            TokenType::Break => parser.reduce::<6>(),
            TokenType::Do => parser.reduce::<6>(),
            TokenType::Else => parser.reduce::<6>(),
            TokenType::Elseif => parser.reduce::<6>(),
            TokenType::End => parser.reduce::<6>(),
            TokenType::For => parser.reduce::<6>(),
            TokenType::Function => parser.reduce::<6>(),
            TokenType::Goto => parser.reduce::<6>(),
            TokenType::If => parser.reduce::<6>(),
            TokenType::Local => parser.reduce::<6>(),
            TokenType::Repeat => parser.reduce::<6>(),
            TokenType::Return => parser.reduce::<6>(),
            TokenType::While => parser.reduce::<6>(),
            TokenType::LParen => parser.reduce::<6>(),
            TokenType::DoubleColon => parser.reduce::<6>(),
            TokenType::SemiColon => parser.reduce::<6>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<645> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<9>(),
            TokenType::Break => parser.reduce::<9>(),
            TokenType::Do => parser.reduce::<9>(),
            TokenType::Else => parser.reduce::<9>(),
            TokenType::Elseif => parser.reduce::<9>(),
            TokenType::End => parser.reduce::<9>(),
            TokenType::For => parser.reduce::<9>(),
            TokenType::Function => parser.reduce::<9>(),
            TokenType::Goto => parser.reduce::<9>(),
            TokenType::If => parser.reduce::<9>(),
            TokenType::Local => parser.reduce::<9>(),
            TokenType::Repeat => parser.reduce::<9>(),
            TokenType::Return => parser.reduce::<9>(),
            TokenType::While => parser.reduce::<9>(),
            TokenType::LParen => parser.reduce::<9>(),
            TokenType::DoubleColon => parser.reduce::<9>(),
            TokenType::SemiColon => parser.reduce::<9>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<646> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(1113),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<647> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<8>(),
            TokenType::String(_) => parser.shift(1159),
            TokenType::Break => parser.reduce::<8>(),
            TokenType::Do => parser.reduce::<8>(),
            TokenType::Else => parser.reduce::<8>(),
            TokenType::Elseif => parser.reduce::<8>(),
            TokenType::End => parser.reduce::<8>(),
            TokenType::For => parser.reduce::<8>(),
            TokenType::Function => parser.reduce::<8>(),
            TokenType::Goto => parser.reduce::<8>(),
            TokenType::If => parser.reduce::<8>(),
            TokenType::Local => parser.reduce::<8>(),
            TokenType::Repeat => parser.reduce::<8>(),
            TokenType::Return => parser.reduce::<8>(),
            TokenType::While => parser.reduce::<8>(),
            // Shift(1188)-Reduce(8)
            TokenType::LParen => parser.shift(1188),
            TokenType::LSquare => parser.shift(52),
            TokenType::LCurly => parser.shift(1239),
            TokenType::DoubleColon => parser.reduce::<8>(),
            TokenType::SemiColon => parser.reduce::<8>(),
            TokenType::Colon => parser.shift(1191),
            TokenType::Dot => parser.shift(68),
            TokenType::Args => parser.goto(1192),
            TokenType::Tableconstructor => parser.goto(1231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<648> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<649> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1138),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<650> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1159),
            TokenType::Assign => parser.reduce::<46>(),
            TokenType::LParen => parser.shift(1188),
            TokenType::LSquare => parser.shift(48),
            TokenType::LCurly => parser.shift(1239),
            TokenType::Colon => parser.shift(1157),
            TokenType::Comma => parser.shift(36),
            TokenType::Dot => parser.shift(64),
            TokenType::VarlistCont => parser.goto(33),
            TokenType::Args => parser.goto(1158),
            TokenType::Tableconstructor => parser.goto(1231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<651> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(1116),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<652> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(1255),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<653> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1122),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<654> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1097),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<655> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::RSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<656> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::RSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<657> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1124),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<658> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1091),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<659> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::RSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<660> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(1498),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<661> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1098),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<662> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1114),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<663> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::RParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Comma => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<664> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1089),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<665> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1107),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<666> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::RCurly => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Comma => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<667> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1152),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<668> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1411),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<669> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1540),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<670> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1448),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<671> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::RParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Comma => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<672> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1142),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<673> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1103),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<674> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<99>(),
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Break => parser.reduce::<99>(),
            TokenType::Do => parser.reduce::<99>(),
            TokenType::For => parser.reduce::<99>(),
            TokenType::Function => parser.reduce::<99>(),
            TokenType::Goto => parser.reduce::<99>(),
            TokenType::If => parser.reduce::<99>(),
            TokenType::Local => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Repeat => parser.reduce::<99>(),
            TokenType::Return => parser.reduce::<99>(),
            TokenType::While => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::DoubleColon => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Comma => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            TokenType::Eof => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<675> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<108>(),
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Break => parser.reduce::<108>(),
            TokenType::Do => parser.reduce::<108>(),
            TokenType::For => parser.reduce::<108>(),
            TokenType::Function => parser.reduce::<108>(),
            TokenType::Goto => parser.reduce::<108>(),
            TokenType::If => parser.reduce::<108>(),
            TokenType::Local => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Repeat => parser.reduce::<108>(),
            TokenType::Return => parser.reduce::<108>(),
            TokenType::While => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::DoubleColon => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Comma => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            TokenType::Eof => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<676> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(1486),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<677> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1512),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<678> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1088),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<679> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1104),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<680> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<98>(),
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Break => parser.reduce::<98>(),
            TokenType::Do => parser.reduce::<98>(),
            TokenType::For => parser.reduce::<98>(),
            TokenType::Function => parser.reduce::<98>(),
            TokenType::Goto => parser.reduce::<98>(),
            TokenType::If => parser.reduce::<98>(),
            TokenType::Local => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Repeat => parser.reduce::<98>(),
            TokenType::Return => parser.reduce::<98>(),
            TokenType::While => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::DoubleColon => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Comma => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            TokenType::Eof => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<681> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::RSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<682> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1506),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<683> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1083),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<684> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Comma => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            TokenType::Eof => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<685> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::RCurly => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Comma => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<686> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1507),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<687> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1484),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<688> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1093),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<689> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1134),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<690> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1092),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<691> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1389),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<692> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1241),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Until => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.shift(1248),
            TokenType::LSquare => parser.shift(1130),
            TokenType::LCurly => parser.shift(1294),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.shift(1246),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.shift(1245),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(1247),
            TokenType::Tableconstructor => parser.goto(1293),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<693> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1204),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.shift(1206),
            TokenType::LSquare => parser.shift(1123),
            TokenType::LCurly => parser.shift(1285),
            TokenType::Colon => parser.shift(1198),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.shift(1197),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(1203),
            TokenType::Tableconstructor => parser.goto(1284),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<694> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1417),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<695> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1221),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.shift(1223),
            TokenType::LSquare => parser.shift(1117),
            TokenType::LCurly => parser.shift(1288),
            TokenType::Colon => parser.shift(1228),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.shift(1227),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(1233),
            TokenType::Tableconstructor => parser.goto(1287),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<696> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1241),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Until => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.shift(1248),
            TokenType::LSquare => parser.shift(1118),
            TokenType::LCurly => parser.shift(1294),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.shift(1236),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.shift(1232),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(1240),
            TokenType::Tableconstructor => parser.goto(1293),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<697> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1204),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.shift(1206),
            TokenType::LSquare => parser.shift(1141),
            TokenType::LCurly => parser.shift(1285),
            TokenType::Colon => parser.shift(1234),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.shift(1230),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(1235),
            TokenType::Tableconstructor => parser.goto(1284),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<698> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1221),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.shift(1223),
            TokenType::LSquare => parser.shift(1129),
            TokenType::LCurly => parser.shift(1288),
            TokenType::Colon => parser.shift(1219),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.shift(1216),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(1220),
            TokenType::Tableconstructor => parser.goto(1287),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<699> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::Or => parser.shift(1259),
            TokenType::Until => parser.reduce::<59>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Sub => parser.shift(1327),
            TokenType::Mul => parser.shift(1347),
            TokenType::Div => parser.shift(1358),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Mod => parser.shift(1458),
            TokenType::Pow => parser.shift(1477),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitOr => parser.shift(1518),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::Eq => parser.shift(1568),
            TokenType::Neq => parser.shift(1573),
            TokenType::Leq => parser.shift(1578),
            TokenType::Geq => parser.shift(1581),
            TokenType::Less => parser.shift(1590),
            TokenType::Greater => parser.shift(1595),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(1145),
            TokenType::Concat => parser.shift(1598),
            TokenType::ExplistCont => parser.goto(1100),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<700> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Until => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<701> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Until => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<702> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Until => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<703> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Until => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<704> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Until => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<705> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<706> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<707> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<708> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<709> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<710> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Add => parser.shift(1299),
            TokenType::Sub => parser.shift(1316),
            TokenType::Mul => parser.shift(1342),
            TokenType::Div => parser.shift(1351),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Mod => parser.shift(1402),
            TokenType::Pow => parser.shift(1460),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitOr => parser.shift(1500),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::Eq => parser.shift(1534),
            TokenType::Neq => parser.shift(1557),
            TokenType::Leq => parser.shift(1569),
            TokenType::Geq => parser.shift(1575),
            TokenType::Less => parser.shift(1582),
            TokenType::Greater => parser.shift(1589),
            TokenType::Comma => parser.shift(1154),
            TokenType::Concat => parser.shift(1596),
            TokenType::ExplistCont => parser.goto(1133),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<711> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<712> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<713> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<714> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<715> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<716> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1333),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<717> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1315),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<718> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1319),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<719> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1214),
            TokenType::And => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.shift(1218),
            TokenType::LSquare => parser.shift(1156),
            TokenType::LCurly => parser.shift(1279),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.shift(1243),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.shift(1242),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(1244),
            TokenType::Tableconstructor => parser.goto(1277),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<720> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1214),
            TokenType::And => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.shift(1218),
            TokenType::LSquare => parser.shift(1128),
            TokenType::LCurly => parser.shift(1279),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.shift(1212),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.shift(1211),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(1213),
            TokenType::Tableconstructor => parser.goto(1277),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<721> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1101),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<722> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::End => parser.reduce::<59>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Add => parser.shift(1283),
            TokenType::Sub => parser.shift(1311),
            TokenType::Mul => parser.shift(1331),
            TokenType::Div => parser.shift(1348),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Mod => parser.shift(1395),
            TokenType::Pow => parser.shift(1447),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitOr => parser.shift(1501),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::Eq => parser.shift(1539),
            TokenType::Neq => parser.shift(1563),
            TokenType::Leq => parser.shift(1570),
            TokenType::Geq => parser.shift(1576),
            TokenType::Less => parser.shift(1580),
            TokenType::Greater => parser.shift(1594),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(1121),
            TokenType::Concat => parser.shift(1597),
            TokenType::ExplistCont => parser.goto(1095),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<723> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<724> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<725> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<726> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<727> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<728> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1428),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<729> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1335),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<730> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<107>(),
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Break => parser.reduce::<107>(),
            TokenType::Do => parser.reduce::<107>(),
            TokenType::For => parser.reduce::<107>(),
            TokenType::Function => parser.reduce::<107>(),
            TokenType::Goto => parser.reduce::<107>(),
            TokenType::If => parser.reduce::<107>(),
            TokenType::Local => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Repeat => parser.reduce::<107>(),
            TokenType::Return => parser.reduce::<107>(),
            TokenType::While => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::DoubleColon => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Comma => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            TokenType::Eof => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<731> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1514),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<732> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1438),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<733> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1381),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<734> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1373),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<735> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<736> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1346),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<737> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::RSquare => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<738> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<739> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1332),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<740> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.shift(1262),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            // Shift(1264)-Reduce(69)
            TokenType::LParen => parser.shift(1264),
            TokenType::LSquare => parser.shift(1109),
            TokenType::LCurly => parser.shift(1309),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.shift(1260),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.shift(1258),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(1261),
            TokenType::Tableconstructor => parser.goto(1308),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<741> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Until => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<742> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.shift(1202),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            // Shift(1205)-Reduce(69)
            TokenType::LParen => parser.shift(1205),
            TokenType::LSquare => parser.shift(1155),
            TokenType::LCurly => parser.shift(1292),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.shift(1281),
            TokenType::Dot => parser.shift(1280),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Eof => parser.reduce::<69>(),
            TokenType::Args => parser.goto(1282),
            TokenType::Tableconstructor => parser.goto(1289),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<743> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1350),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<744> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(897),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::RCurly => parser.reduce::<93>(),
            TokenType::SemiColon => parser.reduce::<93>(),
            TokenType::Comma => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<745> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<746> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.shift(1262),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            // Shift(1264)-Reduce(70)
            TokenType::LParen => parser.shift(1264),
            TokenType::LSquare => parser.shift(1120),
            TokenType::LCurly => parser.shift(1309),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.shift(1273),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.shift(1272),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(1274),
            TokenType::Tableconstructor => parser.goto(1308),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<747> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1349),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<748> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(874),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::RParen => parser.reduce::<93>(),
            TokenType::Comma => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<749> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.shift(1202),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            // Shift(1205)-Reduce(70)
            TokenType::LParen => parser.shift(1205),
            TokenType::LSquare => parser.shift(1125),
            TokenType::LCurly => parser.shift(1292),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.shift(1200),
            TokenType::Dot => parser.shift(1196),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Eof => parser.reduce::<70>(),
            TokenType::Args => parser.goto(1201),
            TokenType::Tableconstructor => parser.goto(1289),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<750> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Eof => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<751> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Eof => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<752> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            TokenType::Eof => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<753> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            TokenType::Eof => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<754> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            TokenType::Eof => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<755> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1416),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<756> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(1370),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<757> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.shift(1189),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Sub => parser.shift(1398),
            TokenType::Mul => parser.shift(1478),
            TokenType::Div => parser.shift(1515),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Mod => parser.shift(1571),
            TokenType::Pow => parser.shift(1588),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitOr => parser.shift(1605),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::Eq => parser.shift(1615),
            TokenType::Neq => parser.shift(1618),
            TokenType::Leq => parser.shift(1621),
            TokenType::Geq => parser.shift(1624),
            TokenType::Less => parser.shift(1627),
            TokenType::Greater => parser.shift(1630),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(1126),
            TokenType::Concat => parser.shift(1633),
            TokenType::ExplistCont => parser.goto(1112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<758> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1392),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<759> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.shift(1269),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::Until => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            // Shift(1278)-Reduce(69)
            TokenType::LParen => parser.shift(1278),
            TokenType::LSquare => parser.shift(1119),
            TokenType::LCurly => parser.shift(1312),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.shift(1275),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.shift(1271),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(1276),
            TokenType::Tableconstructor => parser.goto(1310),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<760> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<761> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<762> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<763> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1355),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<764> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<765> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<766> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1434),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<767> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(1361),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<768> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(903),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::SemiColon => parser.reduce::<93>(),
            TokenType::Comma => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            TokenType::Eof => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<769> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.shift(1269),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::Until => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            // Shift(1278)-Reduce(70)
            TokenType::LParen => parser.shift(1278),
            TokenType::LSquare => parser.shift(1127),
            TokenType::LCurly => parser.shift(1312),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.shift(1267),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.shift(1266),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(1268),
            TokenType::Tableconstructor => parser.goto(1310),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<770> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1562),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<771> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.shift(1249),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::Until => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Sub => parser.shift(1470),
            TokenType::Mul => parser.shift(1489),
            TokenType::Div => parser.shift(1521),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Mod => parser.shift(1579),
            TokenType::Pow => parser.shift(1592),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitOr => parser.shift(1606),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::Eq => parser.shift(1614),
            TokenType::Neq => parser.shift(1617),
            TokenType::Leq => parser.shift(1620),
            TokenType::Geq => parser.shift(1623),
            TokenType::Less => parser.shift(1626),
            TokenType::Greater => parser.shift(1629),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(1175),
            TokenType::Concat => parser.shift(1631),
            TokenType::ExplistCont => parser.goto(1143),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<772> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1357),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<773> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::Until => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<774> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::Until => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<775> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::Until => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<776> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::Until => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<777> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::Until => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<778> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::RSquare => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<779> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(1378),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<780> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1356),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<781> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1353),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<782> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(874),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::RParen => parser.reduce::<95>(),
            TokenType::Comma => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<783> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1380),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<784> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1429),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<785> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::RSquare => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<786> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1422),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<787> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1354),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<788> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1446),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<789> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1396),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<790> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(897),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::RCurly => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Comma => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<791> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(903),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Comma => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            TokenType::Eof => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<792> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1363),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<793> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1421),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<794> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(874),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::RParen => parser.reduce::<94>(),
            TokenType::Comma => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<795> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1359),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<796> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1379),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<797> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1390),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<798> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<799> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1437),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<800> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<801> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(903),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::SemiColon => parser.reduce::<94>(),
            TokenType::Comma => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            TokenType::Eof => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<802> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1444),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<803> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1376),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<804> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Do => parser.reduce::<91>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<805> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::RParen => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<806> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<807> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::RSquare => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<808> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            TokenType::Eof => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<809> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1374),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<810> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1384),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<811> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Then => parser.reduce::<97>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<812> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(1468),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<813> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Do => parser.reduce::<97>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<814> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Then => parser.reduce::<81>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<815> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Then => parser.reduce::<80>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<816> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Then => parser.reduce::<73>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<817> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1591),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<818> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::RParen => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<819> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Then => parser.reduce::<75>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<820> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Then => parser.reduce::<84>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<821> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::RParen => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<822> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Div => parser.shift(362),
            TokenType::Idiv => parser.shift(373),
            TokenType::Mod => parser.shift(383),
            TokenType::Pow => parser.shift(389),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<823> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Then => parser.reduce::<90>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<824> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<825> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(897),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::RCurly => parser.reduce::<94>(),
            TokenType::SemiColon => parser.reduce::<94>(),
            TokenType::Comma => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<826> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::RParen => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<827> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(874),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::RParen => parser.reduce::<96>(),
            TokenType::Comma => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<828> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Do => parser.reduce::<83>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<829> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Then => parser.reduce::<83>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<830> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Do => parser.reduce::<85>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<831> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1546),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<832> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<833> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Then => parser.reduce::<78>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<834> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Then => parser.reduce::<74>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<835> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::RParen => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<836> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Then => parser.reduce::<85>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<837> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(897),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::RCurly => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Comma => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<838> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1419),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<839> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<840> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Do => parser.reduce::<75>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<841> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(1472),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<842> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Then => parser.reduce::<86>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<843> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<844> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Div => parser.shift(362),
            TokenType::Idiv => parser.shift(373),
            TokenType::Mod => parser.shift(383),
            TokenType::Pow => parser.shift(389),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<845> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Do => parser.reduce::<90>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<846> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<847> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Then => parser.reduce::<79>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<848> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<849> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<93>(),
            TokenType::And => parser.reduce::<93>(),
            TokenType::Break => parser.reduce::<93>(),
            TokenType::Do => parser.reduce::<93>(),
            TokenType::For => parser.reduce::<93>(),
            TokenType::Function => parser.reduce::<93>(),
            TokenType::Goto => parser.reduce::<93>(),
            TokenType::If => parser.reduce::<93>(),
            TokenType::Local => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Repeat => parser.reduce::<93>(),
            TokenType::Return => parser.reduce::<93>(),
            TokenType::While => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::LParen => parser.reduce::<93>(),
            TokenType::DoubleColon => parser.reduce::<93>(),
            TokenType::SemiColon => parser.reduce::<93>(),
            TokenType::Comma => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            TokenType::Eof => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<850> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::Until => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<851> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Then => parser.reduce::<76>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<852> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1452),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<853> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Then => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Div => parser.shift(365),
            TokenType::Idiv => parser.shift(370),
            TokenType::Mod => parser.shift(376),
            TokenType::Pow => parser.shift(385),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<854> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Do => parser.reduce::<92>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<855> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Then => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Div => parser.shift(365),
            TokenType::Idiv => parser.shift(370),
            TokenType::Mod => parser.shift(376),
            TokenType::Pow => parser.shift(385),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<856> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Do => parser.reduce::<84>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<857> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::RParen => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<858> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(1475),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<859> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::RParen => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<860> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Then => parser.reduce::<92>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<861> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<862> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::RParen => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<863> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::RParen => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<864> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1382),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<865> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Then => parser.reduce::<91>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<866> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::RParen => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<867> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Do => parser.reduce::<81>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<868> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<869> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(903),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Comma => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            TokenType::Eof => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<870> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::RParen => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<871> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Do => parser.reduce::<82>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<872> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Then => parser.reduce::<89>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<873> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::RParen => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<874> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1425),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<875> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::RParen => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<876> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Do => parser.reduce::<86>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<877> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<878> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::RParen => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<879> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<880> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Then => parser.reduce::<82>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<881> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::RParen => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<882> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::RParen => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<883> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Do => parser.reduce::<89>(),
            TokenType::Or => parser.shift(257),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Add => parser.shift(290),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(329),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(352),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(362),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(373),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(383),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(389),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(417),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(432),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(437),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(440),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(444),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(450),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(452),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(454),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(455),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<884> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<885> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.shift(281),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Then => parser.reduce::<77>(),
            TokenType::Add => parser.shift(328),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(337),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(356),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(365),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(370),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(376),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(385),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(402),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(418),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(424),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(428),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(433),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(436),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(439),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(443),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(448),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<886> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Until => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<887> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Or => parser.shift(280),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Add => parser.shift(294),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(349),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(364),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(375),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(386),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(391),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(396),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(419),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(431),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(434),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(438),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(441),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(445),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(449),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(451),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::RParen => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(453),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<888> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<889> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<890> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1462),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<891> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1465),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<892> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<893> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<894> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1385),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<895> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::End => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<896> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1414),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<897> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1404),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<898> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(1483),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<899> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Until => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<900> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Until => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<901> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<902> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<903> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1415),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<904> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1387),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<905> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1418),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<906> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(1505),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<907> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(1493),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<908> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<95>(),
            TokenType::And => parser.reduce::<95>(),
            TokenType::Break => parser.reduce::<95>(),
            TokenType::Do => parser.reduce::<95>(),
            TokenType::For => parser.reduce::<95>(),
            TokenType::Function => parser.reduce::<95>(),
            TokenType::Goto => parser.reduce::<95>(),
            TokenType::If => parser.reduce::<95>(),
            TokenType::Local => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Repeat => parser.reduce::<95>(),
            TokenType::Return => parser.reduce::<95>(),
            TokenType::While => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::LParen => parser.reduce::<95>(),
            TokenType::DoubleColon => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Comma => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            TokenType::Eof => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<909> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1548),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<910> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1455),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<911> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1146),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<912> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1149),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<913> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1441),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<914> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1150),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<915> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1403),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<916> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1372),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<917> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1151),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<918> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1162),
            TokenType::Funcbody => parser.goto(1160),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<919> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1499),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<920> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1153),
            TokenType::Funcbody => parser.goto(1144),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<921> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1513),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<922> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1176),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<923> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1431),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<924> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1163),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<925> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1427),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<926> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1167),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<927> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1430),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<928> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1371),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<929> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1173),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<930> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1166),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<931> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1182),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<932> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1453),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<933> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1181),
            TokenType::Funcbody => parser.goto(1174),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<934> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1161),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<935> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1511),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<936> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1413),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<937> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<94>(),
            TokenType::And => parser.reduce::<94>(),
            TokenType::Break => parser.reduce::<94>(),
            TokenType::Do => parser.reduce::<94>(),
            TokenType::For => parser.reduce::<94>(),
            TokenType::Function => parser.reduce::<94>(),
            TokenType::Goto => parser.reduce::<94>(),
            TokenType::If => parser.reduce::<94>(),
            TokenType::Local => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Repeat => parser.reduce::<94>(),
            TokenType::Return => parser.reduce::<94>(),
            TokenType::While => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::LParen => parser.reduce::<94>(),
            TokenType::DoubleColon => parser.reduce::<94>(),
            TokenType::SemiColon => parser.reduce::<94>(),
            TokenType::Comma => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            TokenType::Eof => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<938> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1184),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<939> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1537),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<940> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(1529),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<941> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(1530),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<942> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1457),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<943> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1165),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<944> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(1528),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<945> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1394),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<946> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1168),
            TokenType::Funcbody => parser.goto(1164),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<947> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1516),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<948> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1432),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<949> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1388),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<950> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1451),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<951> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1420),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<952> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1171),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<953> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<96>(),
            TokenType::And => parser.reduce::<96>(),
            TokenType::Break => parser.reduce::<96>(),
            TokenType::Do => parser.reduce::<96>(),
            TokenType::For => parser.reduce::<96>(),
            TokenType::Function => parser.reduce::<96>(),
            TokenType::Goto => parser.reduce::<96>(),
            TokenType::If => parser.reduce::<96>(),
            TokenType::Local => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Repeat => parser.reduce::<96>(),
            TokenType::Return => parser.reduce::<96>(),
            TokenType::While => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::LParen => parser.reduce::<96>(),
            TokenType::DoubleColon => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Comma => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            TokenType::Eof => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<954> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1365),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<955> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1450),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<956> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1410),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<957> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1426),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<958> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1178),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<959> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1541),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<960> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Eof => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<961> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1461),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<962> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1406),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<963> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1445),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<964> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Eof => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<965> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            TokenType::Eof => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<966> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1397),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<967> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::Until => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<968> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::End => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<969> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1443),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<970> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1424),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<971> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1400),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<972> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1554),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<973> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1442),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<974> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1407),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<975> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1408),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<976> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1463),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<977> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1412),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<978> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<979> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<980> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1466),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<981> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1440),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<982> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::Until => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<983> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::Until => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<984> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1170),
            TokenType::Funcbody => parser.goto(1169),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<985> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1508),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<986> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1401),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<987> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Exp => parser.goto(1409),
            TokenType::Functioncall => parser.goto(293),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<988> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1405),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<989> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1454),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<990> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1542),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<991> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1467),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<992> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1436),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<993> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1459),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<994> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(163),
            TokenType::String(_) => parser.shift(296),
            TokenType::Integer(_) => parser.shift(297),
            TokenType::Float(_) => parser.shift(298),
            TokenType::False => parser.shift(299),
            TokenType::Function => parser.shift(429),
            TokenType::Nil => parser.shift(300),
            TokenType::Not => parser.shift(306),
            TokenType::True => parser.shift(345),
            TokenType::Sub => parser.shift(347),
            TokenType::Len => parser.shift(367),
            TokenType::BitXor => parser.shift(384),
            TokenType::LParen => parser.shift(205),
            TokenType::LCurly => parser.shift(430),
            TokenType::Dots => parser.shift(401),
            TokenType::Var => parser.goto(289),
            TokenType::Exp => parser.goto(1449),
            TokenType::Functioncall => parser.goto(292),
            TokenType::Functiondef => parser.goto(414),
            TokenType::Tableconstructor => parser.goto(415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<995> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1187),
            TokenType::Funcbody => parser.goto(1186),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<996> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1495),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<997> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(1469),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<998> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1180),
            TokenType::Funcbody => parser.goto(1179),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<999> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1504),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1000> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1538),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1001> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1565),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1002> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1527),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1003> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1566),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1004> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1559),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1005> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1549),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1006> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1558),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1007> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1564),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1008> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1536),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1009> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1544),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1010> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1560),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1011> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1555),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1012> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(169),
            TokenType::String(_) => parser.shift(339),
            TokenType::Integer(_) => parser.shift(340),
            TokenType::Float(_) => parser.shift(341),
            TokenType::False => parser.shift(342),
            TokenType::Function => parser.shift(456),
            TokenType::Nil => parser.shift(343),
            TokenType::Not => parser.shift(346),
            TokenType::True => parser.shift(371),
            TokenType::Sub => parser.shift(372),
            TokenType::Len => parser.shift(395),
            TokenType::BitXor => parser.shift(423),
            TokenType::LParen => parser.shift(202),
            TokenType::LCurly => parser.shift(457),
            TokenType::Dots => parser.shift(442),
            TokenType::Var => parser.goto(333),
            TokenType::Exp => parser.goto(1545),
            TokenType::Functioncall => parser.goto(334),
            TokenType::Functiondef => parser.goto(446),
            TokenType::Tableconstructor => parser.goto(447),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1013> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<33>(),
            TokenType::Break => parser.reduce::<33>(),
            TokenType::Do => parser.reduce::<33>(),
            TokenType::For => parser.reduce::<33>(),
            TokenType::Function => parser.reduce::<33>(),
            TokenType::Goto => parser.reduce::<33>(),
            TokenType::If => parser.reduce::<33>(),
            TokenType::Local => parser.reduce::<33>(),
            TokenType::Repeat => parser.reduce::<33>(),
            TokenType::Return => parser.reduce::<33>(),
            TokenType::While => parser.reduce::<33>(),
            TokenType::Assign => parser.reduce::<33>(),
            TokenType::LParen => parser.reduce::<33>(),
            TokenType::DoubleColon => parser.reduce::<33>(),
            TokenType::SemiColon => parser.reduce::<33>(),
            TokenType::Comma => parser.reduce::<33>(),
            TokenType::Eof => parser.reduce::<33>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1014> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<44>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1015> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<113>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1016> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<1>(),
            TokenType::Elseif => parser.reduce::<1>(),
            TokenType::End => parser.reduce::<1>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1017> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Dots => parser.shift(1634),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1018> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<5>(),
            TokenType::Elseif => parser.reduce::<5>(),
            TokenType::End => parser.reduce::<5>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1019> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<55>(),
            TokenType::Comma => parser.reduce::<55>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1020> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1650),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1021> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1651),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1022> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<25>(),
            TokenType::Break => parser.reduce::<25>(),
            TokenType::Do => parser.reduce::<25>(),
            TokenType::For => parser.reduce::<25>(),
            TokenType::Function => parser.reduce::<25>(),
            TokenType::Goto => parser.reduce::<25>(),
            TokenType::If => parser.reduce::<25>(),
            TokenType::Local => parser.reduce::<25>(),
            TokenType::Repeat => parser.reduce::<25>(),
            TokenType::Return => parser.reduce::<25>(),
            TokenType::Until => parser.reduce::<25>(),
            TokenType::While => parser.reduce::<25>(),
            TokenType::LParen => parser.reduce::<25>(),
            TokenType::DoubleColon => parser.reduce::<25>(),
            TokenType::SemiColon => parser.reduce::<25>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1023> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1637),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1024> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(166),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Eof => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(1635),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1025> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<42>(),
            TokenType::Colon => parser.reduce::<42>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1026> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<25>(),
            TokenType::Break => parser.reduce::<25>(),
            TokenType::Do => parser.reduce::<25>(),
            TokenType::End => parser.reduce::<25>(),
            TokenType::For => parser.reduce::<25>(),
            TokenType::Function => parser.reduce::<25>(),
            TokenType::Goto => parser.reduce::<25>(),
            TokenType::If => parser.reduce::<25>(),
            TokenType::Local => parser.reduce::<25>(),
            TokenType::Repeat => parser.reduce::<25>(),
            TokenType::Return => parser.reduce::<25>(),
            TokenType::While => parser.reduce::<25>(),
            TokenType::LParen => parser.reduce::<25>(),
            TokenType::DoubleColon => parser.reduce::<25>(),
            TokenType::SemiColon => parser.reduce::<25>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1027> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::Until => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1028> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::End => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1029> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<34>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1030> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<38>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1031> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Greater => parser.shift(1636),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1032> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<34>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1033> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<38>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1034> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1638),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1035> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<102>(),
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::Break => parser.reduce::<102>(),
            TokenType::Do => parser.reduce::<102>(),
            TokenType::For => parser.reduce::<102>(),
            TokenType::Function => parser.reduce::<102>(),
            TokenType::Goto => parser.reduce::<102>(),
            TokenType::If => parser.reduce::<102>(),
            TokenType::Local => parser.reduce::<102>(),
            TokenType::Repeat => parser.reduce::<102>(),
            TokenType::Return => parser.reduce::<102>(),
            TokenType::Until => parser.reduce::<102>(),
            TokenType::While => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::DoubleColon => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1036> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1640),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1037> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Greater => parser.shift(1639),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1038> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(1654),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1039> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(1655),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1040> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::Or => parser.shift(1286),
            TokenType::Add => parser.shift(1313),
            TokenType::Sub => parser.shift(1321),
            TokenType::Mul => parser.shift(1345),
            TokenType::Div => parser.shift(1352),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Mod => parser.shift(1399),
            TokenType::Pow => parser.shift(1439),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitOr => parser.shift(1490),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::Eq => parser.shift(1522),
            TokenType::Neq => parser.shift(1531),
            TokenType::Leq => parser.shift(1547),
            TokenType::Geq => parser.shift(1567),
            TokenType::Less => parser.shift(1572),
            TokenType::Greater => parser.shift(1577),
            TokenType::Comma => parser.shift(1666),
            TokenType::Concat => parser.shift(1583),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1041> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<28>(),
            TokenType::Break => parser.reduce::<28>(),
            TokenType::Do => parser.reduce::<28>(),
            TokenType::End => parser.reduce::<28>(),
            TokenType::For => parser.reduce::<28>(),
            TokenType::Function => parser.reduce::<28>(),
            TokenType::Goto => parser.reduce::<28>(),
            TokenType::If => parser.reduce::<28>(),
            TokenType::Local => parser.reduce::<28>(),
            TokenType::Repeat => parser.reduce::<28>(),
            TokenType::Return => parser.reduce::<28>(),
            TokenType::While => parser.reduce::<28>(),
            TokenType::LParen => parser.reduce::<28>(),
            TokenType::DoubleColon => parser.reduce::<28>(),
            TokenType::SemiColon => parser.reduce::<28>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1042> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<28>(),
            TokenType::Break => parser.reduce::<28>(),
            TokenType::Do => parser.reduce::<28>(),
            TokenType::For => parser.reduce::<28>(),
            TokenType::Function => parser.reduce::<28>(),
            TokenType::Goto => parser.reduce::<28>(),
            TokenType::If => parser.reduce::<28>(),
            TokenType::Local => parser.reduce::<28>(),
            TokenType::Repeat => parser.reduce::<28>(),
            TokenType::Return => parser.reduce::<28>(),
            TokenType::Until => parser.reduce::<28>(),
            TokenType::While => parser.reduce::<28>(),
            TokenType::LParen => parser.reduce::<28>(),
            TokenType::DoubleColon => parser.reduce::<28>(),
            TokenType::SemiColon => parser.reduce::<28>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1043> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<56>(),
            TokenType::Assign => parser.shift(1686),
            TokenType::Comma => parser.shift(235),
            TokenType::NamelistCont => parser.goto(234),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1044> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.shift(1667),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1045> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1642),
            TokenType::Funcbody => parser.goto(1641),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1046> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(1871),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1047> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(1869),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1048> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(1868),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1049> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Then => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1050> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Then => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1051> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<102>(),
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::Break => parser.reduce::<102>(),
            TokenType::Do => parser.reduce::<102>(),
            TokenType::End => parser.reduce::<102>(),
            TokenType::For => parser.reduce::<102>(),
            TokenType::Function => parser.reduce::<102>(),
            TokenType::Goto => parser.reduce::<102>(),
            TokenType::If => parser.reduce::<102>(),
            TokenType::Local => parser.reduce::<102>(),
            TokenType::Repeat => parser.reduce::<102>(),
            TokenType::Return => parser.reduce::<102>(),
            TokenType::While => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::DoubleColon => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1052> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::Or => parser.shift(1286),
            TokenType::Add => parser.shift(1313),
            TokenType::Sub => parser.shift(1321),
            TokenType::Mul => parser.shift(1345),
            TokenType::Div => parser.shift(1352),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Mod => parser.shift(1399),
            TokenType::Pow => parser.shift(1439),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitOr => parser.shift(1490),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::Eq => parser.shift(1522),
            TokenType::Neq => parser.shift(1531),
            TokenType::Leq => parser.shift(1547),
            TokenType::Geq => parser.shift(1567),
            TokenType::Less => parser.shift(1572),
            TokenType::Greater => parser.shift(1577),
            TokenType::Comma => parser.shift(1690),
            TokenType::Concat => parser.shift(1583),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1053> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(1870),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1054> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<101>(),
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::Break => parser.reduce::<101>(),
            TokenType::Do => parser.reduce::<101>(),
            TokenType::For => parser.reduce::<101>(),
            TokenType::Function => parser.reduce::<101>(),
            TokenType::Goto => parser.reduce::<101>(),
            TokenType::If => parser.reduce::<101>(),
            TokenType::Local => parser.reduce::<101>(),
            TokenType::Repeat => parser.reduce::<101>(),
            TokenType::Return => parser.reduce::<101>(),
            TokenType::Until => parser.reduce::<101>(),
            TokenType::While => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::DoubleColon => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1055> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::RParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1056> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<14>(),
            TokenType::And => parser.shift(1694),
            TokenType::Break => parser.reduce::<14>(),
            TokenType::Do => parser.reduce::<14>(),
            TokenType::For => parser.reduce::<14>(),
            TokenType::Function => parser.reduce::<14>(),
            TokenType::Goto => parser.reduce::<14>(),
            TokenType::If => parser.reduce::<14>(),
            TokenType::Local => parser.reduce::<14>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Repeat => parser.reduce::<14>(),
            TokenType::Return => parser.reduce::<14>(),
            TokenType::Until => parser.reduce::<14>(),
            TokenType::While => parser.reduce::<14>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Sub => parser.shift(1898),
            TokenType::Mul => parser.shift(1979),
            TokenType::Div => parser.shift(2000),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Mod => parser.shift(2058),
            TokenType::Pow => parser.shift(2082),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitOr => parser.shift(2093),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::Eq => parser.shift(2099),
            TokenType::Neq => parser.shift(2101),
            TokenType::Leq => parser.shift(2103),
            TokenType::Geq => parser.shift(2106),
            TokenType::Less => parser.shift(2108),
            TokenType::Greater => parser.shift(2110),
            TokenType::LParen => parser.reduce::<14>(),
            TokenType::DoubleColon => parser.reduce::<14>(),
            TokenType::SemiColon => parser.reduce::<14>(),
            TokenType::Concat => parser.shift(2111),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1057> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(1756),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1058> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<3>(),
            TokenType::Elseif => parser.reduce::<3>(),
            TokenType::End => parser.reduce::<3>(),
            TokenType::Return => parser.reduce::<3>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1059> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1645),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1060> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<14>(),
            TokenType::And => parser.shift(1695),
            TokenType::Break => parser.reduce::<14>(),
            TokenType::Do => parser.reduce::<14>(),
            TokenType::End => parser.reduce::<14>(),
            TokenType::For => parser.reduce::<14>(),
            TokenType::Function => parser.reduce::<14>(),
            TokenType::Goto => parser.reduce::<14>(),
            TokenType::If => parser.reduce::<14>(),
            TokenType::Local => parser.reduce::<14>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Repeat => parser.reduce::<14>(),
            TokenType::Return => parser.reduce::<14>(),
            TokenType::While => parser.reduce::<14>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Sub => parser.shift(1901),
            TokenType::Mul => parser.shift(1983),
            TokenType::Div => parser.shift(2002),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Mod => parser.shift(2060),
            TokenType::Pow => parser.shift(2083),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitOr => parser.shift(2092),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::Eq => parser.shift(2098),
            TokenType::Neq => parser.shift(2100),
            TokenType::Leq => parser.shift(2102),
            TokenType::Geq => parser.shift(2104),
            TokenType::Less => parser.shift(2105),
            TokenType::Greater => parser.shift(2107),
            TokenType::LParen => parser.reduce::<14>(),
            TokenType::DoubleColon => parser.reduce::<14>(),
            TokenType::SemiColon => parser.reduce::<14>(),
            TokenType::Concat => parser.shift(2109),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1061> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Do => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1062> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::RParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1063> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::Until => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1064> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Do => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1065> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(545),
            TokenType::LParen => parser.shift(547),
            TokenType::LCurly => parser.shift(575),
            TokenType::Args => parser.goto(1643),
            TokenType::Tableconstructor => parser.goto(573),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1066> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::Assign => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Comma => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1067> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(67),
            TokenType::LParen => parser.shift(71),
            TokenType::LCurly => parser.shift(88),
            TokenType::Args => parser.goto(1644),
            TokenType::Tableconstructor => parser.goto(86),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1068> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1801),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1069> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1070> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<11>(),
            TokenType::Break => parser.reduce::<11>(),
            TokenType::Do => parser.reduce::<11>(),
            TokenType::Else => parser.reduce::<11>(),
            TokenType::Elseif => parser.reduce::<11>(),
            TokenType::End => parser.reduce::<11>(),
            TokenType::For => parser.reduce::<11>(),
            TokenType::Function => parser.reduce::<11>(),
            TokenType::Goto => parser.reduce::<11>(),
            TokenType::If => parser.reduce::<11>(),
            TokenType::Local => parser.reduce::<11>(),
            TokenType::Repeat => parser.reduce::<11>(),
            TokenType::Return => parser.reduce::<11>(),
            TokenType::While => parser.reduce::<11>(),
            TokenType::LParen => parser.reduce::<11>(),
            TokenType::DoubleColon => parser.reduce::<11>(),
            TokenType::SemiColon => parser.reduce::<11>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1071> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::Or => parser.shift(281),
            TokenType::Then => parser.shift(1659),
            TokenType::Add => parser.shift(328),
            TokenType::Sub => parser.shift(337),
            TokenType::Mul => parser.shift(356),
            TokenType::Div => parser.shift(365),
            TokenType::Idiv => parser.shift(370),
            TokenType::Mod => parser.shift(376),
            TokenType::Pow => parser.shift(385),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitOr => parser.shift(402),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftR => parser.shift(418),
            TokenType::Eq => parser.shift(424),
            TokenType::Neq => parser.shift(428),
            TokenType::Leq => parser.shift(433),
            TokenType::Geq => parser.shift(436),
            TokenType::Less => parser.shift(439),
            TokenType::Greater => parser.shift(443),
            TokenType::Concat => parser.shift(448),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1072> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1656),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1073> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::Else => parser.reduce::<35>(),
            TokenType::Elseif => parser.reduce::<35>(),
            TokenType::End => parser.reduce::<35>(),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::SemiColon => parser.reduce::<35>(),
            TokenType::Dots => parser.shift(1948),
            TokenType::RetstatExplist => parser.goto(1646),
            TokenType::Var => parser.goto(1851),
            TokenType::Explist => parser.goto(1652),
            TokenType::Exp => parser.goto(1860),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1074> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(545),
            TokenType::LParen => parser.shift(547),
            TokenType::LCurly => parser.shift(575),
            TokenType::Args => parser.goto(1648),
            TokenType::Tableconstructor => parser.goto(573),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1075> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1657),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1076> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1077> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.shift(1660),
            TokenType::End => parser.reduce::<18>(),
            TokenType::StatElse => parser.goto(1647),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1078> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::RCurly => parser.reduce::<52>(),
            TokenType::SemiColon => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Comma => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1079> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<101>(),
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::Break => parser.reduce::<101>(),
            TokenType::Do => parser.reduce::<101>(),
            TokenType::End => parser.reduce::<101>(),
            TokenType::For => parser.reduce::<101>(),
            TokenType::Function => parser.reduce::<101>(),
            TokenType::Goto => parser.reduce::<101>(),
            TokenType::If => parser.reduce::<101>(),
            TokenType::Local => parser.reduce::<101>(),
            TokenType::Repeat => parser.reduce::<101>(),
            TokenType::Return => parser.reduce::<101>(),
            TokenType::While => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::DoubleColon => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1080> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1649),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1081> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Comma => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            TokenType::Eof => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1082> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1661),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1083> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1084> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1793),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1085> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::RParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Comma => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1086> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1704),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1087> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::Do => parser.shift(1658),
            TokenType::Or => parser.shift(257),
            TokenType::Add => parser.shift(290),
            TokenType::Sub => parser.shift(329),
            TokenType::Mul => parser.shift(352),
            TokenType::Div => parser.shift(362),
            TokenType::Idiv => parser.shift(373),
            TokenType::Mod => parser.shift(383),
            TokenType::Pow => parser.shift(389),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitOr => parser.shift(417),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftR => parser.shift(432),
            TokenType::Eq => parser.shift(437),
            TokenType::Neq => parser.shift(440),
            TokenType::Leq => parser.shift(444),
            TokenType::Geq => parser.shift(450),
            TokenType::Less => parser.shift(452),
            TokenType::Greater => parser.shift(454),
            TokenType::Concat => parser.shift(455),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1088> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<52>(),
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Break => parser.reduce::<52>(),
            TokenType::Do => parser.reduce::<52>(),
            TokenType::For => parser.reduce::<52>(),
            TokenType::Function => parser.reduce::<52>(),
            TokenType::Goto => parser.reduce::<52>(),
            TokenType::If => parser.reduce::<52>(),
            TokenType::Local => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Repeat => parser.reduce::<52>(),
            TokenType::Return => parser.reduce::<52>(),
            TokenType::While => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::DoubleColon => parser.reduce::<52>(),
            TokenType::SemiColon => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Comma => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            TokenType::Eof => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1089> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::RCurly => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Comma => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1090> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::SemiColon => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Comma => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            TokenType::Eof => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1091> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(656),
            TokenType::LParen => parser.shift(660),
            TokenType::LCurly => parser.shift(682),
            TokenType::Args => parser.goto(1671),
            TokenType::Tableconstructor => parser.goto(681),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1092> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1093> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Then => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1094> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(633),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.shift(635),
            TokenType::LSquare => parser.shift(1710),
            TokenType::LCurly => parser.shift(687),
            TokenType::RCurly => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.shift(1780),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.shift(1779),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(1783),
            TokenType::Tableconstructor => parser.goto(685),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1095> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1096> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(628),
            TokenType::LParen => parser.shift(629),
            TokenType::LCurly => parser.shift(686),
            TokenType::Args => parser.goto(1669),
            TokenType::Tableconstructor => parser.goto(684),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1097> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(656),
            TokenType::LParen => parser.shift(660),
            TokenType::LCurly => parser.shift(682),
            TokenType::Args => parser.goto(1662),
            TokenType::Tableconstructor => parser.goto(681),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1098> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::RParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Comma => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1099> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2020),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1100> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1101> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::RParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1102> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(633),
            TokenType::LParen => parser.shift(635),
            TokenType::LCurly => parser.shift(687),
            TokenType::Args => parser.goto(1670),
            TokenType::Tableconstructor => parser.goto(685),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1103> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(675),
            TokenType::LParen => parser.shift(676),
            TokenType::LCurly => parser.shift(731),
            TokenType::Args => parser.goto(1679),
            TokenType::Tableconstructor => parser.goto(730),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1104> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(675),
            TokenType::LParen => parser.shift(676),
            TokenType::LCurly => parser.shift(731),
            TokenType::Args => parser.goto(1664),
            TokenType::Tableconstructor => parser.goto(730),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1105> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(545),
            TokenType::LParen => parser.shift(547),
            TokenType::LSquare => parser.shift(515),
            TokenType::LCurly => parser.shift(575),
            TokenType::Colon => parser.shift(1773),
            TokenType::Dot => parser.shift(556),
            TokenType::Args => parser.goto(1774),
            TokenType::Tableconstructor => parser.goto(573),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1106> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1818),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1107> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(633),
            TokenType::LParen => parser.shift(635),
            TokenType::LCurly => parser.shift(687),
            TokenType::Args => parser.goto(1672),
            TokenType::Tableconstructor => parser.goto(685),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1108> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(1797),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1109> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1866),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1110> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(628),
            TokenType::LParen => parser.shift(629),
            TokenType::LCurly => parser.shift(686),
            TokenType::Args => parser.goto(1674),
            TokenType::Tableconstructor => parser.goto(684),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1111> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(656),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.shift(660),
            TokenType::LSquare => parser.shift(1700),
            TokenType::RSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.shift(682),
            TokenType::Colon => parser.shift(1782),
            TokenType::Dot => parser.shift(1781),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(1784),
            TokenType::Tableconstructor => parser.goto(681),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1112> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1113> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Explist => parser.goto(1685),
            TokenType::Exp => parser.goto(1876),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1114> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(622),
            TokenType::LParen => parser.shift(627),
            TokenType::LCurly => parser.shift(677),
            TokenType::Args => parser.goto(1680),
            TokenType::Tableconstructor => parser.goto(671),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1115> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(622),
            TokenType::LParen => parser.shift(627),
            TokenType::LCurly => parser.shift(677),
            TokenType::Args => parser.goto(1673),
            TokenType::Tableconstructor => parser.goto(671),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1116> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.shift(675),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            // Shift(676)-Reduce(71)
            TokenType::LParen => parser.shift(676),
            TokenType::LSquare => parser.shift(1691),
            TokenType::LCurly => parser.shift(731),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.shift(1795),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.shift(1794),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Eof => parser.reduce::<71>(),
            TokenType::Args => parser.goto(1796),
            TokenType::Tableconstructor => parser.goto(730),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1117> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1848),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1118> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1856),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1119> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1847),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1120> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1854),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1121> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1849),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1122> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::RSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1123> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1846),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1124> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::RSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1125> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1844),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1126> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(1873),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1127> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1842),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1128> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1843),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1129> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1835),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1130> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1838),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1131> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1916),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1132> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(1834),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1133> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1134> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Then => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1135> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<27>(),
            TokenType::Break => parser.reduce::<27>(),
            TokenType::Do => parser.reduce::<27>(),
            TokenType::Else => parser.reduce::<27>(),
            TokenType::Elseif => parser.reduce::<27>(),
            TokenType::End => parser.reduce::<27>(),
            TokenType::For => parser.reduce::<27>(),
            TokenType::Function => parser.reduce::<27>(),
            TokenType::Goto => parser.reduce::<27>(),
            TokenType::If => parser.reduce::<27>(),
            TokenType::Local => parser.reduce::<27>(),
            TokenType::Repeat => parser.reduce::<27>(),
            TokenType::Return => parser.reduce::<27>(),
            TokenType::While => parser.reduce::<27>(),
            TokenType::Assign => parser.shift(1755),
            TokenType::LParen => parser.reduce::<27>(),
            TokenType::DoubleColon => parser.reduce::<27>(),
            TokenType::SemiColon => parser.reduce::<27>(),
            TokenType::StatAttexplist => parser.goto(1681),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1136> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::Else => parser.reduce::<32>(),
            TokenType::Elseif => parser.reduce::<32>(),
            TokenType::End => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(1668),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(1665),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1137> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::DoubleColon => parser.shift(1663),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1138> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<13>(),
            TokenType::Break => parser.reduce::<13>(),
            TokenType::Do => parser.reduce::<13>(),
            TokenType::For => parser.reduce::<13>(),
            TokenType::Function => parser.reduce::<13>(),
            TokenType::Goto => parser.reduce::<13>(),
            TokenType::If => parser.reduce::<13>(),
            TokenType::Local => parser.reduce::<13>(),
            TokenType::Repeat => parser.reduce::<13>(),
            TokenType::Return => parser.reduce::<13>(),
            TokenType::While => parser.reduce::<13>(),
            TokenType::LParen => parser.reduce::<13>(),
            TokenType::DoubleColon => parser.reduce::<13>(),
            TokenType::SemiColon => parser.reduce::<13>(),
            TokenType::Eof => parser.reduce::<13>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1139> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(622),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.shift(627),
            TokenType::RParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.shift(1703),
            TokenType::LCurly => parser.shift(677),
            TokenType::Colon => parser.shift(1791),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.shift(1790),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(1792),
            TokenType::Tableconstructor => parser.goto(671),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1140> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1687),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1141> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1839),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1142> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<53>(),
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Break => parser.reduce::<53>(),
            TokenType::Do => parser.reduce::<53>(),
            TokenType::For => parser.reduce::<53>(),
            TokenType::Function => parser.reduce::<53>(),
            TokenType::Goto => parser.reduce::<53>(),
            TokenType::If => parser.reduce::<53>(),
            TokenType::Local => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Repeat => parser.reduce::<53>(),
            TokenType::Return => parser.reduce::<53>(),
            TokenType::While => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::DoubleColon => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Comma => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            TokenType::Eof => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1143> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::Until => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1144> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::Comma => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1145> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1858),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1146> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Do => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1147> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(41),
            TokenType::String(_) => parser.shift(118),
            TokenType::Integer(_) => parser.shift(119),
            TokenType::Float(_) => parser.shift(120),
            TokenType::False => parser.shift(121),
            TokenType::Function => parser.shift(145),
            TokenType::Nil => parser.shift(122),
            TokenType::Not => parser.shift(123),
            TokenType::True => parser.shift(126),
            TokenType::Sub => parser.shift(127),
            TokenType::Len => parser.shift(130),
            TokenType::BitXor => parser.shift(131),
            TokenType::LParen => parser.shift(51),
            TokenType::LCurly => parser.shift(146),
            TokenType::Dots => parser.shift(138),
            TokenType::Var => parser.goto(114),
            TokenType::Exp => parser.goto(1682),
            TokenType::Functioncall => parser.goto(115),
            TokenType::Functiondef => parser.goto(139),
            TokenType::Tableconstructor => parser.goto(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1148> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(628),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.shift(629),
            TokenType::LSquare => parser.shift(1693),
            TokenType::LCurly => parser.shift(686),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.shift(1777),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.shift(1776),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Eof => parser.reduce::<71>(),
            TokenType::Args => parser.goto(1778),
            TokenType::Tableconstructor => parser.goto(684),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1149> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Then => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1150> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::End => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1151> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<104>(),
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::Break => parser.reduce::<104>(),
            TokenType::Do => parser.reduce::<104>(),
            TokenType::End => parser.reduce::<104>(),
            TokenType::For => parser.reduce::<104>(),
            TokenType::Function => parser.reduce::<104>(),
            TokenType::Goto => parser.reduce::<104>(),
            TokenType::If => parser.reduce::<104>(),
            TokenType::Local => parser.reduce::<104>(),
            TokenType::Repeat => parser.reduce::<104>(),
            TokenType::Return => parser.reduce::<104>(),
            TokenType::While => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::DoubleColon => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1152> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::RParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1153> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(1678),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1154> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1859),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1155> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1837),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1156> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(1840),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1157> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1683),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1158> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<98>(),
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::Break => parser.reduce::<98>(),
            TokenType::Do => parser.reduce::<98>(),
            TokenType::Else => parser.reduce::<98>(),
            TokenType::Elseif => parser.reduce::<98>(),
            TokenType::End => parser.reduce::<98>(),
            TokenType::For => parser.reduce::<98>(),
            TokenType::Function => parser.reduce::<98>(),
            TokenType::Goto => parser.reduce::<98>(),
            TokenType::If => parser.reduce::<98>(),
            TokenType::Local => parser.reduce::<98>(),
            TokenType::Repeat => parser.reduce::<98>(),
            TokenType::Return => parser.reduce::<98>(),
            TokenType::While => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::DoubleColon => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1159> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<108>(),
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::Break => parser.reduce::<108>(),
            TokenType::Do => parser.reduce::<108>(),
            TokenType::Else => parser.reduce::<108>(),
            TokenType::Elseif => parser.reduce::<108>(),
            TokenType::End => parser.reduce::<108>(),
            TokenType::For => parser.reduce::<108>(),
            TokenType::Function => parser.reduce::<108>(),
            TokenType::Goto => parser.reduce::<108>(),
            TokenType::If => parser.reduce::<108>(),
            TokenType::Local => parser.reduce::<108>(),
            TokenType::Repeat => parser.reduce::<108>(),
            TokenType::Return => parser.reduce::<108>(),
            TokenType::While => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::DoubleColon => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1160> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<109>(),
            TokenType::Do => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::Comma => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1161> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::Until => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1162> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(1675),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1163> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::RCurly => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1164> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<109>(),
            TokenType::End => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::SemiColon => parser.reduce::<109>(),
            TokenType::Comma => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1165> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            TokenType::Eof => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1166> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::RParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1167> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<104>(),
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::Break => parser.reduce::<104>(),
            TokenType::Do => parser.reduce::<104>(),
            TokenType::For => parser.reduce::<104>(),
            TokenType::Function => parser.reduce::<104>(),
            TokenType::Goto => parser.reduce::<104>(),
            TokenType::If => parser.reduce::<104>(),
            TokenType::Local => parser.reduce::<104>(),
            TokenType::Repeat => parser.reduce::<104>(),
            TokenType::Return => parser.reduce::<104>(),
            TokenType::Until => parser.reduce::<104>(),
            TokenType::While => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::DoubleColon => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1168> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(1677),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1169> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<109>(),
            TokenType::And => parser.reduce::<109>(),
            TokenType::Break => parser.reduce::<109>(),
            TokenType::Do => parser.reduce::<109>(),
            TokenType::For => parser.reduce::<109>(),
            TokenType::Function => parser.reduce::<109>(),
            TokenType::Goto => parser.reduce::<109>(),
            TokenType::If => parser.reduce::<109>(),
            TokenType::Local => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Repeat => parser.reduce::<109>(),
            TokenType::Return => parser.reduce::<109>(),
            TokenType::While => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::LParen => parser.reduce::<109>(),
            TokenType::DoubleColon => parser.reduce::<109>(),
            TokenType::SemiColon => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            TokenType::Eof => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1170> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(1676),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1171> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::RParen => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1172> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1928),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1173> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::RSquare => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1174> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Until => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::SemiColon => parser.reduce::<109>(),
            TokenType::Comma => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1175> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(1884),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1176> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::RParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1177> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1927),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1178> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            TokenType::Eof => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1179> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<109>(),
            TokenType::And => parser.reduce::<109>(),
            TokenType::Break => parser.reduce::<109>(),
            TokenType::Do => parser.reduce::<109>(),
            TokenType::For => parser.reduce::<109>(),
            TokenType::Function => parser.reduce::<109>(),
            TokenType::Goto => parser.reduce::<109>(),
            TokenType::If => parser.reduce::<109>(),
            TokenType::Local => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Repeat => parser.reduce::<109>(),
            TokenType::Return => parser.reduce::<109>(),
            TokenType::Until => parser.reduce::<109>(),
            TokenType::While => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::LParen => parser.reduce::<109>(),
            TokenType::DoubleColon => parser.reduce::<109>(),
            TokenType::SemiColon => parser.reduce::<109>(),
            TokenType::Comma => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1180> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(1689),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1181> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(1699),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1182> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Then => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1183> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1692),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1184> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1185> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<100>(),
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::Break => parser.reduce::<100>(),
            TokenType::Do => parser.reduce::<100>(),
            TokenType::For => parser.reduce::<100>(),
            TokenType::Function => parser.reduce::<100>(),
            TokenType::Goto => parser.reduce::<100>(),
            TokenType::If => parser.reduce::<100>(),
            TokenType::Local => parser.reduce::<100>(),
            TokenType::Repeat => parser.reduce::<100>(),
            TokenType::Return => parser.reduce::<100>(),
            TokenType::Until => parser.reduce::<100>(),
            TokenType::While => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::DoubleColon => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1186> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<109>(),
            TokenType::And => parser.reduce::<109>(),
            TokenType::Break => parser.reduce::<109>(),
            TokenType::Do => parser.reduce::<109>(),
            TokenType::End => parser.reduce::<109>(),
            TokenType::For => parser.reduce::<109>(),
            TokenType::Function => parser.reduce::<109>(),
            TokenType::Goto => parser.reduce::<109>(),
            TokenType::If => parser.reduce::<109>(),
            TokenType::Local => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Repeat => parser.reduce::<109>(),
            TokenType::Return => parser.reduce::<109>(),
            TokenType::While => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::LParen => parser.reduce::<109>(),
            TokenType::DoubleColon => parser.reduce::<109>(),
            TokenType::SemiColon => parser.reduce::<109>(),
            TokenType::Comma => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1187> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(1705),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1188> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(1991),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1189> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2021),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1190> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1726),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1191> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1697),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1192> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<99>(),
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::Break => parser.reduce::<99>(),
            TokenType::Do => parser.reduce::<99>(),
            TokenType::Else => parser.reduce::<99>(),
            TokenType::Elseif => parser.reduce::<99>(),
            TokenType::End => parser.reduce::<99>(),
            TokenType::For => parser.reduce::<99>(),
            TokenType::Function => parser.reduce::<99>(),
            TokenType::Goto => parser.reduce::<99>(),
            TokenType::If => parser.reduce::<99>(),
            TokenType::Local => parser.reduce::<99>(),
            TokenType::Repeat => parser.reduce::<99>(),
            TokenType::Return => parser.reduce::<99>(),
            TokenType::While => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::DoubleColon => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1193> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1688),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1194> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<100>(),
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::Break => parser.reduce::<100>(),
            TokenType::Do => parser.reduce::<100>(),
            TokenType::End => parser.reduce::<100>(),
            TokenType::For => parser.reduce::<100>(),
            TokenType::Function => parser.reduce::<100>(),
            TokenType::Goto => parser.reduce::<100>(),
            TokenType::If => parser.reduce::<100>(),
            TokenType::Local => parser.reduce::<100>(),
            TokenType::Repeat => parser.reduce::<100>(),
            TokenType::Return => parser.reduce::<100>(),
            TokenType::While => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::DoubleColon => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1195> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<16>(),
            TokenType::Elseif => parser.shift(1147),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatElseif => parser.goto(1698),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1196> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1711),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1197> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1766),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1198> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1735),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1199> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1892),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1200> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1701),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1201> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<99>(),
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Break => parser.reduce::<99>(),
            TokenType::Do => parser.reduce::<99>(),
            TokenType::For => parser.reduce::<99>(),
            TokenType::Function => parser.reduce::<99>(),
            TokenType::Goto => parser.reduce::<99>(),
            TokenType::If => parser.reduce::<99>(),
            TokenType::Local => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Repeat => parser.reduce::<99>(),
            TokenType::Return => parser.reduce::<99>(),
            TokenType::While => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::DoubleColon => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            TokenType::Eof => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1202> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<108>(),
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Break => parser.reduce::<108>(),
            TokenType::Do => parser.reduce::<108>(),
            TokenType::For => parser.reduce::<108>(),
            TokenType::Function => parser.reduce::<108>(),
            TokenType::Goto => parser.reduce::<108>(),
            TokenType::If => parser.reduce::<108>(),
            TokenType::Local => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Repeat => parser.reduce::<108>(),
            TokenType::Return => parser.reduce::<108>(),
            TokenType::While => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::DoubleColon => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            TokenType::Eof => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1203> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Comma => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1204> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Comma => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1205> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(1988),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1206> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(1993),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1207> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1736),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1208> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<16>(),
            TokenType::Elseif => parser.shift(1147),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatElseif => parser.goto(1722),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1209> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1720),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1210> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Then => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1211> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1729),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1212> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1737),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1213> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::End => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Comma => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1214> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::End => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Comma => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1215> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1912),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1216> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1724),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1217> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.shift(1802),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1218> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(1994),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1219> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1764),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1220> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Do => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Comma => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1221> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Do => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Comma => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1222> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(1702),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1223> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(1992),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1224> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1734),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1225> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1760),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1226> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Do => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1227> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1765),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1228> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1767),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1229> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1728),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1230> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1731),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1231> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<107>(),
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::Break => parser.reduce::<107>(),
            TokenType::Do => parser.reduce::<107>(),
            TokenType::Else => parser.reduce::<107>(),
            TokenType::Elseif => parser.reduce::<107>(),
            TokenType::End => parser.reduce::<107>(),
            TokenType::For => parser.reduce::<107>(),
            TokenType::Function => parser.reduce::<107>(),
            TokenType::Goto => parser.reduce::<107>(),
            TokenType::If => parser.reduce::<107>(),
            TokenType::Local => parser.reduce::<107>(),
            TokenType::Repeat => parser.reduce::<107>(),
            TokenType::Return => parser.reduce::<107>(),
            TokenType::While => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::DoubleColon => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1232> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1712),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1233> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Do => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Comma => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1234> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1709),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1235> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Comma => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1236> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1730),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1237> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1740),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1238> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::RParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1239> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1995),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1240> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Until => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Comma => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1241> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Until => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Comma => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1242> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1763),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1243> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1758),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1244> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::End => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Comma => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1245> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1708),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1246> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1761),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1247> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Until => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Comma => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1248> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(1980),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1249> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2038),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1250> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(1721),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1251> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1715),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1252> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(1714),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1253> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(1706),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1254> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1924),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1255> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(1753),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1256> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(1716),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1257> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(1713),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1258> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1749),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1259> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1938),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1260> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1723),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1261> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<98>(),
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Break => parser.reduce::<98>(),
            TokenType::Do => parser.reduce::<98>(),
            TokenType::End => parser.reduce::<98>(),
            TokenType::For => parser.reduce::<98>(),
            TokenType::Function => parser.reduce::<98>(),
            TokenType::Goto => parser.reduce::<98>(),
            TokenType::If => parser.reduce::<98>(),
            TokenType::Local => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Repeat => parser.reduce::<98>(),
            TokenType::Return => parser.reduce::<98>(),
            TokenType::While => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::DoubleColon => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Comma => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1262> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<108>(),
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Break => parser.reduce::<108>(),
            TokenType::Do => parser.reduce::<108>(),
            TokenType::End => parser.reduce::<108>(),
            TokenType::For => parser.reduce::<108>(),
            TokenType::Function => parser.reduce::<108>(),
            TokenType::Goto => parser.reduce::<108>(),
            TokenType::If => parser.reduce::<108>(),
            TokenType::Local => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Repeat => parser.reduce::<108>(),
            TokenType::Return => parser.reduce::<108>(),
            TokenType::While => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::DoubleColon => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Comma => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1263> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(1747),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1264> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(1998),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1265> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1738),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1266> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1775),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1267> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1762),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1268> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<99>(),
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Break => parser.reduce::<99>(),
            TokenType::Do => parser.reduce::<99>(),
            TokenType::For => parser.reduce::<99>(),
            TokenType::Function => parser.reduce::<99>(),
            TokenType::Goto => parser.reduce::<99>(),
            TokenType::If => parser.reduce::<99>(),
            TokenType::Local => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Repeat => parser.reduce::<99>(),
            TokenType::Return => parser.reduce::<99>(),
            TokenType::Until => parser.reduce::<99>(),
            TokenType::While => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::DoubleColon => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Comma => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1269> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<108>(),
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Break => parser.reduce::<108>(),
            TokenType::Do => parser.reduce::<108>(),
            TokenType::For => parser.reduce::<108>(),
            TokenType::Function => parser.reduce::<108>(),
            TokenType::Goto => parser.reduce::<108>(),
            TokenType::If => parser.reduce::<108>(),
            TokenType::Local => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Repeat => parser.reduce::<108>(),
            TokenType::Return => parser.reduce::<108>(),
            TokenType::Until => parser.reduce::<108>(),
            TokenType::While => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::DoubleColon => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Comma => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1270> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1739),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1271> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1752),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1272> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1733),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1273> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1757),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1274> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<99>(),
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Break => parser.reduce::<99>(),
            TokenType::Do => parser.reduce::<99>(),
            TokenType::End => parser.reduce::<99>(),
            TokenType::For => parser.reduce::<99>(),
            TokenType::Function => parser.reduce::<99>(),
            TokenType::Goto => parser.reduce::<99>(),
            TokenType::If => parser.reduce::<99>(),
            TokenType::Local => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Repeat => parser.reduce::<99>(),
            TokenType::Return => parser.reduce::<99>(),
            TokenType::While => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::DoubleColon => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Comma => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1275> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1751),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1276> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<98>(),
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Break => parser.reduce::<98>(),
            TokenType::Do => parser.reduce::<98>(),
            TokenType::For => parser.reduce::<98>(),
            TokenType::Function => parser.reduce::<98>(),
            TokenType::Goto => parser.reduce::<98>(),
            TokenType::If => parser.reduce::<98>(),
            TokenType::Local => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Repeat => parser.reduce::<98>(),
            TokenType::Return => parser.reduce::<98>(),
            TokenType::Until => parser.reduce::<98>(),
            TokenType::While => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::DoubleColon => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Comma => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1277> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::End => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Comma => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1278> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(1989),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1279> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(2003),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1280> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1754),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1281> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1725),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1282> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<98>(),
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Break => parser.reduce::<98>(),
            TokenType::Do => parser.reduce::<98>(),
            TokenType::For => parser.reduce::<98>(),
            TokenType::Function => parser.reduce::<98>(),
            TokenType::Goto => parser.reduce::<98>(),
            TokenType::If => parser.reduce::<98>(),
            TokenType::Local => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Repeat => parser.reduce::<98>(),
            TokenType::Return => parser.reduce::<98>(),
            TokenType::While => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::DoubleColon => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            TokenType::Eof => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1283> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1897),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1284> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Comma => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1285> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1996),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1286> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1931),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1287> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Do => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Comma => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1288> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(2004),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1289> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<107>(),
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Break => parser.reduce::<107>(),
            TokenType::Do => parser.reduce::<107>(),
            TokenType::For => parser.reduce::<107>(),
            TokenType::Function => parser.reduce::<107>(),
            TokenType::Goto => parser.reduce::<107>(),
            TokenType::If => parser.reduce::<107>(),
            TokenType::Local => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Repeat => parser.reduce::<107>(),
            TokenType::Return => parser.reduce::<107>(),
            TokenType::While => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::DoubleColon => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            TokenType::Eof => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1290> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1743),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1291> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1746),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1292> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1997),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1293> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Until => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Comma => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1294> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(2005),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1295> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2043),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1296> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1719),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1297> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1768),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1298> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2026),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1299> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1907),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1300> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1717),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1301> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1771),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1302> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1727),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1303> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1718),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1304> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1921),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1305> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1707),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1306> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(1750),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1307> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::Or => parser.shift(639),
            TokenType::Add => parser.shift(694),
            TokenType::Sub => parser.shift(734),
            TokenType::Mul => parser.shift(763),
            TokenType::Div => parser.shift(784),
            TokenType::Idiv => parser.shift(793),
            TokenType::Mod => parser.shift(810),
            TokenType::Pow => parser.shift(874),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitOr => parser.shift(915),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftR => parser.shift(936),
            TokenType::Eq => parser.shift(948),
            TokenType::Neq => parser.shift(954),
            TokenType::Leq => parser.shift(962),
            TokenType::Geq => parser.shift(970),
            TokenType::Less => parser.shift(974),
            TokenType::Greater => parser.shift(977),
            TokenType::RParen => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(581),
            TokenType::Concat => parser.shift(987),
            TokenType::ExplistCont => parser.goto(1732),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1308> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<107>(),
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Break => parser.reduce::<107>(),
            TokenType::Do => parser.reduce::<107>(),
            TokenType::End => parser.reduce::<107>(),
            TokenType::For => parser.reduce::<107>(),
            TokenType::Function => parser.reduce::<107>(),
            TokenType::Goto => parser.reduce::<107>(),
            TokenType::If => parser.reduce::<107>(),
            TokenType::Local => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Repeat => parser.reduce::<107>(),
            TokenType::Return => parser.reduce::<107>(),
            TokenType::While => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::DoubleColon => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Comma => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1309> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(1999),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1310> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<107>(),
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Break => parser.reduce::<107>(),
            TokenType::Do => parser.reduce::<107>(),
            TokenType::For => parser.reduce::<107>(),
            TokenType::Function => parser.reduce::<107>(),
            TokenType::Goto => parser.reduce::<107>(),
            TokenType::If => parser.reduce::<107>(),
            TokenType::Local => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Repeat => parser.reduce::<107>(),
            TokenType::Return => parser.reduce::<107>(),
            TokenType::Until => parser.reduce::<107>(),
            TokenType::While => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::DoubleColon => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Comma => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1311> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1933),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1312> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(2001),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1313> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1904),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1314> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::Or => parser.shift(670),
            TokenType::Add => parser.shift(728),
            TokenType::Sub => parser.shift(755),
            TokenType::Mul => parser.shift(788),
            TokenType::Div => parser.shift(802),
            TokenType::Idiv => parser.shift(852),
            TokenType::Mod => parser.shift(891),
            TokenType::Pow => parser.shift(903),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitOr => parser.shift(942),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftR => parser.shift(955),
            TokenType::Eq => parser.shift(961),
            TokenType::Neq => parser.shift(969),
            TokenType::Leq => parser.shift(976),
            TokenType::Geq => parser.shift(981),
            TokenType::Less => parser.shift(989),
            TokenType::Greater => parser.shift(992),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(599),
            TokenType::Concat => parser.shift(994),
            TokenType::Eof => parser.reduce::<59>(),
            TokenType::ExplistCont => parser.goto(1772),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1315> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::Comma => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1316> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1915),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1317> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.shift(1828),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::Until => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            // Shift(1832)-Reduce(69)
            TokenType::LParen => parser.shift(1832),
            TokenType::LSquare => parser.shift(1759),
            TokenType::LCurly => parser.shift(1855),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.shift(1831),
            TokenType::Dot => parser.shift(1829),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(1833),
            TokenType::Tableconstructor => parser.goto(1853),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1318> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.shift(1828),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::Until => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            // Shift(1832)-Reduce(70)
            TokenType::LParen => parser.shift(1832),
            TokenType::LSquare => parser.shift(1769),
            TokenType::LCurly => parser.shift(1855),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.shift(1826),
            TokenType::Dot => parser.shift(1825),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(1827),
            TokenType::Tableconstructor => parser.goto(1853),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1319> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<93>(),
            TokenType::Do => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::Comma => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1320> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2034),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1321> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1894),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1322> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::Until => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1323> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::Until => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1324> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::Until => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1325> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::Until => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1326> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::Until => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1327> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1956),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1328> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.shift(669),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.shift(770),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.shift(831),
            TokenType::Sub => parser.shift(909),
            TokenType::Mul => parser.shift(939),
            TokenType::Div => parser.shift(959),
            TokenType::Idiv => parser.shift(972),
            TokenType::Mod => parser.shift(990),
            TokenType::Pow => parser.shift(1000),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitOr => parser.shift(1003),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::Eq => parser.shift(1006),
            TokenType::Neq => parser.shift(1007),
            TokenType::Leq => parser.shift(1008),
            TokenType::Geq => parser.shift(1009),
            TokenType::Less => parser.shift(1010),
            TokenType::Greater => parser.shift(1011),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(617),
            TokenType::Concat => parser.shift(1012),
            TokenType::Eof => parser.reduce::<59>(),
            TokenType::ExplistCont => parser.goto(1836),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1329> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.shift(1788),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            // Shift(1789)-Reduce(69)
            TokenType::LParen => parser.shift(1789),
            TokenType::LSquare => parser.shift(1741),
            TokenType::LCurly => parser.shift(1852),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.shift(1786),
            TokenType::Dot => parser.shift(1785),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(1787),
            TokenType::Tableconstructor => parser.goto(1850),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1330> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(1891),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1331> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1946),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1332> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::Comma => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1333> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Until => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::SemiColon => parser.reduce::<93>(),
            TokenType::Comma => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1334> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.shift(1788),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            // Shift(1789)-Reduce(70)
            TokenType::LParen => parser.shift(1789),
            TokenType::LSquare => parser.shift(1742),
            TokenType::LCurly => parser.shift(1852),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.shift(1799),
            TokenType::Dot => parser.shift(1798),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(1800),
            TokenType::Tableconstructor => parser.goto(1850),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1335> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<93>(),
            TokenType::End => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::SemiColon => parser.reduce::<93>(),
            TokenType::Comma => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1336> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1337> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1338> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1339> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1340> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1341> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(1888),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1342> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1899),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1343> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2017),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1344> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2062),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1345> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1890),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1346> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<95>(),
            TokenType::Do => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::Comma => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1347> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1929),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1348> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1908),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1349> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<95>(),
            TokenType::End => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Comma => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1350> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Until => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Comma => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1351> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1905),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1352> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1903),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1353> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::Comma => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1354> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<94>(),
            TokenType::End => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::SemiColon => parser.reduce::<94>(),
            TokenType::Comma => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1355> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::RParen => parser.reduce::<89>(),
            TokenType::Comma => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1356> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Until => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::SemiColon => parser.reduce::<94>(),
            TokenType::Comma => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1357> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<94>(),
            TokenType::Do => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::Comma => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1358> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1917),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1359> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::Comma => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1360> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1925),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1361> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<93>(),
            TokenType::And => parser.reduce::<93>(),
            TokenType::Break => parser.reduce::<93>(),
            TokenType::Do => parser.reduce::<93>(),
            TokenType::End => parser.reduce::<93>(),
            TokenType::For => parser.reduce::<93>(),
            TokenType::Function => parser.reduce::<93>(),
            TokenType::Goto => parser.reduce::<93>(),
            TokenType::If => parser.reduce::<93>(),
            TokenType::Local => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Repeat => parser.reduce::<93>(),
            TokenType::Return => parser.reduce::<93>(),
            TokenType::While => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::LParen => parser.reduce::<93>(),
            TokenType::DoubleColon => parser.reduce::<93>(),
            TokenType::SemiColon => parser.reduce::<93>(),
            TokenType::Comma => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1362> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::Until => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1363> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<96>(),
            TokenType::Do => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::Comma => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1364> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1926),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1365> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1366> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(1982),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1367> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2019),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1368> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::RParen => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1369> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1906),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1370> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<93>(),
            TokenType::And => parser.reduce::<93>(),
            TokenType::Break => parser.reduce::<93>(),
            TokenType::Do => parser.reduce::<93>(),
            TokenType::For => parser.reduce::<93>(),
            TokenType::Function => parser.reduce::<93>(),
            TokenType::Goto => parser.reduce::<93>(),
            TokenType::If => parser.reduce::<93>(),
            TokenType::Local => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Repeat => parser.reduce::<93>(),
            TokenType::Return => parser.reduce::<93>(),
            TokenType::While => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::LParen => parser.reduce::<93>(),
            TokenType::DoubleColon => parser.reduce::<93>(),
            TokenType::SemiColon => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            TokenType::Eof => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1371> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::RSquare => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1372> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::RSquare => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1373> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Div => parser.shift(784),
            TokenType::Idiv => parser.shift(793),
            TokenType::Mod => parser.shift(810),
            TokenType::Pow => parser.shift(874),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::RParen => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1374> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::RSquare => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1375> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1376> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<96>(),
            TokenType::End => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Comma => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1377> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(1960),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1378> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<93>(),
            TokenType::And => parser.reduce::<93>(),
            TokenType::Break => parser.reduce::<93>(),
            TokenType::Do => parser.reduce::<93>(),
            TokenType::For => parser.reduce::<93>(),
            TokenType::Function => parser.reduce::<93>(),
            TokenType::Goto => parser.reduce::<93>(),
            TokenType::If => parser.reduce::<93>(),
            TokenType::Local => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Repeat => parser.reduce::<93>(),
            TokenType::Return => parser.reduce::<93>(),
            TokenType::Until => parser.reduce::<93>(),
            TokenType::While => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::LParen => parser.reduce::<93>(),
            TokenType::DoubleColon => parser.reduce::<93>(),
            TokenType::SemiColon => parser.reduce::<93>(),
            TokenType::Comma => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1379> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::RSquare => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1380> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::RSquare => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1381> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::RSquare => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1382> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::RSquare => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1383> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2014),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1384> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::RParen => parser.reduce::<92>(),
            TokenType::Comma => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1385> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::RSquare => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1386> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::RSquare => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1387> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::RSquare => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1388> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::RSquare => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1389> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::RSquare => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1390> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Until => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Comma => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1391> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1909),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1392> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::RSquare => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1393> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::RSquare => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1394> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::RSquare => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1395> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1914),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1396> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::RSquare => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1397> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::RSquare => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1398> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2031),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1399> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1895),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1400> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::RSquare => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1401> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::RSquare => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1402> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1922),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1403> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::RParen => parser.reduce::<81>(),
            TokenType::Comma => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1404> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::RCurly => parser.reduce::<97>(),
            TokenType::SemiColon => parser.reduce::<97>(),
            TokenType::Comma => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1405> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::RCurly => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1406> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::RParen => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1407> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::RParen => parser.reduce::<75>(),
            TokenType::Comma => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1408> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::RSquare => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1409> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::RParen => parser.reduce::<86>(),
            TokenType::Comma => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1410> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.shift(638),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.shift(691),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(733),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(758),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(783),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(789),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(796),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(809),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(904),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(928),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(945),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(949),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(956),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(966),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(971),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(975),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::RSquare => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(986),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1411> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::RCurly => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1412> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::RParen => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1413> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::RParen => parser.reduce::<85>(),
            TokenType::Comma => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1414> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::RParen => parser.reduce::<83>(),
            TokenType::Comma => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1415> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::SemiColon => parser.reduce::<97>(),
            TokenType::Comma => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<97>(),
            TokenType::Eof => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1416> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Div => parser.shift(802),
            TokenType::Idiv => parser.shift(852),
            TokenType::Mod => parser.shift(891),
            TokenType::Pow => parser.shift(903),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            TokenType::Eof => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1417> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Div => parser.shift(784),
            TokenType::Idiv => parser.shift(793),
            TokenType::Mod => parser.shift(810),
            TokenType::Pow => parser.shift(874),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::RParen => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1418> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::RParen => parser.reduce::<82>(),
            TokenType::Comma => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1419> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::RCurly => parser.reduce::<91>(),
            TokenType::SemiColon => parser.reduce::<91>(),
            TokenType::Comma => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1420> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::SemiColon => parser.reduce::<84>(),
            TokenType::Comma => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<84>(),
            TokenType::Eof => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1421> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::RParen => parser.reduce::<91>(),
            TokenType::Comma => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1422> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::RCurly => parser.reduce::<89>(),
            TokenType::SemiColon => parser.reduce::<89>(),
            TokenType::Comma => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1423> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1424> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::RParen => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1425> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::RParen => parser.reduce::<97>(),
            TokenType::Comma => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1426> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::RCurly => parser.reduce::<85>(),
            TokenType::SemiColon => parser.reduce::<85>(),
            TokenType::Comma => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1427> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::SemiColon => parser.reduce::<82>(),
            TokenType::Comma => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<82>(),
            TokenType::Eof => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1428> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Div => parser.shift(802),
            TokenType::Idiv => parser.shift(852),
            TokenType::Mod => parser.shift(891),
            TokenType::Pow => parser.shift(903),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            TokenType::Eof => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1429> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::RParen => parser.reduce::<90>(),
            TokenType::Comma => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1430> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::RParen => parser.reduce::<84>(),
            TokenType::Comma => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1431> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::RCurly => parser.reduce::<82>(),
            TokenType::SemiColon => parser.reduce::<82>(),
            TokenType::Comma => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1432> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(596),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.shift(639),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.shift(694),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(734),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(763),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(784),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(793),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(810),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(874),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(896),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(905),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(915),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(927),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(936),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(948),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(954),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(962),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(970),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(974),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(977),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::RParen => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(987),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1433> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::Or => parser.shift(668),
            TokenType::Add => parser.shift(732),
            TokenType::Sub => parser.shift(766),
            TokenType::Mul => parser.shift(786),
            TokenType::Div => parser.shift(799),
            TokenType::Idiv => parser.shift(838),
            TokenType::Mod => parser.shift(890),
            TokenType::Pow => parser.shift(897),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitOr => parser.shift(932),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftR => parser.shift(957),
            TokenType::Eq => parser.shift(963),
            TokenType::Neq => parser.shift(973),
            TokenType::Leq => parser.shift(980),
            TokenType::Geq => parser.shift(988),
            TokenType::Less => parser.shift(991),
            TokenType::Greater => parser.shift(993),
            TokenType::RCurly => parser.reduce::<125>(),
            TokenType::SemiColon => parser.reduce::<125>(),
            TokenType::Comma => parser.reduce::<125>(),
            TokenType::Concat => parser.shift(997),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1434> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Div => parser.shift(799),
            TokenType::Idiv => parser.shift(838),
            TokenType::Mod => parser.shift(890),
            TokenType::Pow => parser.shift(897),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1435> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::RCurly => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1436> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<76>(),
            TokenType::Eof => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1437> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::RCurly => parser.reduce::<90>(),
            TokenType::SemiColon => parser.reduce::<90>(),
            TokenType::Comma => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1438> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Div => parser.shift(799),
            TokenType::Idiv => parser.shift(838),
            TokenType::Mod => parser.shift(890),
            TokenType::Pow => parser.shift(897),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::RCurly => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1439> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1937),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1440> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<78>(),
            TokenType::Eof => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1441> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::SemiColon => parser.reduce::<83>(),
            TokenType::Comma => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<83>(),
            TokenType::Eof => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1442> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::RCurly => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1443> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<80>(),
            TokenType::Eof => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1444> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::SemiColon => parser.reduce::<90>(),
            TokenType::Comma => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<90>(),
            TokenType::Eof => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1445> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::RCurly => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1446> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::SemiColon => parser.reduce::<89>(),
            TokenType::Comma => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<89>(),
            TokenType::Eof => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1447> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1962),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1448> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<73>(),
            TokenType::Eof => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1449> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::SemiColon => parser.reduce::<86>(),
            TokenType::Comma => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<86>(),
            TokenType::Eof => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1450> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::SemiColon => parser.reduce::<85>(),
            TokenType::Comma => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<85>(),
            TokenType::Eof => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1451> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::RCurly => parser.reduce::<84>(),
            TokenType::SemiColon => parser.reduce::<84>(),
            TokenType::Comma => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1452> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::SemiColon => parser.reduce::<91>(),
            TokenType::Comma => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<91>(),
            TokenType::Eof => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1453> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::RCurly => parser.reduce::<81>(),
            TokenType::SemiColon => parser.reduce::<81>(),
            TokenType::Comma => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1454> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::SemiColon => parser.reduce::<75>(),
            TokenType::Comma => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<75>(),
            TokenType::Eof => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1455> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::RCurly => parser.reduce::<83>(),
            TokenType::SemiColon => parser.reduce::<83>(),
            TokenType::Comma => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1456> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<74>(),
            TokenType::Eof => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1457> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::SemiColon => parser.reduce::<81>(),
            TokenType::Comma => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<81>(),
            TokenType::Eof => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1458> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1972),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1459> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::RCurly => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1460> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1932),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1461> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<79>(),
            TokenType::Eof => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1462> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::RCurly => parser.reduce::<92>(),
            TokenType::SemiColon => parser.reduce::<92>(),
            TokenType::Comma => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1463> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<77>(),
            TokenType::Eof => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1464> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2009),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1465> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(604),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Or => parser.shift(670),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Add => parser.shift(728),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(755),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(788),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(802),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(852),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(891),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(903),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(913),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(925),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(942),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(951),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(955),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(961),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(969),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(976),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(981),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(989),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(992),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::SemiColon => parser.reduce::<92>(),
            TokenType::Comma => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(994),
            TokenType::Concat => parser.reduce::<92>(),
            TokenType::Eof => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1466> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::RCurly => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1467> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::RCurly => parser.reduce::<75>(),
            TokenType::SemiColon => parser.reduce::<75>(),
            TokenType::Comma => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1468> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<95>(),
            TokenType::And => parser.reduce::<95>(),
            TokenType::Break => parser.reduce::<95>(),
            TokenType::Do => parser.reduce::<95>(),
            TokenType::For => parser.reduce::<95>(),
            TokenType::Function => parser.reduce::<95>(),
            TokenType::Goto => parser.reduce::<95>(),
            TokenType::If => parser.reduce::<95>(),
            TokenType::Local => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Repeat => parser.reduce::<95>(),
            TokenType::Return => parser.reduce::<95>(),
            TokenType::While => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::LParen => parser.reduce::<95>(),
            TokenType::DoubleColon => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            TokenType::Eof => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1469> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Or => parser.shift(668),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Add => parser.shift(732),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(766),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(786),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(799),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(838),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(890),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(897),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(932),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(957),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(963),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(973),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(980),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(988),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(991),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(993),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::RCurly => parser.reduce::<86>(),
            TokenType::SemiColon => parser.reduce::<86>(),
            TokenType::Comma => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(997),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1470> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2042),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1471> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1896),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1472> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<95>(),
            TokenType::And => parser.reduce::<95>(),
            TokenType::Break => parser.reduce::<95>(),
            TokenType::Do => parser.reduce::<95>(),
            TokenType::End => parser.reduce::<95>(),
            TokenType::For => parser.reduce::<95>(),
            TokenType::Function => parser.reduce::<95>(),
            TokenType::Goto => parser.reduce::<95>(),
            TokenType::If => parser.reduce::<95>(),
            TokenType::Local => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Repeat => parser.reduce::<95>(),
            TokenType::Return => parser.reduce::<95>(),
            TokenType::While => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::LParen => parser.reduce::<95>(),
            TokenType::DoubleColon => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Comma => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1473> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1913),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1474> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(1990),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1475> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<95>(),
            TokenType::And => parser.reduce::<95>(),
            TokenType::Break => parser.reduce::<95>(),
            TokenType::Do => parser.reduce::<95>(),
            TokenType::For => parser.reduce::<95>(),
            TokenType::Function => parser.reduce::<95>(),
            TokenType::Goto => parser.reduce::<95>(),
            TokenType::If => parser.reduce::<95>(),
            TokenType::Local => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Repeat => parser.reduce::<95>(),
            TokenType::Return => parser.reduce::<95>(),
            TokenType::Until => parser.reduce::<95>(),
            TokenType::While => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::LParen => parser.reduce::<95>(),
            TokenType::DoubleColon => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Comma => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1476> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2016),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1477> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1910),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1478> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2022),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1479> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1900),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1480> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1919),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1481> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1902),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1482> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1936),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1483> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<94>(),
            TokenType::And => parser.reduce::<94>(),
            TokenType::Break => parser.reduce::<94>(),
            TokenType::Do => parser.reduce::<94>(),
            TokenType::For => parser.reduce::<94>(),
            TokenType::Function => parser.reduce::<94>(),
            TokenType::Goto => parser.reduce::<94>(),
            TokenType::If => parser.reduce::<94>(),
            TokenType::Local => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Repeat => parser.reduce::<94>(),
            TokenType::Return => parser.reduce::<94>(),
            TokenType::While => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::LParen => parser.reduce::<94>(),
            TokenType::DoubleColon => parser.reduce::<94>(),
            TokenType::SemiColon => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            TokenType::Eof => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1484> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1744),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1485> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1893),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1486> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1745),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1487> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1748),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1488> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2012),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1489> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2033),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1490> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1911),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1491> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1823),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1492> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1805),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1493> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<94>(),
            TokenType::And => parser.reduce::<94>(),
            TokenType::Break => parser.reduce::<94>(),
            TokenType::Do => parser.reduce::<94>(),
            TokenType::End => parser.reduce::<94>(),
            TokenType::For => parser.reduce::<94>(),
            TokenType::Function => parser.reduce::<94>(),
            TokenType::Goto => parser.reduce::<94>(),
            TokenType::If => parser.reduce::<94>(),
            TokenType::Local => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Repeat => parser.reduce::<94>(),
            TokenType::Return => parser.reduce::<94>(),
            TokenType::While => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::LParen => parser.reduce::<94>(),
            TokenType::DoubleColon => parser.reduce::<94>(),
            TokenType::SemiColon => parser.reduce::<94>(),
            TokenType::Comma => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1494> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1804),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1495> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1819),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1496> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2018),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1497> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<121>(),
            TokenType::SemiColon => parser.shift(602),
            TokenType::Comma => parser.shift(603),
            TokenType::FieldlistCont => parser.goto(1830),
            TokenType::Fieldsep => parser.goto(597),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1498> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1803),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1499> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1812),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1500> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1955),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1501> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1963),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1502> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1961),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1503> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2045),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1504> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1806),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1505> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<94>(),
            TokenType::And => parser.reduce::<94>(),
            TokenType::Break => parser.reduce::<94>(),
            TokenType::Do => parser.reduce::<94>(),
            TokenType::For => parser.reduce::<94>(),
            TokenType::Function => parser.reduce::<94>(),
            TokenType::Goto => parser.reduce::<94>(),
            TokenType::If => parser.reduce::<94>(),
            TokenType::Local => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Repeat => parser.reduce::<94>(),
            TokenType::Return => parser.reduce::<94>(),
            TokenType::Until => parser.reduce::<94>(),
            TokenType::While => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::LParen => parser.reduce::<94>(),
            TokenType::DoubleColon => parser.reduce::<94>(),
            TokenType::SemiColon => parser.reduce::<94>(),
            TokenType::Comma => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1506> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1817),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1507> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1815),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1508> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1808),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1509> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1934),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1510> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1807),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1511> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1810),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1512> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1811),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1513> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1809),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1514> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1813),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1515> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2081),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1516> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1822),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1517> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1944),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1518> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1970),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1519> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1981),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1520> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1935),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1521> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2056),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1522> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1941),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1523> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1957),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1524> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1952),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1525> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2023),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1526> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1976),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1527> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<82>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Break => parser.reduce::<82>(),
            TokenType::Do => parser.reduce::<82>(),
            TokenType::For => parser.reduce::<82>(),
            TokenType::Function => parser.reduce::<82>(),
            TokenType::Goto => parser.reduce::<82>(),
            TokenType::If => parser.reduce::<82>(),
            TokenType::Local => parser.reduce::<82>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Repeat => parser.reduce::<82>(),
            TokenType::Return => parser.reduce::<82>(),
            TokenType::While => parser.reduce::<82>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::LParen => parser.reduce::<82>(),
            TokenType::DoubleColon => parser.reduce::<82>(),
            TokenType::SemiColon => parser.reduce::<82>(),
            TokenType::Comma => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<82>(),
            TokenType::Eof => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1528> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<96>(),
            TokenType::And => parser.reduce::<96>(),
            TokenType::Break => parser.reduce::<96>(),
            TokenType::Do => parser.reduce::<96>(),
            TokenType::End => parser.reduce::<96>(),
            TokenType::For => parser.reduce::<96>(),
            TokenType::Function => parser.reduce::<96>(),
            TokenType::Goto => parser.reduce::<96>(),
            TokenType::If => parser.reduce::<96>(),
            TokenType::Local => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Repeat => parser.reduce::<96>(),
            TokenType::Return => parser.reduce::<96>(),
            TokenType::While => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::LParen => parser.reduce::<96>(),
            TokenType::DoubleColon => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Comma => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1529> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<96>(),
            TokenType::And => parser.reduce::<96>(),
            TokenType::Break => parser.reduce::<96>(),
            TokenType::Do => parser.reduce::<96>(),
            TokenType::For => parser.reduce::<96>(),
            TokenType::Function => parser.reduce::<96>(),
            TokenType::Goto => parser.reduce::<96>(),
            TokenType::If => parser.reduce::<96>(),
            TokenType::Local => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Repeat => parser.reduce::<96>(),
            TokenType::Return => parser.reduce::<96>(),
            TokenType::While => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::LParen => parser.reduce::<96>(),
            TokenType::DoubleColon => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            TokenType::Eof => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1530> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<96>(),
            TokenType::And => parser.reduce::<96>(),
            TokenType::Break => parser.reduce::<96>(),
            TokenType::Do => parser.reduce::<96>(),
            TokenType::For => parser.reduce::<96>(),
            TokenType::Function => parser.reduce::<96>(),
            TokenType::Goto => parser.reduce::<96>(),
            TokenType::If => parser.reduce::<96>(),
            TokenType::Local => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Repeat => parser.reduce::<96>(),
            TokenType::Return => parser.reduce::<96>(),
            TokenType::Until => parser.reduce::<96>(),
            TokenType::While => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::LParen => parser.reduce::<96>(),
            TokenType::DoubleColon => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Comma => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1531> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1943),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1532> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2041),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1533> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::End => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1534> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1945),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1535> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::Until => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1536> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<77>(),
            TokenType::Eof => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1537> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<89>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Break => parser.reduce::<89>(),
            TokenType::Do => parser.reduce::<89>(),
            TokenType::For => parser.reduce::<89>(),
            TokenType::Function => parser.reduce::<89>(),
            TokenType::Goto => parser.reduce::<89>(),
            TokenType::If => parser.reduce::<89>(),
            TokenType::Local => parser.reduce::<89>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Repeat => parser.reduce::<89>(),
            TokenType::Return => parser.reduce::<89>(),
            TokenType::While => parser.reduce::<89>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::LParen => parser.reduce::<89>(),
            TokenType::DoubleColon => parser.reduce::<89>(),
            TokenType::SemiColon => parser.reduce::<89>(),
            TokenType::Comma => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<89>(),
            TokenType::Eof => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1538> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<97>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Break => parser.reduce::<97>(),
            TokenType::Do => parser.reduce::<97>(),
            TokenType::For => parser.reduce::<97>(),
            TokenType::Function => parser.reduce::<97>(),
            TokenType::Goto => parser.reduce::<97>(),
            TokenType::If => parser.reduce::<97>(),
            TokenType::Local => parser.reduce::<97>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Repeat => parser.reduce::<97>(),
            TokenType::Return => parser.reduce::<97>(),
            TokenType::While => parser.reduce::<97>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::LParen => parser.reduce::<97>(),
            TokenType::DoubleColon => parser.reduce::<97>(),
            TokenType::SemiColon => parser.reduce::<97>(),
            TokenType::Comma => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<97>(),
            TokenType::Eof => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1539> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1973),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1540> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<74>(),
            TokenType::Eof => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1541> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<90>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Break => parser.reduce::<90>(),
            TokenType::Do => parser.reduce::<90>(),
            TokenType::For => parser.reduce::<90>(),
            TokenType::Function => parser.reduce::<90>(),
            TokenType::Goto => parser.reduce::<90>(),
            TokenType::If => parser.reduce::<90>(),
            TokenType::Local => parser.reduce::<90>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Repeat => parser.reduce::<90>(),
            TokenType::Return => parser.reduce::<90>(),
            TokenType::While => parser.reduce::<90>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::LParen => parser.reduce::<90>(),
            TokenType::DoubleColon => parser.reduce::<90>(),
            TokenType::SemiColon => parser.reduce::<90>(),
            TokenType::Comma => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<90>(),
            TokenType::Eof => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1542> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<92>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Break => parser.reduce::<92>(),
            TokenType::Do => parser.reduce::<92>(),
            TokenType::For => parser.reduce::<92>(),
            TokenType::Function => parser.reduce::<92>(),
            TokenType::Goto => parser.reduce::<92>(),
            TokenType::If => parser.reduce::<92>(),
            TokenType::Local => parser.reduce::<92>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Repeat => parser.reduce::<92>(),
            TokenType::Return => parser.reduce::<92>(),
            TokenType::While => parser.reduce::<92>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::LParen => parser.reduce::<92>(),
            TokenType::DoubleColon => parser.reduce::<92>(),
            TokenType::SemiColon => parser.reduce::<92>(),
            TokenType::Comma => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<92>(),
            TokenType::Eof => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1543> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1958),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1544> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<78>(),
            TokenType::Eof => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1545> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<86>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Break => parser.reduce::<86>(),
            TokenType::Do => parser.reduce::<86>(),
            TokenType::For => parser.reduce::<86>(),
            TokenType::Function => parser.reduce::<86>(),
            TokenType::Goto => parser.reduce::<86>(),
            TokenType::If => parser.reduce::<86>(),
            TokenType::Local => parser.reduce::<86>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Repeat => parser.reduce::<86>(),
            TokenType::Return => parser.reduce::<86>(),
            TokenType::While => parser.reduce::<86>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::LParen => parser.reduce::<86>(),
            TokenType::DoubleColon => parser.reduce::<86>(),
            TokenType::SemiColon => parser.reduce::<86>(),
            TokenType::Comma => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<86>(),
            TokenType::Eof => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1546> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Div => parser.shift(959),
            TokenType::Idiv => parser.shift(972),
            TokenType::Mod => parser.shift(990),
            TokenType::Pow => parser.shift(1000),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            TokenType::Eof => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1547> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1918),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1548> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Div => parser.shift(959),
            TokenType::Idiv => parser.shift(972),
            TokenType::Mod => parser.shift(990),
            TokenType::Pow => parser.shift(1000),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            TokenType::Eof => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1549> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<85>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Break => parser.reduce::<85>(),
            TokenType::Do => parser.reduce::<85>(),
            TokenType::For => parser.reduce::<85>(),
            TokenType::Function => parser.reduce::<85>(),
            TokenType::Goto => parser.reduce::<85>(),
            TokenType::If => parser.reduce::<85>(),
            TokenType::Local => parser.reduce::<85>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Repeat => parser.reduce::<85>(),
            TokenType::Return => parser.reduce::<85>(),
            TokenType::While => parser.reduce::<85>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::LParen => parser.reduce::<85>(),
            TokenType::DoubleColon => parser.reduce::<85>(),
            TokenType::SemiColon => parser.reduce::<85>(),
            TokenType::Comma => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<85>(),
            TokenType::Eof => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1550> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1551> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1552> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::Until => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1553> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::Until => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1554> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<91>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Break => parser.reduce::<91>(),
            TokenType::Do => parser.reduce::<91>(),
            TokenType::For => parser.reduce::<91>(),
            TokenType::Function => parser.reduce::<91>(),
            TokenType::Goto => parser.reduce::<91>(),
            TokenType::If => parser.reduce::<91>(),
            TokenType::Local => parser.reduce::<91>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Repeat => parser.reduce::<91>(),
            TokenType::Return => parser.reduce::<91>(),
            TokenType::While => parser.reduce::<91>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::LParen => parser.reduce::<91>(),
            TokenType::DoubleColon => parser.reduce::<91>(),
            TokenType::SemiColon => parser.reduce::<91>(),
            TokenType::Comma => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<91>(),
            TokenType::Eof => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1555> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<76>(),
            TokenType::Eof => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1556> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2059),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1557> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1950),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1558> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<79>(),
            TokenType::Eof => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1559> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<84>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Break => parser.reduce::<84>(),
            TokenType::Do => parser.reduce::<84>(),
            TokenType::For => parser.reduce::<84>(),
            TokenType::Function => parser.reduce::<84>(),
            TokenType::Goto => parser.reduce::<84>(),
            TokenType::If => parser.reduce::<84>(),
            TokenType::Local => parser.reduce::<84>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Repeat => parser.reduce::<84>(),
            TokenType::Return => parser.reduce::<84>(),
            TokenType::While => parser.reduce::<84>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::LParen => parser.reduce::<84>(),
            TokenType::DoubleColon => parser.reduce::<84>(),
            TokenType::SemiColon => parser.reduce::<84>(),
            TokenType::Comma => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<84>(),
            TokenType::Eof => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1560> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<75>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Break => parser.reduce::<75>(),
            TokenType::Do => parser.reduce::<75>(),
            TokenType::For => parser.reduce::<75>(),
            TokenType::Function => parser.reduce::<75>(),
            TokenType::Goto => parser.reduce::<75>(),
            TokenType::If => parser.reduce::<75>(),
            TokenType::Local => parser.reduce::<75>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Repeat => parser.reduce::<75>(),
            TokenType::Return => parser.reduce::<75>(),
            TokenType::While => parser.reduce::<75>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::LParen => parser.reduce::<75>(),
            TokenType::DoubleColon => parser.reduce::<75>(),
            TokenType::SemiColon => parser.reduce::<75>(),
            TokenType::Comma => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<75>(),
            TokenType::Eof => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1561> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2070),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1562> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<73>(),
            TokenType::Eof => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1563> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1968),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1564> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<80>(),
            TokenType::Eof => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1565> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<83>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Break => parser.reduce::<83>(),
            TokenType::Do => parser.reduce::<83>(),
            TokenType::For => parser.reduce::<83>(),
            TokenType::Function => parser.reduce::<83>(),
            TokenType::Goto => parser.reduce::<83>(),
            TokenType::If => parser.reduce::<83>(),
            TokenType::Local => parser.reduce::<83>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Repeat => parser.reduce::<83>(),
            TokenType::Return => parser.reduce::<83>(),
            TokenType::While => parser.reduce::<83>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::LParen => parser.reduce::<83>(),
            TokenType::DoubleColon => parser.reduce::<83>(),
            TokenType::SemiColon => parser.reduce::<83>(),
            TokenType::Comma => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<83>(),
            TokenType::Eof => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1566> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<81>(),
            TokenType::And => parser.shift(669),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Break => parser.reduce::<81>(),
            TokenType::Do => parser.reduce::<81>(),
            TokenType::For => parser.reduce::<81>(),
            TokenType::Function => parser.reduce::<81>(),
            TokenType::Goto => parser.reduce::<81>(),
            TokenType::If => parser.reduce::<81>(),
            TokenType::Local => parser.reduce::<81>(),
            TokenType::Or => parser.shift(770),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Repeat => parser.reduce::<81>(),
            TokenType::Return => parser.reduce::<81>(),
            TokenType::While => parser.reduce::<81>(),
            TokenType::Add => parser.shift(831),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(909),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(939),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(959),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(972),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(990),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(1000),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(1001),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(1002),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(1003),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(1004),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(1005),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(1006),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(1007),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(1008),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(1009),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(1010),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(1011),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::LParen => parser.reduce::<81>(),
            TokenType::DoubleColon => parser.reduce::<81>(),
            TokenType::SemiColon => parser.reduce::<81>(),
            TokenType::Comma => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(1012),
            TokenType::Concat => parser.reduce::<81>(),
            TokenType::Eof => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1567> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1953),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1568> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1959),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1569> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1939),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1570> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1964),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1571> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2071),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1572> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1942),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1573> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1975),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1574> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2047),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1575> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1949),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1576> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1977),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1577> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1940),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1578> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1965),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1579> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2076),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1580> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1978),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1581> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1966),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1582> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1951),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1583> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(1930),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1584> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1821),
            TokenType::Funcbody => parser.goto(1820),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1585> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(2008),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1586> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1816),
            TokenType::Funcbody => parser.goto(1814),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1587> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(2011),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1588> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2027),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1589> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1954),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1590> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1974),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1591> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(1824),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1592> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2079),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1593> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2054),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1594> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1971),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1595> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1986),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1596> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(1967),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1597> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(489),
            TokenType::String(_) => parser.shift(723),
            TokenType::Integer(_) => parser.shift(724),
            TokenType::Float(_) => parser.shift(725),
            TokenType::False => parser.shift(726),
            TokenType::Function => parser.shift(946),
            TokenType::Nil => parser.shift(727),
            TokenType::Not => parser.shift(729),
            TokenType::True => parser.shift(745),
            TokenType::Sub => parser.shift(747),
            TokenType::Len => parser.shift(787),
            TokenType::BitXor => parser.shift(803),
            TokenType::LParen => parser.shift(522),
            TokenType::LCurly => parser.shift(947),
            TokenType::Dots => parser.shift(895),
            TokenType::Var => parser.goto(719),
            TokenType::Exp => parser.goto(1969),
            TokenType::Functioncall => parser.goto(720),
            TokenType::Functiondef => parser.goto(901),
            TokenType::Tableconstructor => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1598> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(492),
            TokenType::String(_) => parser.shift(700),
            TokenType::Integer(_) => parser.shift(701),
            TokenType::Float(_) => parser.shift(702),
            TokenType::False => parser.shift(703),
            TokenType::Function => parser.shift(933),
            TokenType::Nil => parser.shift(704),
            TokenType::Not => parser.shift(716),
            TokenType::True => parser.shift(741),
            TokenType::Sub => parser.shift(743),
            TokenType::Len => parser.shift(780),
            TokenType::BitXor => parser.shift(797),
            TokenType::LParen => parser.shift(526),
            TokenType::LCurly => parser.shift(935),
            TokenType::Dots => parser.shift(886),
            TokenType::Var => parser.goto(692),
            TokenType::Exp => parser.goto(1947),
            TokenType::Functioncall => parser.goto(696),
            TokenType::Functiondef => parser.goto(899),
            TokenType::Tableconstructor => parser.goto(900),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1599> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2069),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1600> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2051),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1601> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2030),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1602> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2039),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1603> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2067),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1604> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2024),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1605> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2040),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1606> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2061),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1607> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2037),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1608> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2066),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1609> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2073),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1610> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2049),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1611> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2068),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1612> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2035),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1613> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2055),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1614> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2077),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1615> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2064),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1616> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2078),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1617> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2048),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1618> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2044),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1619> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2032),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1620> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2080),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1621> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2050),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1622> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2028),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1623> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2065),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1624> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2052),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1625> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2029),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1626> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2057),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1627> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2074),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1628> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2053),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1629> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2072),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1630> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2063),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1631> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(507),
            TokenType::String(_) => parser.shift(773),
            TokenType::Integer(_) => parser.shift(774),
            TokenType::Float(_) => parser.shift(775),
            TokenType::False => parser.shift(776),
            TokenType::Function => parser.shift(998),
            TokenType::Nil => parser.shift(777),
            TokenType::Not => parser.shift(779),
            TokenType::True => parser.shift(850),
            TokenType::Sub => parser.shift(858),
            TokenType::Len => parser.shift(906),
            TokenType::BitXor => parser.shift(941),
            TokenType::LParen => parser.shift(530),
            TokenType::LCurly => parser.shift(999),
            TokenType::Dots => parser.shift(967),
            TokenType::Var => parser.goto(759),
            TokenType::Exp => parser.goto(2025),
            TokenType::Functioncall => parser.goto(769),
            TokenType::Functiondef => parser.goto(982),
            TokenType::Tableconstructor => parser.goto(983),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1632> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(750),
            TokenType::Integer(_) => parser.shift(751),
            TokenType::Float(_) => parser.shift(752),
            TokenType::False => parser.shift(753),
            TokenType::Function => parser.shift(984),
            TokenType::Nil => parser.shift(754),
            TokenType::Not => parser.shift(756),
            TokenType::True => parser.shift(808),
            TokenType::Sub => parser.shift(812),
            TokenType::Len => parser.shift(898),
            TokenType::BitXor => parser.shift(940),
            TokenType::LParen => parser.shift(552),
            TokenType::LCurly => parser.shift(985),
            TokenType::Dots => parser.shift(960),
            TokenType::Var => parser.goto(742),
            TokenType::Exp => parser.goto(2036),
            TokenType::Functioncall => parser.goto(749),
            TokenType::Functiondef => parser.goto(964),
            TokenType::Tableconstructor => parser.goto(965),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1633> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(513),
            TokenType::String(_) => parser.shift(760),
            TokenType::Integer(_) => parser.shift(761),
            TokenType::Float(_) => parser.shift(762),
            TokenType::False => parser.shift(764),
            TokenType::Function => parser.shift(995),
            TokenType::Nil => parser.shift(765),
            TokenType::Not => parser.shift(767),
            TokenType::True => parser.shift(832),
            TokenType::Sub => parser.shift(841),
            TokenType::Len => parser.shift(907),
            TokenType::BitXor => parser.shift(944),
            TokenType::LParen => parser.shift(537),
            TokenType::LCurly => parser.shift(996),
            TokenType::Dots => parser.shift(968),
            TokenType::Var => parser.goto(740),
            TokenType::Exp => parser.goto(2046),
            TokenType::Functioncall => parser.goto(746),
            TokenType::Functiondef => parser.goto(978),
            TokenType::Tableconstructor => parser.goto(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1634> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<115>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1635> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(474),
            TokenType::Eof => parser.reduce::<30>(),
            TokenType::AttnamelistCont => parser.goto(2121),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1636> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<33>(),
            TokenType::Break => parser.reduce::<33>(),
            TokenType::Do => parser.reduce::<33>(),
            TokenType::For => parser.reduce::<33>(),
            TokenType::Function => parser.reduce::<33>(),
            TokenType::Goto => parser.reduce::<33>(),
            TokenType::If => parser.reduce::<33>(),
            TokenType::Local => parser.reduce::<33>(),
            TokenType::Repeat => parser.reduce::<33>(),
            TokenType::Return => parser.reduce::<33>(),
            TokenType::Until => parser.reduce::<33>(),
            TokenType::While => parser.reduce::<33>(),
            TokenType::Assign => parser.reduce::<33>(),
            TokenType::LParen => parser.reduce::<33>(),
            TokenType::DoubleColon => parser.reduce::<33>(),
            TokenType::SemiColon => parser.reduce::<33>(),
            TokenType::Comma => parser.reduce::<33>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1637> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<56>(),
            TokenType::Comma => parser.shift(1023),
            TokenType::Comma => parser.reduce::<56>(),
            TokenType::NamelistCont => parser.goto(2114),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1638> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::Until => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(496),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(2113),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1639> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<33>(),
            TokenType::Break => parser.reduce::<33>(),
            TokenType::Do => parser.reduce::<33>(),
            TokenType::End => parser.reduce::<33>(),
            TokenType::For => parser.reduce::<33>(),
            TokenType::Function => parser.reduce::<33>(),
            TokenType::Goto => parser.reduce::<33>(),
            TokenType::If => parser.reduce::<33>(),
            TokenType::Local => parser.reduce::<33>(),
            TokenType::Repeat => parser.reduce::<33>(),
            TokenType::Return => parser.reduce::<33>(),
            TokenType::While => parser.reduce::<33>(),
            TokenType::Assign => parser.reduce::<33>(),
            TokenType::LParen => parser.reduce::<33>(),
            TokenType::DoubleColon => parser.reduce::<33>(),
            TokenType::SemiColon => parser.reduce::<33>(),
            TokenType::Comma => parser.reduce::<33>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1640> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::End => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(510),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(2112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1641> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<24>(),
            TokenType::Break => parser.reduce::<24>(),
            TokenType::Do => parser.reduce::<24>(),
            TokenType::Else => parser.reduce::<24>(),
            TokenType::Elseif => parser.reduce::<24>(),
            TokenType::End => parser.reduce::<24>(),
            TokenType::For => parser.reduce::<24>(),
            TokenType::Function => parser.reduce::<24>(),
            TokenType::Goto => parser.reduce::<24>(),
            TokenType::If => parser.reduce::<24>(),
            TokenType::Local => parser.reduce::<24>(),
            TokenType::Repeat => parser.reduce::<24>(),
            TokenType::Return => parser.reduce::<24>(),
            TokenType::While => parser.reduce::<24>(),
            TokenType::LParen => parser.reduce::<24>(),
            TokenType::DoubleColon => parser.reduce::<24>(),
            TokenType::SemiColon => parser.reduce::<24>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1642> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(2115),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1643> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1644> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<103>(),
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::Break => parser.reduce::<103>(),
            TokenType::Do => parser.reduce::<103>(),
            TokenType::For => parser.reduce::<103>(),
            TokenType::Function => parser.reduce::<103>(),
            TokenType::Goto => parser.reduce::<103>(),
            TokenType::If => parser.reduce::<103>(),
            TokenType::Local => parser.reduce::<103>(),
            TokenType::Repeat => parser.reduce::<103>(),
            TokenType::Return => parser.reduce::<103>(),
            TokenType::While => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::DoubleColon => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Eof => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1645> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::Do => parser.reduce::<21>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Add => parser.shift(1299),
            TokenType::Sub => parser.shift(1316),
            TokenType::Mul => parser.shift(1342),
            TokenType::Div => parser.shift(1351),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Mod => parser.shift(1402),
            TokenType::Pow => parser.shift(1460),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitOr => parser.shift(1500),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::Eq => parser.shift(1534),
            TokenType::Neq => parser.shift(1557),
            TokenType::Leq => parser.shift(1569),
            TokenType::Geq => parser.shift(1575),
            TokenType::Less => parser.shift(1582),
            TokenType::Greater => parser.shift(1589),
            TokenType::Comma => parser.shift(2143),
            TokenType::Concat => parser.shift(1596),
            TokenType::StatForexp => parser.goto(2118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1646> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<37>(),
            TokenType::Elseif => parser.reduce::<37>(),
            TokenType::End => parser.reduce::<37>(),
            TokenType::SemiColon => parser.shift(2120),
            TokenType::RetstatEnd => parser.goto(2117),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1647> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2116),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1648> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1649> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1642),
            TokenType::Funcbody => parser.goto(2119),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1650> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2314),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1651> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2313),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1652> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<36>(),
            TokenType::Elseif => parser.reduce::<36>(),
            TokenType::End => parser.reduce::<36>(),
            TokenType::SemiColon => parser.reduce::<36>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1653> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Else => parser.reduce::<48>(),
            TokenType::Elseif => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1654> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2237),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1655> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2202),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1656> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2321),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1657> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2311),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1658> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2273),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1659> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(511),
            TokenType::Do => parser.shift(517),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(532),
            TokenType::Function => parser.shift(533),
            TokenType::Goto => parser.shift(535),
            TokenType::If => parser.shift(551),
            TokenType::Local => parser.shift(615),
            TokenType::Repeat => parser.shift(616),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(618),
            TokenType::LParen => parser.shift(652),
            TokenType::DoubleColon => parser.shift(648),
            TokenType::SemiColon => parser.shift(644),
            TokenType::Block => parser.goto(2255),
            TokenType::BlockStat => parser.goto(466),
            TokenType::Stat => parser.goto(498),
            TokenType::Label => parser.goto(645),
            TokenType::Varlist => parser.goto(646),
            TokenType::Var => parser.goto(650),
            TokenType::Functioncall => parser.goto(647),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1660> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2275),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1661> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2316),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1662> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::RSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1663> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<39>(),
            TokenType::Break => parser.reduce::<39>(),
            TokenType::Do => parser.reduce::<39>(),
            TokenType::Else => parser.reduce::<39>(),
            TokenType::Elseif => parser.reduce::<39>(),
            TokenType::End => parser.reduce::<39>(),
            TokenType::For => parser.reduce::<39>(),
            TokenType::Function => parser.reduce::<39>(),
            TokenType::Goto => parser.reduce::<39>(),
            TokenType::If => parser.reduce::<39>(),
            TokenType::Local => parser.reduce::<39>(),
            TokenType::Repeat => parser.reduce::<39>(),
            TokenType::Return => parser.reduce::<39>(),
            TokenType::While => parser.reduce::<39>(),
            TokenType::LParen => parser.reduce::<39>(),
            TokenType::DoubleColon => parser.reduce::<39>(),
            TokenType::SemiColon => parser.reduce::<39>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1664> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<101>(),
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Break => parser.reduce::<101>(),
            TokenType::Do => parser.reduce::<101>(),
            TokenType::For => parser.reduce::<101>(),
            TokenType::Function => parser.reduce::<101>(),
            TokenType::Goto => parser.reduce::<101>(),
            TokenType::If => parser.reduce::<101>(),
            TokenType::Local => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Repeat => parser.reduce::<101>(),
            TokenType::Return => parser.reduce::<101>(),
            TokenType::While => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::DoubleColon => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Comma => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            TokenType::Eof => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1665> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::Else => parser.reduce::<30>(),
            TokenType::Elseif => parser.reduce::<30>(),
            TokenType::End => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(2125),
            TokenType::AttnamelistCont => parser.goto(2122),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1666> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(2126),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1667> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Explist => parser.goto(2124),
            TokenType::Exp => parser.goto(710),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1668> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2123),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1669> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Comma => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            TokenType::Eof => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1670> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::RCurly => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Comma => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1671> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::RSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1672> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::RCurly => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Comma => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1673> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::RParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Comma => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1674> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Comma => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            TokenType::Eof => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1675> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2134),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1676> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2141),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1677> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2131),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1678> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1679> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<102>(),
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Break => parser.reduce::<102>(),
            TokenType::Do => parser.reduce::<102>(),
            TokenType::For => parser.reduce::<102>(),
            TokenType::Function => parser.reduce::<102>(),
            TokenType::Goto => parser.reduce::<102>(),
            TokenType::If => parser.reduce::<102>(),
            TokenType::Local => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Repeat => parser.reduce::<102>(),
            TokenType::Return => parser.reduce::<102>(),
            TokenType::While => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::DoubleColon => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Comma => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            TokenType::Eof => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1680> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::RParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Comma => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1681> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<26>(),
            TokenType::Break => parser.reduce::<26>(),
            TokenType::Do => parser.reduce::<26>(),
            TokenType::Else => parser.reduce::<26>(),
            TokenType::Elseif => parser.reduce::<26>(),
            TokenType::End => parser.reduce::<26>(),
            TokenType::For => parser.reduce::<26>(),
            TokenType::Function => parser.reduce::<26>(),
            TokenType::Goto => parser.reduce::<26>(),
            TokenType::If => parser.reduce::<26>(),
            TokenType::Local => parser.reduce::<26>(),
            TokenType::Repeat => parser.reduce::<26>(),
            TokenType::Return => parser.reduce::<26>(),
            TokenType::While => parser.reduce::<26>(),
            TokenType::LParen => parser.reduce::<26>(),
            TokenType::DoubleColon => parser.reduce::<26>(),
            TokenType::SemiColon => parser.reduce::<26>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1682> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(217),
            TokenType::Or => parser.shift(281),
            TokenType::Then => parser.shift(2137),
            TokenType::Add => parser.shift(328),
            TokenType::Sub => parser.shift(337),
            TokenType::Mul => parser.shift(356),
            TokenType::Div => parser.shift(365),
            TokenType::Idiv => parser.shift(370),
            TokenType::Mod => parser.shift(376),
            TokenType::Pow => parser.shift(385),
            TokenType::BitAnd => parser.shift(390),
            TokenType::BitXor => parser.shift(394),
            TokenType::BitOr => parser.shift(402),
            TokenType::ShiftL => parser.shift(413),
            TokenType::ShiftR => parser.shift(418),
            TokenType::Eq => parser.shift(424),
            TokenType::Neq => parser.shift(428),
            TokenType::Leq => parser.shift(433),
            TokenType::Geq => parser.shift(436),
            TokenType::Less => parser.shift(439),
            TokenType::Greater => parser.shift(443),
            TokenType::Concat => parser.shift(448),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1683> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1159),
            TokenType::LParen => parser.shift(1188),
            TokenType::LCurly => parser.shift(1239),
            TokenType::Args => parser.goto(2127),
            TokenType::Tableconstructor => parser.goto(1231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1684> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(2262),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1685> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<7>(),
            TokenType::Break => parser.reduce::<7>(),
            TokenType::Do => parser.reduce::<7>(),
            TokenType::Else => parser.reduce::<7>(),
            TokenType::Elseif => parser.reduce::<7>(),
            TokenType::End => parser.reduce::<7>(),
            TokenType::For => parser.reduce::<7>(),
            TokenType::Function => parser.reduce::<7>(),
            TokenType::Goto => parser.reduce::<7>(),
            TokenType::If => parser.reduce::<7>(),
            TokenType::Local => parser.reduce::<7>(),
            TokenType::Repeat => parser.reduce::<7>(),
            TokenType::Return => parser.reduce::<7>(),
            TokenType::While => parser.reduce::<7>(),
            TokenType::LParen => parser.reduce::<7>(),
            TokenType::DoubleColon => parser.reduce::<7>(),
            TokenType::SemiColon => parser.reduce::<7>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1686> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(504),
            TokenType::String(_) => parser.shift(705),
            TokenType::Integer(_) => parser.shift(706),
            TokenType::Float(_) => parser.shift(707),
            TokenType::False => parser.shift(708),
            TokenType::Function => parser.shift(920),
            TokenType::Nil => parser.shift(709),
            TokenType::Not => parser.shift(717),
            TokenType::True => parser.shift(738),
            TokenType::Sub => parser.shift(739),
            TokenType::Len => parser.shift(781),
            TokenType::BitXor => parser.shift(795),
            TokenType::LParen => parser.shift(534),
            TokenType::LCurly => parser.shift(921),
            TokenType::Dots => parser.shift(877),
            TokenType::Var => parser.goto(693),
            TokenType::Exp => parser.goto(2129),
            TokenType::Functioncall => parser.goto(697),
            TokenType::Functiondef => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(893),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1687> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2319),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1688> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(240),
            TokenType::LParen => parser.shift(241),
            TokenType::LCurly => parser.shift(270),
            TokenType::Args => parser.goto(2128),
            TokenType::Tableconstructor => parser.goto(268),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1689> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2138),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1690> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(2132),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1691> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2288),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1692> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(224),
            TokenType::LParen => parser.shift(225),
            TokenType::LCurly => parser.shift(248),
            TokenType::Args => parser.goto(2130),
            TokenType::Tableconstructor => parser.goto(247),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1693> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2283),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1694> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2364),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1695> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2373),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1696> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::Else => parser.reduce::<48>(),
            TokenType::Elseif => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1697> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1159),
            TokenType::LParen => parser.shift(1188),
            TokenType::LCurly => parser.shift(1239),
            TokenType::Args => parser.goto(2142),
            TokenType::Tableconstructor => parser.goto(1231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1698> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.shift(1660),
            TokenType::End => parser.reduce::<18>(),
            TokenType::StatElse => parser.goto(2136),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1699> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1700> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2266),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1701> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1202),
            TokenType::LParen => parser.shift(1205),
            TokenType::LCurly => parser.shift(1292),
            TokenType::Args => parser.goto(2133),
            TokenType::Tableconstructor => parser.goto(1289),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1702> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.shift(1262),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            // Shift(1264)-Reduce(71)
            TokenType::LParen => parser.shift(1264),
            TokenType::LSquare => parser.shift(2170),
            TokenType::LCurly => parser.shift(1309),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.shift(2285),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.shift(2284),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(2286),
            TokenType::Tableconstructor => parser.goto(1308),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1703> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2287),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1704> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2320),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1705> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2139),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1706> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1221),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.shift(1223),
            TokenType::LSquare => parser.shift(2228),
            TokenType::LCurly => parser.shift(1288),
            TokenType::Colon => parser.shift(2277),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.shift(2276),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(2278),
            TokenType::Tableconstructor => parser.goto(1287),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1707> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::RSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1708> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Until => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::SemiColon => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Comma => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1709> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1204),
            TokenType::LParen => parser.shift(1206),
            TokenType::LCurly => parser.shift(1285),
            TokenType::Args => parser.goto(2145),
            TokenType::Tableconstructor => parser.goto(1284),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1710> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2274),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1711> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<53>(),
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Break => parser.reduce::<53>(),
            TokenType::Do => parser.reduce::<53>(),
            TokenType::For => parser.reduce::<53>(),
            TokenType::Function => parser.reduce::<53>(),
            TokenType::Goto => parser.reduce::<53>(),
            TokenType::If => parser.reduce::<53>(),
            TokenType::Local => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Repeat => parser.reduce::<53>(),
            TokenType::Return => parser.reduce::<53>(),
            TokenType::While => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::DoubleColon => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            TokenType::Eof => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1712> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Until => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Comma => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1713> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1204),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.shift(1206),
            TokenType::LSquare => parser.shift(2207),
            TokenType::LCurly => parser.shift(1285),
            TokenType::Colon => parser.shift(2263),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.shift(2257),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(2264),
            TokenType::Tableconstructor => parser.goto(1284),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1714> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.shift(1269),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::Until => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            // Shift(1278)-Reduce(71)
            TokenType::LParen => parser.shift(1278),
            TokenType::LSquare => parser.shift(2233),
            TokenType::LCurly => parser.shift(1312),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.shift(2295),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.shift(2291),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(2297),
            TokenType::Tableconstructor => parser.goto(1310),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1715> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::Assign => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Comma => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1716> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1241),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Until => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.shift(1248),
            TokenType::LSquare => parser.shift(2182),
            TokenType::LCurly => parser.shift(1294),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.shift(2281),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.shift(2280),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(2282),
            TokenType::Tableconstructor => parser.goto(1293),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1717> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            TokenType::Eof => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1718> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::RCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1719> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::RCurly => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1720> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(253),
            TokenType::LParen => parser.shift(258),
            TokenType::LCurly => parser.shift(286),
            TokenType::Args => parser.goto(2144),
            TokenType::Tableconstructor => parser.goto(285),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1721> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.shift(1202),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            // Shift(1205)-Reduce(71)
            TokenType::LParen => parser.shift(1205),
            TokenType::LSquare => parser.shift(2236),
            TokenType::LCurly => parser.shift(1292),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.shift(2293),
            TokenType::Dot => parser.shift(2292),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Eof => parser.reduce::<71>(),
            TokenType::Args => parser.goto(2298),
            TokenType::Tableconstructor => parser.goto(1289),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1722> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.shift(1660),
            TokenType::End => parser.reduce::<18>(),
            TokenType::StatElse => parser.goto(2150),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1723> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1262),
            TokenType::LParen => parser.shift(1264),
            TokenType::LCurly => parser.shift(1309),
            TokenType::Args => parser.goto(2147),
            TokenType::Tableconstructor => parser.goto(1308),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1724> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Do => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Comma => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1725> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1202),
            TokenType::LParen => parser.shift(1205),
            TokenType::LCurly => parser.shift(1292),
            TokenType::Args => parser.goto(2146),
            TokenType::Tableconstructor => parser.goto(1289),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1726> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<12>(),
            TokenType::Break => parser.reduce::<12>(),
            TokenType::Do => parser.reduce::<12>(),
            TokenType::Else => parser.reduce::<12>(),
            TokenType::Elseif => parser.reduce::<12>(),
            TokenType::End => parser.reduce::<12>(),
            TokenType::For => parser.reduce::<12>(),
            TokenType::Function => parser.reduce::<12>(),
            TokenType::Goto => parser.reduce::<12>(),
            TokenType::If => parser.reduce::<12>(),
            TokenType::Local => parser.reduce::<12>(),
            TokenType::Repeat => parser.reduce::<12>(),
            TokenType::Return => parser.reduce::<12>(),
            TokenType::While => parser.reduce::<12>(),
            TokenType::LParen => parser.reduce::<12>(),
            TokenType::DoubleColon => parser.reduce::<12>(),
            TokenType::SemiColon => parser.reduce::<12>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1727> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            TokenType::Eof => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1728> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::RParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1729> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::End => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Comma => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1730> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1241),
            TokenType::LParen => parser.shift(1248),
            TokenType::LCurly => parser.shift(1294),
            TokenType::Args => parser.goto(2148),
            TokenType::Tableconstructor => parser.goto(1293),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1731> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Comma => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1732> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1733> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<53>(),
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Break => parser.reduce::<53>(),
            TokenType::Do => parser.reduce::<53>(),
            TokenType::End => parser.reduce::<53>(),
            TokenType::For => parser.reduce::<53>(),
            TokenType::Function => parser.reduce::<53>(),
            TokenType::Goto => parser.reduce::<53>(),
            TokenType::If => parser.reduce::<53>(),
            TokenType::Local => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Repeat => parser.reduce::<53>(),
            TokenType::Return => parser.reduce::<53>(),
            TokenType::While => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::DoubleColon => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Comma => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1734> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1735> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1204),
            TokenType::LParen => parser.shift(1206),
            TokenType::LCurly => parser.shift(1285),
            TokenType::Args => parser.goto(2152),
            TokenType::Tableconstructor => parser.goto(1284),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1736> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Then => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1737> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1214),
            TokenType::LParen => parser.shift(1218),
            TokenType::LCurly => parser.shift(1279),
            TokenType::Args => parser.goto(2209),
            TokenType::Tableconstructor => parser.goto(1277),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1738> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<13>(),
            TokenType::Break => parser.reduce::<13>(),
            TokenType::Do => parser.reduce::<13>(),
            TokenType::End => parser.reduce::<13>(),
            TokenType::For => parser.reduce::<13>(),
            TokenType::Function => parser.reduce::<13>(),
            TokenType::Goto => parser.reduce::<13>(),
            TokenType::If => parser.reduce::<13>(),
            TokenType::Local => parser.reduce::<13>(),
            TokenType::Repeat => parser.reduce::<13>(),
            TokenType::Return => parser.reduce::<13>(),
            TokenType::While => parser.reduce::<13>(),
            TokenType::LParen => parser.reduce::<13>(),
            TokenType::DoubleColon => parser.reduce::<13>(),
            TokenType::SemiColon => parser.reduce::<13>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1739> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<13>(),
            TokenType::Break => parser.reduce::<13>(),
            TokenType::Do => parser.reduce::<13>(),
            TokenType::For => parser.reduce::<13>(),
            TokenType::Function => parser.reduce::<13>(),
            TokenType::Goto => parser.reduce::<13>(),
            TokenType::If => parser.reduce::<13>(),
            TokenType::Local => parser.reduce::<13>(),
            TokenType::Repeat => parser.reduce::<13>(),
            TokenType::Return => parser.reduce::<13>(),
            TokenType::Until => parser.reduce::<13>(),
            TokenType::While => parser.reduce::<13>(),
            TokenType::LParen => parser.reduce::<13>(),
            TokenType::DoubleColon => parser.reduce::<13>(),
            TokenType::SemiColon => parser.reduce::<13>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1740> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(266),
            TokenType::LParen => parser.shift(267),
            TokenType::LCurly => parser.shift(284),
            TokenType::Args => parser.goto(2177),
            TokenType::Tableconstructor => parser.goto(283),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1741> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2308),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1742> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2310),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1743> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::RParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1744> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::RCurly => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1745> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<104>(),
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Break => parser.reduce::<104>(),
            TokenType::Do => parser.reduce::<104>(),
            TokenType::For => parser.reduce::<104>(),
            TokenType::Function => parser.reduce::<104>(),
            TokenType::Goto => parser.reduce::<104>(),
            TokenType::If => parser.reduce::<104>(),
            TokenType::Local => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Repeat => parser.reduce::<104>(),
            TokenType::Return => parser.reduce::<104>(),
            TokenType::While => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::DoubleColon => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Comma => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            TokenType::Eof => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1746> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::RSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1747> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1214),
            TokenType::And => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.shift(1218),
            TokenType::LSquare => parser.shift(2186),
            TokenType::LCurly => parser.shift(1279),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.shift(2271),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.shift(2270),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(2272),
            TokenType::Tableconstructor => parser.goto(1277),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1748> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Comma => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            TokenType::Eof => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1749> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<52>(),
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Break => parser.reduce::<52>(),
            TokenType::Do => parser.reduce::<52>(),
            TokenType::End => parser.reduce::<52>(),
            TokenType::For => parser.reduce::<52>(),
            TokenType::Function => parser.reduce::<52>(),
            TokenType::Goto => parser.reduce::<52>(),
            TokenType::If => parser.reduce::<52>(),
            TokenType::Local => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Repeat => parser.reduce::<52>(),
            TokenType::Return => parser.reduce::<52>(),
            TokenType::While => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::DoubleColon => parser.reduce::<52>(),
            TokenType::SemiColon => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Comma => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1750> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::RParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1751> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1269),
            TokenType::LParen => parser.shift(1278),
            TokenType::LCurly => parser.shift(1312),
            TokenType::Args => parser.goto(2164),
            TokenType::Tableconstructor => parser.goto(1310),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1752> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<52>(),
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Break => parser.reduce::<52>(),
            TokenType::Do => parser.reduce::<52>(),
            TokenType::For => parser.reduce::<52>(),
            TokenType::Function => parser.reduce::<52>(),
            TokenType::Goto => parser.reduce::<52>(),
            TokenType::If => parser.reduce::<52>(),
            TokenType::Local => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Repeat => parser.reduce::<52>(),
            TokenType::Return => parser.reduce::<52>(),
            TokenType::Until => parser.reduce::<52>(),
            TokenType::While => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::DoubleColon => parser.reduce::<52>(),
            TokenType::SemiColon => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Comma => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1753> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1159),
            TokenType::LParen => parser.shift(1188),
            TokenType::LSquare => parser.shift(515),
            TokenType::LCurly => parser.shift(1239),
            TokenType::Colon => parser.shift(2251),
            TokenType::Dot => parser.shift(556),
            TokenType::Args => parser.goto(2252),
            TokenType::Tableconstructor => parser.goto(1231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1754> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<52>(),
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Break => parser.reduce::<52>(),
            TokenType::Do => parser.reduce::<52>(),
            TokenType::For => parser.reduce::<52>(),
            TokenType::Function => parser.reduce::<52>(),
            TokenType::Goto => parser.reduce::<52>(),
            TokenType::If => parser.reduce::<52>(),
            TokenType::Local => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Repeat => parser.reduce::<52>(),
            TokenType::Return => parser.reduce::<52>(),
            TokenType::While => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::DoubleColon => parser.reduce::<52>(),
            TokenType::SemiColon => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            TokenType::Eof => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1755> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Explist => parser.goto(2154),
            TokenType::Exp => parser.goto(1876),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1756> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2168),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1757> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1262),
            TokenType::LParen => parser.shift(1264),
            TokenType::LCurly => parser.shift(1309),
            TokenType::Args => parser.goto(2225),
            TokenType::Tableconstructor => parser.goto(1308),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1758> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1214),
            TokenType::LParen => parser.shift(1218),
            TokenType::LCurly => parser.shift(1279),
            TokenType::Args => parser.goto(2192),
            TokenType::Tableconstructor => parser.goto(1277),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1759> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2309),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1760> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(262),
            TokenType::LParen => parser.shift(269),
            TokenType::LCurly => parser.shift(288),
            TokenType::Args => parser.goto(2153),
            TokenType::Tableconstructor => parser.goto(287),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1761> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1241),
            TokenType::LParen => parser.shift(1248),
            TokenType::LCurly => parser.shift(1294),
            TokenType::Args => parser.goto(2162),
            TokenType::Tableconstructor => parser.goto(1293),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1762> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1269),
            TokenType::LParen => parser.shift(1278),
            TokenType::LCurly => parser.shift(1312),
            TokenType::Args => parser.goto(2159),
            TokenType::Tableconstructor => parser.goto(1310),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1763> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::End => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::SemiColon => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Comma => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1764> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1221),
            TokenType::LParen => parser.shift(1223),
            TokenType::LCurly => parser.shift(1288),
            TokenType::Args => parser.goto(2155),
            TokenType::Tableconstructor => parser.goto(1287),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1765> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Do => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Comma => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1766> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Comma => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1767> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1221),
            TokenType::LParen => parser.shift(1223),
            TokenType::LCurly => parser.shift(1288),
            TokenType::Args => parser.goto(2195),
            TokenType::Tableconstructor => parser.goto(1287),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1768> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            TokenType::Eof => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1769> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2312),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1770> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(2279),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1771> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            TokenType::Eof => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1772> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Eof => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1773> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2163),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1774> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1775> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<53>(),
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Break => parser.reduce::<53>(),
            TokenType::Do => parser.reduce::<53>(),
            TokenType::For => parser.reduce::<53>(),
            TokenType::Function => parser.reduce::<53>(),
            TokenType::Goto => parser.reduce::<53>(),
            TokenType::If => parser.reduce::<53>(),
            TokenType::Local => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Repeat => parser.reduce::<53>(),
            TokenType::Return => parser.reduce::<53>(),
            TokenType::Until => parser.reduce::<53>(),
            TokenType::While => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::DoubleColon => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Comma => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1776> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2160),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1777> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2198),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1778> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Comma => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            TokenType::Eof => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1779> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2175),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1780> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2174),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1781> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2149),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1782> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2156),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1783> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::RCurly => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Comma => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1784> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::RSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1785> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2158),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1786> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2157),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1787> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<98>(),
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Break => parser.reduce::<98>(),
            TokenType::Do => parser.reduce::<98>(),
            TokenType::End => parser.reduce::<98>(),
            TokenType::For => parser.reduce::<98>(),
            TokenType::Function => parser.reduce::<98>(),
            TokenType::Goto => parser.reduce::<98>(),
            TokenType::If => parser.reduce::<98>(),
            TokenType::Local => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Repeat => parser.reduce::<98>(),
            TokenType::Return => parser.reduce::<98>(),
            TokenType::While => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::DoubleColon => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1788> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<108>(),
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Break => parser.reduce::<108>(),
            TokenType::Do => parser.reduce::<108>(),
            TokenType::End => parser.reduce::<108>(),
            TokenType::For => parser.reduce::<108>(),
            TokenType::Function => parser.reduce::<108>(),
            TokenType::Goto => parser.reduce::<108>(),
            TokenType::If => parser.reduce::<108>(),
            TokenType::Local => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Repeat => parser.reduce::<108>(),
            TokenType::Return => parser.reduce::<108>(),
            TokenType::While => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::DoubleColon => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1789> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(2347),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1790> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2185),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1791> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2166),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1792> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::RParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Comma => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1793> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2184),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1794> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2199),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1795> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2229),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1796> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<100>(),
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Break => parser.reduce::<100>(),
            TokenType::Do => parser.reduce::<100>(),
            TokenType::For => parser.reduce::<100>(),
            TokenType::Function => parser.reduce::<100>(),
            TokenType::Goto => parser.reduce::<100>(),
            TokenType::If => parser.reduce::<100>(),
            TokenType::Local => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Repeat => parser.reduce::<100>(),
            TokenType::Return => parser.reduce::<100>(),
            TokenType::While => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::DoubleColon => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Comma => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            TokenType::Eof => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1797> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(2183),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1798> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2213),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1799> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2188),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1800> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<99>(),
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Break => parser.reduce::<99>(),
            TokenType::Do => parser.reduce::<99>(),
            TokenType::End => parser.reduce::<99>(),
            TokenType::For => parser.reduce::<99>(),
            TokenType::Function => parser.reduce::<99>(),
            TokenType::Goto => parser.reduce::<99>(),
            TokenType::If => parser.reduce::<99>(),
            TokenType::Local => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Repeat => parser.reduce::<99>(),
            TokenType::Return => parser.reduce::<99>(),
            TokenType::While => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::DoubleColon => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1801> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2176),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1802> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2169),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1803> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::RSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1804> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::RParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Comma => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1805> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::RCurly => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Comma => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1806> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::Until => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1807> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1808> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            TokenType::Eof => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1809> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1810> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Until => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1811> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::RParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1812> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1813> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            TokenType::Eof => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1814> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<109>(),
            TokenType::And => parser.reduce::<109>(),
            TokenType::Break => parser.reduce::<109>(),
            TokenType::Do => parser.reduce::<109>(),
            TokenType::End => parser.reduce::<109>(),
            TokenType::For => parser.reduce::<109>(),
            TokenType::Function => parser.reduce::<109>(),
            TokenType::Goto => parser.reduce::<109>(),
            TokenType::If => parser.reduce::<109>(),
            TokenType::Local => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Repeat => parser.reduce::<109>(),
            TokenType::Return => parser.reduce::<109>(),
            TokenType::While => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::LParen => parser.reduce::<109>(),
            TokenType::DoubleColon => parser.reduce::<109>(),
            TokenType::SemiColon => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1815> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            TokenType::Eof => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1816> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(2151),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1817> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::RSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1818> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2178),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1819> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::End => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1820> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<109>(),
            TokenType::And => parser.reduce::<109>(),
            TokenType::Break => parser.reduce::<109>(),
            TokenType::Do => parser.reduce::<109>(),
            TokenType::For => parser.reduce::<109>(),
            TokenType::Function => parser.reduce::<109>(),
            TokenType::Goto => parser.reduce::<109>(),
            TokenType::If => parser.reduce::<109>(),
            TokenType::Local => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Repeat => parser.reduce::<109>(),
            TokenType::Return => parser.reduce::<109>(),
            TokenType::Until => parser.reduce::<109>(),
            TokenType::While => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::LParen => parser.reduce::<109>(),
            TokenType::DoubleColon => parser.reduce::<109>(),
            TokenType::SemiColon => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1821> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(2203),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1822> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<117>(),
            TokenType::End => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1823> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1824> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(589),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LCurly => parser.shift(400),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(2343),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1825> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2189),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1826> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2165),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1827> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<99>(),
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Break => parser.reduce::<99>(),
            TokenType::Do => parser.reduce::<99>(),
            TokenType::For => parser.reduce::<99>(),
            TokenType::Function => parser.reduce::<99>(),
            TokenType::Goto => parser.reduce::<99>(),
            TokenType::If => parser.reduce::<99>(),
            TokenType::Local => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Repeat => parser.reduce::<99>(),
            TokenType::Return => parser.reduce::<99>(),
            TokenType::Until => parser.reduce::<99>(),
            TokenType::While => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::DoubleColon => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1828> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<108>(),
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Break => parser.reduce::<108>(),
            TokenType::Do => parser.reduce::<108>(),
            TokenType::For => parser.reduce::<108>(),
            TokenType::Function => parser.reduce::<108>(),
            TokenType::Goto => parser.reduce::<108>(),
            TokenType::If => parser.reduce::<108>(),
            TokenType::Local => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Repeat => parser.reduce::<108>(),
            TokenType::Return => parser.reduce::<108>(),
            TokenType::Until => parser.reduce::<108>(),
            TokenType::While => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::DoubleColon => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1829> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2221),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1830> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<122>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1831> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2161),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1832> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(2350),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1833> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<98>(),
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Break => parser.reduce::<98>(),
            TokenType::Do => parser.reduce::<98>(),
            TokenType::For => parser.reduce::<98>(),
            TokenType::Function => parser.reduce::<98>(),
            TokenType::Goto => parser.reduce::<98>(),
            TokenType::If => parser.reduce::<98>(),
            TokenType::Local => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Repeat => parser.reduce::<98>(),
            TokenType::Return => parser.reduce::<98>(),
            TokenType::Until => parser.reduce::<98>(),
            TokenType::While => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::DoubleColon => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1834> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(2217),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1835> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2196),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1836> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Eof => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1837> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2173),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1838> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2181),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1839> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2167),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1840> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2226),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1841> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2371),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1842> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2180),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1843> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2179),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1844> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2171),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1845> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2393),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1846> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2172),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1847> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2193),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1848> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2208),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1849> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::End => parser.reduce::<59>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Add => parser.shift(1283),
            TokenType::Sub => parser.shift(1311),
            TokenType::Mul => parser.shift(1331),
            TokenType::Div => parser.shift(1348),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Mod => parser.shift(1395),
            TokenType::Pow => parser.shift(1447),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitOr => parser.shift(1501),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::Eq => parser.shift(1539),
            TokenType::Neq => parser.shift(1563),
            TokenType::Leq => parser.shift(1570),
            TokenType::Geq => parser.shift(1576),
            TokenType::Less => parser.shift(1580),
            TokenType::Greater => parser.shift(1594),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(1121),
            TokenType::Concat => parser.shift(1597),
            TokenType::ExplistCont => parser.goto(2231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1850> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<107>(),
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Break => parser.reduce::<107>(),
            TokenType::Do => parser.reduce::<107>(),
            TokenType::End => parser.reduce::<107>(),
            TokenType::For => parser.reduce::<107>(),
            TokenType::Function => parser.reduce::<107>(),
            TokenType::Goto => parser.reduce::<107>(),
            TokenType::If => parser.reduce::<107>(),
            TokenType::Local => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Repeat => parser.reduce::<107>(),
            TokenType::Return => parser.reduce::<107>(),
            TokenType::While => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::DoubleColon => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1851> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(2261),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Else => parser.reduce::<69>(),
            TokenType::Elseif => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.shift(2265),
            TokenType::LSquare => parser.shift(2205),
            TokenType::LCurly => parser.shift(2307),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.shift(2259),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.shift(2258),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(2260),
            TokenType::Tableconstructor => parser.goto(2306),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1852> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(2355),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1853> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<107>(),
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Break => parser.reduce::<107>(),
            TokenType::Do => parser.reduce::<107>(),
            TokenType::For => parser.reduce::<107>(),
            TokenType::Function => parser.reduce::<107>(),
            TokenType::Goto => parser.reduce::<107>(),
            TokenType::If => parser.reduce::<107>(),
            TokenType::Local => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Repeat => parser.reduce::<107>(),
            TokenType::Return => parser.reduce::<107>(),
            TokenType::Until => parser.reduce::<107>(),
            TokenType::While => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::DoubleColon => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1854> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2220),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1855> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(2351),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1856> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2235),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1857> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(2261),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Else => parser.reduce::<70>(),
            TokenType::Elseif => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.shift(2265),
            TokenType::LSquare => parser.shift(2238),
            TokenType::LCurly => parser.shift(2307),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.shift(2268),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.shift(2267),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(2269),
            TokenType::Tableconstructor => parser.goto(2306),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1858> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::Or => parser.shift(1259),
            TokenType::Until => parser.reduce::<59>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Sub => parser.shift(1327),
            TokenType::Mul => parser.shift(1347),
            TokenType::Div => parser.shift(1358),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Mod => parser.shift(1458),
            TokenType::Pow => parser.shift(1477),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitOr => parser.shift(1518),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::Eq => parser.shift(1568),
            TokenType::Neq => parser.shift(1573),
            TokenType::Leq => parser.shift(1578),
            TokenType::Geq => parser.shift(1581),
            TokenType::Less => parser.shift(1590),
            TokenType::Greater => parser.shift(1595),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(1145),
            TokenType::Concat => parser.shift(1598),
            TokenType::ExplistCont => parser.goto(2239),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1859> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Add => parser.shift(1299),
            TokenType::Sub => parser.shift(1316),
            TokenType::Mul => parser.shift(1342),
            TokenType::Div => parser.shift(1351),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Mod => parser.shift(1402),
            TokenType::Pow => parser.shift(1460),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitOr => parser.shift(1500),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::Eq => parser.shift(1534),
            TokenType::Neq => parser.shift(1557),
            TokenType::Leq => parser.shift(1569),
            TokenType::Geq => parser.shift(1575),
            TokenType::Less => parser.shift(1582),
            TokenType::Greater => parser.shift(1589),
            TokenType::Comma => parser.shift(1154),
            TokenType::Concat => parser.shift(1596),
            TokenType::ExplistCont => parser.goto(2190),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1860> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::Else => parser.reduce::<59>(),
            TokenType::Elseif => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Add => parser.shift(2317),
            TokenType::Sub => parser.shift(2325),
            TokenType::Mul => parser.shift(2334),
            TokenType::Div => parser.shift(2335),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Mod => parser.shift(2344),
            TokenType::Pow => parser.shift(2349),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitOr => parser.shift(2362),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::Eq => parser.shift(2408),
            TokenType::Neq => parser.shift(2412),
            TokenType::Leq => parser.shift(2413),
            TokenType::Geq => parser.shift(2416),
            TokenType::Less => parser.shift(2418),
            TokenType::Greater => parser.shift(2420),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(2204),
            TokenType::Concat => parser.shift(2421),
            TokenType::ExplistCont => parser.goto(2187),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1861> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<64>(),
            TokenType::Else => parser.reduce::<64>(),
            TokenType::Elseif => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1862> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Else => parser.reduce::<65>(),
            TokenType::Elseif => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1863> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<66>(),
            TokenType::Else => parser.reduce::<66>(),
            TokenType::Elseif => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1864> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Else => parser.reduce::<62>(),
            TokenType::Elseif => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1865> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Else => parser.reduce::<61>(),
            TokenType::Elseif => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1866> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2218),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1867> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2323),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1868> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2197),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1869> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2210),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1870> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2194),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1871> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2206),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1872> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.shift(2300),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::Else => parser.reduce::<69>(),
            TokenType::Elseif => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            // Shift(2304)-Reduce(69)
            TokenType::LParen => parser.shift(2304),
            TokenType::LSquare => parser.shift(2223),
            TokenType::LCurly => parser.shift(2318),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.shift(2302),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.shift(2301),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(2303),
            TokenType::Tableconstructor => parser.goto(2315),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1873> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.shift(1189),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Sub => parser.shift(1398),
            TokenType::Mul => parser.shift(1478),
            TokenType::Div => parser.shift(1515),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Mod => parser.shift(1571),
            TokenType::Pow => parser.shift(1588),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitOr => parser.shift(1605),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::Eq => parser.shift(1615),
            TokenType::Neq => parser.shift(1618),
            TokenType::Leq => parser.shift(1621),
            TokenType::Geq => parser.shift(1624),
            TokenType::Less => parser.shift(1627),
            TokenType::Greater => parser.shift(1630),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(1126),
            TokenType::Concat => parser.shift(1633),
            TokenType::ExplistCont => parser.goto(2256),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1874> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.shift(2300),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::Else => parser.reduce::<70>(),
            TokenType::Elseif => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            // Shift(2304)-Reduce(70)
            TokenType::LParen => parser.shift(2304),
            TokenType::LSquare => parser.shift(2227),
            TokenType::LCurly => parser.shift(2318),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.shift(2296),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.shift(2294),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(2299),
            TokenType::Tableconstructor => parser.goto(2315),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1875> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Else => parser.reduce::<63>(),
            TokenType::Elseif => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1876> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.shift(2290),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::Else => parser.reduce::<59>(),
            TokenType::Elseif => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Sub => parser.shift(2348),
            TokenType::Mul => parser.shift(2359),
            TokenType::Div => parser.shift(2402),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Mod => parser.shift(2414),
            TokenType::Pow => parser.shift(2419),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitOr => parser.shift(2424),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::Eq => parser.shift(2427),
            TokenType::Neq => parser.shift(2428),
            TokenType::Leq => parser.shift(2429),
            TokenType::Geq => parser.shift(2430),
            TokenType::Less => parser.shift(2431),
            TokenType::Greater => parser.shift(2432),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(2245),
            TokenType::Concat => parser.shift(2433),
            TokenType::ExplistCont => parser.goto(2200),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1877> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2333),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1878> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::Else => parser.reduce::<64>(),
            TokenType::Elseif => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1879> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::Else => parser.reduce::<65>(),
            TokenType::Elseif => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1880> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::Else => parser.reduce::<66>(),
            TokenType::Elseif => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1881> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::Else => parser.reduce::<62>(),
            TokenType::Elseif => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1882> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::Else => parser.reduce::<61>(),
            TokenType::Elseif => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1883> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2341),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1884> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.shift(1249),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::Until => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Sub => parser.shift(1470),
            TokenType::Mul => parser.shift(1489),
            TokenType::Div => parser.shift(1521),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Mod => parser.shift(1579),
            TokenType::Pow => parser.shift(1592),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitOr => parser.shift(1606),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::Eq => parser.shift(1614),
            TokenType::Neq => parser.shift(1617),
            TokenType::Leq => parser.shift(1620),
            TokenType::Geq => parser.shift(1623),
            TokenType::Less => parser.shift(1626),
            TokenType::Greater => parser.shift(1629),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(1175),
            TokenType::Concat => parser.shift(1631),
            TokenType::ExplistCont => parser.goto(2289),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1885> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2392),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1886> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2399),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1887> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2338),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1888> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<93>(),
            TokenType::And => parser.reduce::<93>(),
            TokenType::Break => parser.reduce::<93>(),
            TokenType::Do => parser.reduce::<93>(),
            TokenType::End => parser.reduce::<93>(),
            TokenType::For => parser.reduce::<93>(),
            TokenType::Function => parser.reduce::<93>(),
            TokenType::Goto => parser.reduce::<93>(),
            TokenType::If => parser.reduce::<93>(),
            TokenType::Local => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Repeat => parser.reduce::<93>(),
            TokenType::Return => parser.reduce::<93>(),
            TokenType::While => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::LParen => parser.reduce::<93>(),
            TokenType::DoubleColon => parser.reduce::<93>(),
            TokenType::SemiColon => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1889> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2340),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1890> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::Comma => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1891> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<93>(),
            TokenType::And => parser.reduce::<93>(),
            TokenType::Break => parser.reduce::<93>(),
            TokenType::Do => parser.reduce::<93>(),
            TokenType::For => parser.reduce::<93>(),
            TokenType::Function => parser.reduce::<93>(),
            TokenType::Goto => parser.reduce::<93>(),
            TokenType::If => parser.reduce::<93>(),
            TokenType::Local => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Repeat => parser.reduce::<93>(),
            TokenType::Return => parser.reduce::<93>(),
            TokenType::Until => parser.reduce::<93>(),
            TokenType::While => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::LParen => parser.reduce::<93>(),
            TokenType::DoubleColon => parser.reduce::<93>(),
            TokenType::SemiColon => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1892> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1893> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Do => parser.reduce::<82>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::Comma => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1894> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Div => parser.shift(1352),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Mod => parser.shift(1399),
            TokenType::Pow => parser.shift(1439),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1895> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::Comma => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1896> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::Comma => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1897> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Div => parser.shift(1348),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Mod => parser.shift(1395),
            TokenType::Pow => parser.shift(1447),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1898> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2400),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1899> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Do => parser.reduce::<89>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::Comma => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1900> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Do => parser.reduce::<83>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::Comma => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1901> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2394),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1902> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<82>(),
            TokenType::End => parser.reduce::<82>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::SemiColon => parser.reduce::<82>(),
            TokenType::Comma => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1903> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::Comma => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1904> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Div => parser.shift(1352),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Mod => parser.shift(1399),
            TokenType::Pow => parser.shift(1439),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1905> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Do => parser.reduce::<90>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::Comma => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1906> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::Comma => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1907> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Div => parser.shift(1351),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Mod => parser.shift(1402),
            TokenType::Pow => parser.shift(1460),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1908> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<90>(),
            TokenType::End => parser.reduce::<90>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::SemiColon => parser.reduce::<90>(),
            TokenType::Comma => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1909> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Until => parser.reduce::<91>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::SemiColon => parser.reduce::<91>(),
            TokenType::Comma => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1910> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Until => parser.reduce::<97>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::SemiColon => parser.reduce::<97>(),
            TokenType::Comma => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1911> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::Comma => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1912> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1913> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<83>(),
            TokenType::End => parser.reduce::<83>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::SemiColon => parser.reduce::<83>(),
            TokenType::Comma => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1914> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<92>(),
            TokenType::End => parser.reduce::<92>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::SemiColon => parser.reduce::<92>(),
            TokenType::Comma => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1915> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Div => parser.shift(1351),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Mod => parser.shift(1402),
            TokenType::Pow => parser.shift(1460),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1916> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<74>(),
            TokenType::End => parser.reduce::<74>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1917> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Until => parser.reduce::<90>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::SemiColon => parser.reduce::<90>(),
            TokenType::Comma => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1918> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1919> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::Comma => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1920> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::Else => parser.reduce::<63>(),
            TokenType::Elseif => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1921> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Until => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Div => parser.shift(1358),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Mod => parser.shift(1458),
            TokenType::Pow => parser.shift(1477),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1922> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Do => parser.reduce::<92>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::Comma => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1923> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2345),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1924> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1925> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<91>(),
            TokenType::End => parser.reduce::<91>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::SemiColon => parser.reduce::<91>(),
            TokenType::Comma => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1926> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Do => parser.reduce::<91>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::Comma => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1927> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1928> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Until => parser.reduce::<74>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1929> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Until => parser.reduce::<89>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::SemiColon => parser.reduce::<89>(),
            TokenType::Comma => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1930> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::Comma => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1931> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1932> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Do => parser.reduce::<97>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::Comma => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1933> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Div => parser.shift(1348),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Mod => parser.shift(1395),
            TokenType::Pow => parser.shift(1447),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1934> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::Comma => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1935> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::Comma => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1936> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Until => parser.reduce::<83>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::SemiColon => parser.reduce::<83>(),
            TokenType::Comma => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1937> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::Comma => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1938> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Until => parser.reduce::<73>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1939> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1940> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1941> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1942> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::Comma => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1943> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1944> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Do => parser.reduce::<84>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::Comma => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1945> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1946> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<89>(),
            TokenType::End => parser.reduce::<89>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::SemiColon => parser.reduce::<89>(),
            TokenType::Comma => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1947> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Until => parser.reduce::<86>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::SemiColon => parser.reduce::<86>(),
            TokenType::Comma => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1948> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Else => parser.reduce::<67>(),
            TokenType::Elseif => parser.reduce::<67>(),
            TokenType::End => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1949> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1950> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1951> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Do => parser.reduce::<75>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::Comma => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1952> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<85>(),
            TokenType::End => parser.reduce::<85>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::SemiColon => parser.reduce::<85>(),
            TokenType::Comma => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1953> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.shift(1286),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.shift(1313),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(1321),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(1345),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(1352),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(1399),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(1439),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(1490),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(1522),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(1531),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(1547),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(1567),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(1572),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(1577),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(1583),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1954> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1955> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Do => parser.reduce::<81>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::Comma => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1956> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Until => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Div => parser.shift(1358),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Mod => parser.shift(1458),
            TokenType::Pow => parser.shift(1477),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1957> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Do => parser.reduce::<85>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::Comma => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1958> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Until => parser.reduce::<85>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::SemiColon => parser.reduce::<85>(),
            TokenType::Comma => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1959> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Until => parser.reduce::<79>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1960> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<95>(),
            TokenType::And => parser.reduce::<95>(),
            TokenType::Break => parser.reduce::<95>(),
            TokenType::Do => parser.reduce::<95>(),
            TokenType::End => parser.reduce::<95>(),
            TokenType::For => parser.reduce::<95>(),
            TokenType::Function => parser.reduce::<95>(),
            TokenType::Goto => parser.reduce::<95>(),
            TokenType::If => parser.reduce::<95>(),
            TokenType::Local => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Repeat => parser.reduce::<95>(),
            TokenType::Return => parser.reduce::<95>(),
            TokenType::While => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::LParen => parser.reduce::<95>(),
            TokenType::DoubleColon => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1961> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Until => parser.reduce::<82>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::SemiColon => parser.reduce::<82>(),
            TokenType::Comma => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1962> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<97>(),
            TokenType::End => parser.reduce::<97>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::SemiColon => parser.reduce::<97>(),
            TokenType::Comma => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1963> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<81>(),
            TokenType::End => parser.reduce::<81>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::SemiColon => parser.reduce::<81>(),
            TokenType::Comma => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1964> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1965> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Until => parser.reduce::<77>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1966> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Until => parser.reduce::<78>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1967> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Do => parser.reduce::<86>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Add => parser.shift(1299),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(1316),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(1342),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(1351),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(1402),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(1460),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(1500),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(1534),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(1557),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(1569),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(1575),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(1582),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(1589),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::Comma => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(1596),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1968> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<80>(),
            TokenType::End => parser.reduce::<80>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1969> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<86>(),
            TokenType::End => parser.reduce::<86>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::SemiColon => parser.reduce::<86>(),
            TokenType::Comma => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1970> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Until => parser.reduce::<81>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::SemiColon => parser.reduce::<81>(),
            TokenType::Comma => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1971> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<76>(),
            TokenType::End => parser.reduce::<76>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1972> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Until => parser.reduce::<92>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::SemiColon => parser.reduce::<92>(),
            TokenType::Comma => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1973> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1974> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Until => parser.reduce::<75>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::SemiColon => parser.reduce::<75>(),
            TokenType::Comma => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1975> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Until => parser.reduce::<80>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1976> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Until => parser.reduce::<84>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::SemiColon => parser.reduce::<84>(),
            TokenType::Comma => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1977> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1978> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<75>(),
            TokenType::End => parser.reduce::<75>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::SemiColon => parser.reduce::<75>(),
            TokenType::Comma => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1979> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2382),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1980> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2234),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1981> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1131),
            TokenType::And => parser.reduce::<84>(),
            TokenType::End => parser.reduce::<84>(),
            TokenType::Or => parser.shift(1199),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Add => parser.shift(1283),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(1311),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(1331),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(1348),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(1360),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(1395),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(1447),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(1473),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(1481),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(1501),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(1519),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(1524),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(1539),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(1563),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(1570),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(1576),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(1580),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(1594),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::SemiColon => parser.reduce::<84>(),
            TokenType::Comma => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(1597),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1982> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<95>(),
            TokenType::And => parser.reduce::<95>(),
            TokenType::Break => parser.reduce::<95>(),
            TokenType::Do => parser.reduce::<95>(),
            TokenType::For => parser.reduce::<95>(),
            TokenType::Function => parser.reduce::<95>(),
            TokenType::Goto => parser.reduce::<95>(),
            TokenType::If => parser.reduce::<95>(),
            TokenType::Local => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Repeat => parser.reduce::<95>(),
            TokenType::Return => parser.reduce::<95>(),
            TokenType::Until => parser.reduce::<95>(),
            TokenType::While => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::LParen => parser.reduce::<95>(),
            TokenType::DoubleColon => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1983> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2363),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1984> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<68>(),
            TokenType::Else => parser.reduce::<68>(),
            TokenType::Elseif => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1985> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<72>(),
            TokenType::Else => parser.reduce::<72>(),
            TokenType::Elseif => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1986> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1172),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.shift(1259),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Until => parser.reduce::<76>(),
            TokenType::Add => parser.shift(1304),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(1327),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(1347),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(1358),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(1391),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(1458),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(1477),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(1482),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(1502),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(1518),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(1526),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(1543),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(1568),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(1573),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(1578),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(1581),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(1590),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(1595),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(1598),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1987> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2357),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1988> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2240),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1989> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2211),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1990> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<94>(),
            TokenType::And => parser.reduce::<94>(),
            TokenType::Break => parser.reduce::<94>(),
            TokenType::Do => parser.reduce::<94>(),
            TokenType::End => parser.reduce::<94>(),
            TokenType::For => parser.reduce::<94>(),
            TokenType::Function => parser.reduce::<94>(),
            TokenType::Goto => parser.reduce::<94>(),
            TokenType::If => parser.reduce::<94>(),
            TokenType::Local => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Repeat => parser.reduce::<94>(),
            TokenType::Return => parser.reduce::<94>(),
            TokenType::While => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::LParen => parser.reduce::<94>(),
            TokenType::DoubleColon => parser.reduce::<94>(),
            TokenType::SemiColon => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1991> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2214),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1992> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2222),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1993> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2219),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1994> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2224),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1995> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2248),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1996> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2250),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1997> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2215),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1998> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2243),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1999> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2216),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2000> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2365),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2001> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2247),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2002> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2398),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2003> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2232),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2004> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2212),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2005> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2249),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2006> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(2254),
            TokenType::Funcbody => parser.goto(2253),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2007> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(2354),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2008> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2230),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2009> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<94>(),
            TokenType::And => parser.reduce::<94>(),
            TokenType::Break => parser.reduce::<94>(),
            TokenType::Do => parser.reduce::<94>(),
            TokenType::For => parser.reduce::<94>(),
            TokenType::Function => parser.reduce::<94>(),
            TokenType::Goto => parser.reduce::<94>(),
            TokenType::If => parser.reduce::<94>(),
            TokenType::Local => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Repeat => parser.reduce::<94>(),
            TokenType::Return => parser.reduce::<94>(),
            TokenType::Until => parser.reduce::<94>(),
            TokenType::While => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::LParen => parser.reduce::<94>(),
            TokenType::DoubleColon => parser.reduce::<94>(),
            TokenType::SemiColon => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2010> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2403),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2011> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2201),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2012> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<96>(),
            TokenType::And => parser.reduce::<96>(),
            TokenType::Break => parser.reduce::<96>(),
            TokenType::Do => parser.reduce::<96>(),
            TokenType::For => parser.reduce::<96>(),
            TokenType::Function => parser.reduce::<96>(),
            TokenType::Goto => parser.reduce::<96>(),
            TokenType::If => parser.reduce::<96>(),
            TokenType::Local => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Repeat => parser.reduce::<96>(),
            TokenType::Return => parser.reduce::<96>(),
            TokenType::Until => parser.reduce::<96>(),
            TokenType::While => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::LParen => parser.reduce::<96>(),
            TokenType::DoubleColon => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2013> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2401),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2014> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Div => parser.shift(1503),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Mod => parser.shift(1556),
            TokenType::Pow => parser.shift(1574),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            TokenType::Eof => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2015> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2377),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2016> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<89>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Break => parser.reduce::<89>(),
            TokenType::Do => parser.reduce::<89>(),
            TokenType::For => parser.reduce::<89>(),
            TokenType::Function => parser.reduce::<89>(),
            TokenType::Goto => parser.reduce::<89>(),
            TokenType::If => parser.reduce::<89>(),
            TokenType::Local => parser.reduce::<89>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Repeat => parser.reduce::<89>(),
            TokenType::Return => parser.reduce::<89>(),
            TokenType::While => parser.reduce::<89>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::LParen => parser.reduce::<89>(),
            TokenType::DoubleColon => parser.reduce::<89>(),
            TokenType::SemiColon => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<89>(),
            TokenType::Eof => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2017> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Div => parser.shift(1503),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Mod => parser.shift(1556),
            TokenType::Pow => parser.shift(1574),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            TokenType::Eof => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2018> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<96>(),
            TokenType::And => parser.reduce::<96>(),
            TokenType::Break => parser.reduce::<96>(),
            TokenType::Do => parser.reduce::<96>(),
            TokenType::End => parser.reduce::<96>(),
            TokenType::For => parser.reduce::<96>(),
            TokenType::Function => parser.reduce::<96>(),
            TokenType::Goto => parser.reduce::<96>(),
            TokenType::If => parser.reduce::<96>(),
            TokenType::Local => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Repeat => parser.reduce::<96>(),
            TokenType::Return => parser.reduce::<96>(),
            TokenType::While => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::LParen => parser.reduce::<96>(),
            TokenType::DoubleColon => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2019> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::Until => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Div => parser.shift(1521),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Mod => parser.shift(1579),
            TokenType::Pow => parser.shift(1592),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2020> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<74>(),
            TokenType::Eof => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2021> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::End => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2022> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<89>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Break => parser.reduce::<89>(),
            TokenType::Do => parser.reduce::<89>(),
            TokenType::End => parser.reduce::<89>(),
            TokenType::For => parser.reduce::<89>(),
            TokenType::Function => parser.reduce::<89>(),
            TokenType::Goto => parser.reduce::<89>(),
            TokenType::If => parser.reduce::<89>(),
            TokenType::Local => parser.reduce::<89>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Repeat => parser.reduce::<89>(),
            TokenType::Return => parser.reduce::<89>(),
            TokenType::While => parser.reduce::<89>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::LParen => parser.reduce::<89>(),
            TokenType::DoubleColon => parser.reduce::<89>(),
            TokenType::SemiColon => parser.reduce::<89>(),
            TokenType::Comma => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2023> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<91>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Break => parser.reduce::<91>(),
            TokenType::Do => parser.reduce::<91>(),
            TokenType::For => parser.reduce::<91>(),
            TokenType::Function => parser.reduce::<91>(),
            TokenType::Goto => parser.reduce::<91>(),
            TokenType::If => parser.reduce::<91>(),
            TokenType::Local => parser.reduce::<91>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Repeat => parser.reduce::<91>(),
            TokenType::Return => parser.reduce::<91>(),
            TokenType::While => parser.reduce::<91>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::LParen => parser.reduce::<91>(),
            TokenType::DoubleColon => parser.reduce::<91>(),
            TokenType::SemiColon => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<91>(),
            TokenType::Eof => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2024> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<81>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Break => parser.reduce::<81>(),
            TokenType::Do => parser.reduce::<81>(),
            TokenType::For => parser.reduce::<81>(),
            TokenType::Function => parser.reduce::<81>(),
            TokenType::Goto => parser.reduce::<81>(),
            TokenType::If => parser.reduce::<81>(),
            TokenType::Local => parser.reduce::<81>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Repeat => parser.reduce::<81>(),
            TokenType::Return => parser.reduce::<81>(),
            TokenType::While => parser.reduce::<81>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::LParen => parser.reduce::<81>(),
            TokenType::DoubleColon => parser.reduce::<81>(),
            TokenType::SemiColon => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<81>(),
            TokenType::Eof => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2025> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<86>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Break => parser.reduce::<86>(),
            TokenType::Do => parser.reduce::<86>(),
            TokenType::For => parser.reduce::<86>(),
            TokenType::Function => parser.reduce::<86>(),
            TokenType::Goto => parser.reduce::<86>(),
            TokenType::If => parser.reduce::<86>(),
            TokenType::Local => parser.reduce::<86>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Repeat => parser.reduce::<86>(),
            TokenType::Return => parser.reduce::<86>(),
            TokenType::Until => parser.reduce::<86>(),
            TokenType::While => parser.reduce::<86>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::LParen => parser.reduce::<86>(),
            TokenType::DoubleColon => parser.reduce::<86>(),
            TokenType::SemiColon => parser.reduce::<86>(),
            TokenType::Comma => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2026> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<73>(),
            TokenType::Eof => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2027> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<97>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Break => parser.reduce::<97>(),
            TokenType::Do => parser.reduce::<97>(),
            TokenType::End => parser.reduce::<97>(),
            TokenType::For => parser.reduce::<97>(),
            TokenType::Function => parser.reduce::<97>(),
            TokenType::Goto => parser.reduce::<97>(),
            TokenType::If => parser.reduce::<97>(),
            TokenType::Local => parser.reduce::<97>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Repeat => parser.reduce::<97>(),
            TokenType::Return => parser.reduce::<97>(),
            TokenType::While => parser.reduce::<97>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::LParen => parser.reduce::<97>(),
            TokenType::DoubleColon => parser.reduce::<97>(),
            TokenType::SemiColon => parser.reduce::<97>(),
            TokenType::Comma => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2028> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<78>(),
            TokenType::Eof => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2029> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<75>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Break => parser.reduce::<75>(),
            TokenType::Do => parser.reduce::<75>(),
            TokenType::For => parser.reduce::<75>(),
            TokenType::Function => parser.reduce::<75>(),
            TokenType::Goto => parser.reduce::<75>(),
            TokenType::If => parser.reduce::<75>(),
            TokenType::Local => parser.reduce::<75>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Repeat => parser.reduce::<75>(),
            TokenType::Return => parser.reduce::<75>(),
            TokenType::While => parser.reduce::<75>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::LParen => parser.reduce::<75>(),
            TokenType::DoubleColon => parser.reduce::<75>(),
            TokenType::SemiColon => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<75>(),
            TokenType::Eof => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2030> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<82>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Break => parser.reduce::<82>(),
            TokenType::Do => parser.reduce::<82>(),
            TokenType::For => parser.reduce::<82>(),
            TokenType::Function => parser.reduce::<82>(),
            TokenType::Goto => parser.reduce::<82>(),
            TokenType::If => parser.reduce::<82>(),
            TokenType::Local => parser.reduce::<82>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Repeat => parser.reduce::<82>(),
            TokenType::Return => parser.reduce::<82>(),
            TokenType::While => parser.reduce::<82>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::LParen => parser.reduce::<82>(),
            TokenType::DoubleColon => parser.reduce::<82>(),
            TokenType::SemiColon => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<82>(),
            TokenType::Eof => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2031> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Div => parser.shift(1515),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Mod => parser.shift(1571),
            TokenType::Pow => parser.shift(1588),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2032> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<77>(),
            TokenType::Eof => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2033> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<89>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Break => parser.reduce::<89>(),
            TokenType::Do => parser.reduce::<89>(),
            TokenType::For => parser.reduce::<89>(),
            TokenType::Function => parser.reduce::<89>(),
            TokenType::Goto => parser.reduce::<89>(),
            TokenType::If => parser.reduce::<89>(),
            TokenType::Local => parser.reduce::<89>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Repeat => parser.reduce::<89>(),
            TokenType::Return => parser.reduce::<89>(),
            TokenType::Until => parser.reduce::<89>(),
            TokenType::While => parser.reduce::<89>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::LParen => parser.reduce::<89>(),
            TokenType::DoubleColon => parser.reduce::<89>(),
            TokenType::SemiColon => parser.reduce::<89>(),
            TokenType::Comma => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2034> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::Until => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2035> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<85>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Break => parser.reduce::<85>(),
            TokenType::Do => parser.reduce::<85>(),
            TokenType::For => parser.reduce::<85>(),
            TokenType::Function => parser.reduce::<85>(),
            TokenType::Goto => parser.reduce::<85>(),
            TokenType::If => parser.reduce::<85>(),
            TokenType::Local => parser.reduce::<85>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Repeat => parser.reduce::<85>(),
            TokenType::Return => parser.reduce::<85>(),
            TokenType::Until => parser.reduce::<85>(),
            TokenType::While => parser.reduce::<85>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::LParen => parser.reduce::<85>(),
            TokenType::DoubleColon => parser.reduce::<85>(),
            TokenType::SemiColon => parser.reduce::<85>(),
            TokenType::Comma => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2036> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<86>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Break => parser.reduce::<86>(),
            TokenType::Do => parser.reduce::<86>(),
            TokenType::For => parser.reduce::<86>(),
            TokenType::Function => parser.reduce::<86>(),
            TokenType::Goto => parser.reduce::<86>(),
            TokenType::If => parser.reduce::<86>(),
            TokenType::Local => parser.reduce::<86>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Repeat => parser.reduce::<86>(),
            TokenType::Return => parser.reduce::<86>(),
            TokenType::While => parser.reduce::<86>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::LParen => parser.reduce::<86>(),
            TokenType::DoubleColon => parser.reduce::<86>(),
            TokenType::SemiColon => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<86>(),
            TokenType::Eof => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2037> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<84>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Break => parser.reduce::<84>(),
            TokenType::Do => parser.reduce::<84>(),
            TokenType::For => parser.reduce::<84>(),
            TokenType::Function => parser.reduce::<84>(),
            TokenType::Goto => parser.reduce::<84>(),
            TokenType::If => parser.reduce::<84>(),
            TokenType::Local => parser.reduce::<84>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Repeat => parser.reduce::<84>(),
            TokenType::Return => parser.reduce::<84>(),
            TokenType::While => parser.reduce::<84>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::LParen => parser.reduce::<84>(),
            TokenType::DoubleColon => parser.reduce::<84>(),
            TokenType::SemiColon => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<84>(),
            TokenType::Eof => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2038> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::Until => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2039> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<82>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Break => parser.reduce::<82>(),
            TokenType::Do => parser.reduce::<82>(),
            TokenType::End => parser.reduce::<82>(),
            TokenType::For => parser.reduce::<82>(),
            TokenType::Function => parser.reduce::<82>(),
            TokenType::Goto => parser.reduce::<82>(),
            TokenType::If => parser.reduce::<82>(),
            TokenType::Local => parser.reduce::<82>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Repeat => parser.reduce::<82>(),
            TokenType::Return => parser.reduce::<82>(),
            TokenType::While => parser.reduce::<82>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::LParen => parser.reduce::<82>(),
            TokenType::DoubleColon => parser.reduce::<82>(),
            TokenType::SemiColon => parser.reduce::<82>(),
            TokenType::Comma => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2040> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<81>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Break => parser.reduce::<81>(),
            TokenType::Do => parser.reduce::<81>(),
            TokenType::End => parser.reduce::<81>(),
            TokenType::For => parser.reduce::<81>(),
            TokenType::Function => parser.reduce::<81>(),
            TokenType::Goto => parser.reduce::<81>(),
            TokenType::If => parser.reduce::<81>(),
            TokenType::Local => parser.reduce::<81>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Repeat => parser.reduce::<81>(),
            TokenType::Return => parser.reduce::<81>(),
            TokenType::While => parser.reduce::<81>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::LParen => parser.reduce::<81>(),
            TokenType::DoubleColon => parser.reduce::<81>(),
            TokenType::SemiColon => parser.reduce::<81>(),
            TokenType::Comma => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2041> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<91>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Break => parser.reduce::<91>(),
            TokenType::Do => parser.reduce::<91>(),
            TokenType::End => parser.reduce::<91>(),
            TokenType::For => parser.reduce::<91>(),
            TokenType::Function => parser.reduce::<91>(),
            TokenType::Goto => parser.reduce::<91>(),
            TokenType::If => parser.reduce::<91>(),
            TokenType::Local => parser.reduce::<91>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Repeat => parser.reduce::<91>(),
            TokenType::Return => parser.reduce::<91>(),
            TokenType::While => parser.reduce::<91>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::LParen => parser.reduce::<91>(),
            TokenType::DoubleColon => parser.reduce::<91>(),
            TokenType::SemiColon => parser.reduce::<91>(),
            TokenType::Comma => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2042> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::Until => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Div => parser.shift(1521),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Mod => parser.shift(1579),
            TokenType::Pow => parser.shift(1592),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2043> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2044> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::End => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2045> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<90>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Break => parser.reduce::<90>(),
            TokenType::Do => parser.reduce::<90>(),
            TokenType::For => parser.reduce::<90>(),
            TokenType::Function => parser.reduce::<90>(),
            TokenType::Goto => parser.reduce::<90>(),
            TokenType::If => parser.reduce::<90>(),
            TokenType::Local => parser.reduce::<90>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Repeat => parser.reduce::<90>(),
            TokenType::Return => parser.reduce::<90>(),
            TokenType::While => parser.reduce::<90>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::LParen => parser.reduce::<90>(),
            TokenType::DoubleColon => parser.reduce::<90>(),
            TokenType::SemiColon => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<90>(),
            TokenType::Eof => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2046> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<86>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Break => parser.reduce::<86>(),
            TokenType::Do => parser.reduce::<86>(),
            TokenType::End => parser.reduce::<86>(),
            TokenType::For => parser.reduce::<86>(),
            TokenType::Function => parser.reduce::<86>(),
            TokenType::Goto => parser.reduce::<86>(),
            TokenType::If => parser.reduce::<86>(),
            TokenType::Local => parser.reduce::<86>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Repeat => parser.reduce::<86>(),
            TokenType::Return => parser.reduce::<86>(),
            TokenType::While => parser.reduce::<86>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::LParen => parser.reduce::<86>(),
            TokenType::DoubleColon => parser.reduce::<86>(),
            TokenType::SemiColon => parser.reduce::<86>(),
            TokenType::Comma => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2047> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<97>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Break => parser.reduce::<97>(),
            TokenType::Do => parser.reduce::<97>(),
            TokenType::For => parser.reduce::<97>(),
            TokenType::Function => parser.reduce::<97>(),
            TokenType::Goto => parser.reduce::<97>(),
            TokenType::If => parser.reduce::<97>(),
            TokenType::Local => parser.reduce::<97>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Repeat => parser.reduce::<97>(),
            TokenType::Return => parser.reduce::<97>(),
            TokenType::While => parser.reduce::<97>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::LParen => parser.reduce::<97>(),
            TokenType::DoubleColon => parser.reduce::<97>(),
            TokenType::SemiColon => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<97>(),
            TokenType::Eof => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2048> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::Until => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2049> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<84>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Break => parser.reduce::<84>(),
            TokenType::Do => parser.reduce::<84>(),
            TokenType::End => parser.reduce::<84>(),
            TokenType::For => parser.reduce::<84>(),
            TokenType::Function => parser.reduce::<84>(),
            TokenType::Goto => parser.reduce::<84>(),
            TokenType::If => parser.reduce::<84>(),
            TokenType::Local => parser.reduce::<84>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Repeat => parser.reduce::<84>(),
            TokenType::Return => parser.reduce::<84>(),
            TokenType::While => parser.reduce::<84>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::LParen => parser.reduce::<84>(),
            TokenType::DoubleColon => parser.reduce::<84>(),
            TokenType::SemiColon => parser.reduce::<84>(),
            TokenType::Comma => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2050> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2051> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<83>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Break => parser.reduce::<83>(),
            TokenType::Do => parser.reduce::<83>(),
            TokenType::End => parser.reduce::<83>(),
            TokenType::For => parser.reduce::<83>(),
            TokenType::Function => parser.reduce::<83>(),
            TokenType::Goto => parser.reduce::<83>(),
            TokenType::If => parser.reduce::<83>(),
            TokenType::Local => parser.reduce::<83>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Repeat => parser.reduce::<83>(),
            TokenType::Return => parser.reduce::<83>(),
            TokenType::While => parser.reduce::<83>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::LParen => parser.reduce::<83>(),
            TokenType::DoubleColon => parser.reduce::<83>(),
            TokenType::SemiColon => parser.reduce::<83>(),
            TokenType::Comma => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2052> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2053> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<76>(),
            TokenType::Eof => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2054> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<83>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Break => parser.reduce::<83>(),
            TokenType::Do => parser.reduce::<83>(),
            TokenType::For => parser.reduce::<83>(),
            TokenType::Function => parser.reduce::<83>(),
            TokenType::Goto => parser.reduce::<83>(),
            TokenType::If => parser.reduce::<83>(),
            TokenType::Local => parser.reduce::<83>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Repeat => parser.reduce::<83>(),
            TokenType::Return => parser.reduce::<83>(),
            TokenType::While => parser.reduce::<83>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::LParen => parser.reduce::<83>(),
            TokenType::DoubleColon => parser.reduce::<83>(),
            TokenType::SemiColon => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<83>(),
            TokenType::Eof => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2055> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<85>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Break => parser.reduce::<85>(),
            TokenType::Do => parser.reduce::<85>(),
            TokenType::End => parser.reduce::<85>(),
            TokenType::For => parser.reduce::<85>(),
            TokenType::Function => parser.reduce::<85>(),
            TokenType::Goto => parser.reduce::<85>(),
            TokenType::If => parser.reduce::<85>(),
            TokenType::Local => parser.reduce::<85>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Repeat => parser.reduce::<85>(),
            TokenType::Return => parser.reduce::<85>(),
            TokenType::While => parser.reduce::<85>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::LParen => parser.reduce::<85>(),
            TokenType::DoubleColon => parser.reduce::<85>(),
            TokenType::SemiColon => parser.reduce::<85>(),
            TokenType::Comma => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2056> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<90>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Break => parser.reduce::<90>(),
            TokenType::Do => parser.reduce::<90>(),
            TokenType::For => parser.reduce::<90>(),
            TokenType::Function => parser.reduce::<90>(),
            TokenType::Goto => parser.reduce::<90>(),
            TokenType::If => parser.reduce::<90>(),
            TokenType::Local => parser.reduce::<90>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Repeat => parser.reduce::<90>(),
            TokenType::Return => parser.reduce::<90>(),
            TokenType::Until => parser.reduce::<90>(),
            TokenType::While => parser.reduce::<90>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::LParen => parser.reduce::<90>(),
            TokenType::DoubleColon => parser.reduce::<90>(),
            TokenType::SemiColon => parser.reduce::<90>(),
            TokenType::Comma => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2057> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<75>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Break => parser.reduce::<75>(),
            TokenType::Do => parser.reduce::<75>(),
            TokenType::For => parser.reduce::<75>(),
            TokenType::Function => parser.reduce::<75>(),
            TokenType::Goto => parser.reduce::<75>(),
            TokenType::If => parser.reduce::<75>(),
            TokenType::Local => parser.reduce::<75>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Repeat => parser.reduce::<75>(),
            TokenType::Return => parser.reduce::<75>(),
            TokenType::Until => parser.reduce::<75>(),
            TokenType::While => parser.reduce::<75>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::LParen => parser.reduce::<75>(),
            TokenType::DoubleColon => parser.reduce::<75>(),
            TokenType::SemiColon => parser.reduce::<75>(),
            TokenType::Comma => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2058> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2379),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2059> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<92>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Break => parser.reduce::<92>(),
            TokenType::Do => parser.reduce::<92>(),
            TokenType::For => parser.reduce::<92>(),
            TokenType::Function => parser.reduce::<92>(),
            TokenType::Goto => parser.reduce::<92>(),
            TokenType::If => parser.reduce::<92>(),
            TokenType::Local => parser.reduce::<92>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Repeat => parser.reduce::<92>(),
            TokenType::Return => parser.reduce::<92>(),
            TokenType::While => parser.reduce::<92>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::LParen => parser.reduce::<92>(),
            TokenType::DoubleColon => parser.reduce::<92>(),
            TokenType::SemiColon => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<92>(),
            TokenType::Eof => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2060> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2374),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2061> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<81>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Break => parser.reduce::<81>(),
            TokenType::Do => parser.reduce::<81>(),
            TokenType::For => parser.reduce::<81>(),
            TokenType::Function => parser.reduce::<81>(),
            TokenType::Goto => parser.reduce::<81>(),
            TokenType::If => parser.reduce::<81>(),
            TokenType::Local => parser.reduce::<81>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Repeat => parser.reduce::<81>(),
            TokenType::Return => parser.reduce::<81>(),
            TokenType::Until => parser.reduce::<81>(),
            TokenType::While => parser.reduce::<81>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::LParen => parser.reduce::<81>(),
            TokenType::DoubleColon => parser.reduce::<81>(),
            TokenType::SemiColon => parser.reduce::<81>(),
            TokenType::Comma => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2062> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Div => parser.shift(1515),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Mod => parser.shift(1571),
            TokenType::Pow => parser.shift(1588),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2063> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::End => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2064> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2065> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::Until => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2066> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<85>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Break => parser.reduce::<85>(),
            TokenType::Do => parser.reduce::<85>(),
            TokenType::For => parser.reduce::<85>(),
            TokenType::Function => parser.reduce::<85>(),
            TokenType::Goto => parser.reduce::<85>(),
            TokenType::If => parser.reduce::<85>(),
            TokenType::Local => parser.reduce::<85>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Repeat => parser.reduce::<85>(),
            TokenType::Return => parser.reduce::<85>(),
            TokenType::While => parser.reduce::<85>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::LParen => parser.reduce::<85>(),
            TokenType::DoubleColon => parser.reduce::<85>(),
            TokenType::SemiColon => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<85>(),
            TokenType::Eof => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2067> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<82>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Break => parser.reduce::<82>(),
            TokenType::Do => parser.reduce::<82>(),
            TokenType::For => parser.reduce::<82>(),
            TokenType::Function => parser.reduce::<82>(),
            TokenType::Goto => parser.reduce::<82>(),
            TokenType::If => parser.reduce::<82>(),
            TokenType::Local => parser.reduce::<82>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Repeat => parser.reduce::<82>(),
            TokenType::Return => parser.reduce::<82>(),
            TokenType::Until => parser.reduce::<82>(),
            TokenType::While => parser.reduce::<82>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::LParen => parser.reduce::<82>(),
            TokenType::DoubleColon => parser.reduce::<82>(),
            TokenType::SemiColon => parser.reduce::<82>(),
            TokenType::Comma => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2068> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<79>(),
            TokenType::Eof => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2069> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<83>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Break => parser.reduce::<83>(),
            TokenType::Do => parser.reduce::<83>(),
            TokenType::For => parser.reduce::<83>(),
            TokenType::Function => parser.reduce::<83>(),
            TokenType::Goto => parser.reduce::<83>(),
            TokenType::If => parser.reduce::<83>(),
            TokenType::Local => parser.reduce::<83>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Repeat => parser.reduce::<83>(),
            TokenType::Return => parser.reduce::<83>(),
            TokenType::Until => parser.reduce::<83>(),
            TokenType::While => parser.reduce::<83>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::LParen => parser.reduce::<83>(),
            TokenType::DoubleColon => parser.reduce::<83>(),
            TokenType::SemiColon => parser.reduce::<83>(),
            TokenType::Comma => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2070> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<91>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Break => parser.reduce::<91>(),
            TokenType::Do => parser.reduce::<91>(),
            TokenType::For => parser.reduce::<91>(),
            TokenType::Function => parser.reduce::<91>(),
            TokenType::Goto => parser.reduce::<91>(),
            TokenType::If => parser.reduce::<91>(),
            TokenType::Local => parser.reduce::<91>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Repeat => parser.reduce::<91>(),
            TokenType::Return => parser.reduce::<91>(),
            TokenType::Until => parser.reduce::<91>(),
            TokenType::While => parser.reduce::<91>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::LParen => parser.reduce::<91>(),
            TokenType::DoubleColon => parser.reduce::<91>(),
            TokenType::SemiColon => parser.reduce::<91>(),
            TokenType::Comma => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2071> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<92>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Break => parser.reduce::<92>(),
            TokenType::Do => parser.reduce::<92>(),
            TokenType::End => parser.reduce::<92>(),
            TokenType::For => parser.reduce::<92>(),
            TokenType::Function => parser.reduce::<92>(),
            TokenType::Goto => parser.reduce::<92>(),
            TokenType::If => parser.reduce::<92>(),
            TokenType::Local => parser.reduce::<92>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Repeat => parser.reduce::<92>(),
            TokenType::Return => parser.reduce::<92>(),
            TokenType::While => parser.reduce::<92>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::LParen => parser.reduce::<92>(),
            TokenType::DoubleColon => parser.reduce::<92>(),
            TokenType::SemiColon => parser.reduce::<92>(),
            TokenType::Comma => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2072> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::Until => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2073> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<84>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Break => parser.reduce::<84>(),
            TokenType::Do => parser.reduce::<84>(),
            TokenType::For => parser.reduce::<84>(),
            TokenType::Function => parser.reduce::<84>(),
            TokenType::Goto => parser.reduce::<84>(),
            TokenType::If => parser.reduce::<84>(),
            TokenType::Local => parser.reduce::<84>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Repeat => parser.reduce::<84>(),
            TokenType::Return => parser.reduce::<84>(),
            TokenType::Until => parser.reduce::<84>(),
            TokenType::While => parser.reduce::<84>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::LParen => parser.reduce::<84>(),
            TokenType::DoubleColon => parser.reduce::<84>(),
            TokenType::SemiColon => parser.reduce::<84>(),
            TokenType::Comma => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2074> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<75>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Break => parser.reduce::<75>(),
            TokenType::Do => parser.reduce::<75>(),
            TokenType::End => parser.reduce::<75>(),
            TokenType::For => parser.reduce::<75>(),
            TokenType::Function => parser.reduce::<75>(),
            TokenType::Goto => parser.reduce::<75>(),
            TokenType::If => parser.reduce::<75>(),
            TokenType::Local => parser.reduce::<75>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Repeat => parser.reduce::<75>(),
            TokenType::Return => parser.reduce::<75>(),
            TokenType::While => parser.reduce::<75>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::LParen => parser.reduce::<75>(),
            TokenType::DoubleColon => parser.reduce::<75>(),
            TokenType::SemiColon => parser.reduce::<75>(),
            TokenType::Comma => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2075> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::Else => parser.reduce::<67>(),
            TokenType::Elseif => parser.reduce::<67>(),
            TokenType::End => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2076> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<92>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Break => parser.reduce::<92>(),
            TokenType::Do => parser.reduce::<92>(),
            TokenType::For => parser.reduce::<92>(),
            TokenType::Function => parser.reduce::<92>(),
            TokenType::Goto => parser.reduce::<92>(),
            TokenType::If => parser.reduce::<92>(),
            TokenType::Local => parser.reduce::<92>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Repeat => parser.reduce::<92>(),
            TokenType::Return => parser.reduce::<92>(),
            TokenType::Until => parser.reduce::<92>(),
            TokenType::While => parser.reduce::<92>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::LParen => parser.reduce::<92>(),
            TokenType::DoubleColon => parser.reduce::<92>(),
            TokenType::SemiColon => parser.reduce::<92>(),
            TokenType::Comma => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2077> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::Until => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2078> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.shift(1099),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.shift(1298),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.shift(1343),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(1383),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(1476),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(1503),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(1525),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(1556),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(1574),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(1593),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(1601),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(1604),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(1607),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(1608),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(1611),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(1616),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(1619),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(1622),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(1625),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(1628),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(1632),
            TokenType::Concat => parser.reduce::<80>(),
            TokenType::Eof => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2079> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<97>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Break => parser.reduce::<97>(),
            TokenType::Do => parser.reduce::<97>(),
            TokenType::For => parser.reduce::<97>(),
            TokenType::Function => parser.reduce::<97>(),
            TokenType::Goto => parser.reduce::<97>(),
            TokenType::If => parser.reduce::<97>(),
            TokenType::Local => parser.reduce::<97>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Repeat => parser.reduce::<97>(),
            TokenType::Return => parser.reduce::<97>(),
            TokenType::Until => parser.reduce::<97>(),
            TokenType::While => parser.reduce::<97>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::LParen => parser.reduce::<97>(),
            TokenType::DoubleColon => parser.reduce::<97>(),
            TokenType::SemiColon => parser.reduce::<97>(),
            TokenType::Comma => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2080> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::And => parser.shift(1249),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.shift(1320),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::Until => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.shift(1367),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(1470),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(1489),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(1521),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(1561),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(1579),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(1592),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(1599),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(1603),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(1606),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(1609),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(1612),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(1614),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(1617),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(1620),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(1623),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(1626),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(1629),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(1631),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2081> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<90>(),
            TokenType::And => parser.shift(1189),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Break => parser.reduce::<90>(),
            TokenType::Do => parser.reduce::<90>(),
            TokenType::End => parser.reduce::<90>(),
            TokenType::For => parser.reduce::<90>(),
            TokenType::Function => parser.reduce::<90>(),
            TokenType::Goto => parser.reduce::<90>(),
            TokenType::If => parser.reduce::<90>(),
            TokenType::Local => parser.reduce::<90>(),
            TokenType::Or => parser.shift(1295),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Repeat => parser.reduce::<90>(),
            TokenType::Return => parser.reduce::<90>(),
            TokenType::While => parser.reduce::<90>(),
            TokenType::Add => parser.shift(1344),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(1398),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(1478),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(1515),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(1532),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(1571),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(1588),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(1600),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(1602),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(1605),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(1610),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(1613),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(1615),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(1618),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(1621),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(1624),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(1627),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(1630),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::LParen => parser.reduce::<90>(),
            TokenType::DoubleColon => parser.reduce::<90>(),
            TokenType::SemiColon => parser.reduce::<90>(),
            TokenType::Comma => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(1633),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2082> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2388),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2083> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2360),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2084> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::Else => parser.reduce::<68>(),
            TokenType::Elseif => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2085> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::Else => parser.reduce::<72>(),
            TokenType::Elseif => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2086> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2381),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2087> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2376),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2088> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2368),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2089> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(2242),
            TokenType::Funcbody => parser.goto(2241),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2090> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(2353),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2091> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2372),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2092> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2383),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2093> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2375),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2094> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2389),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2095> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2369),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2096> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2385),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2097> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2370),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2098> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2397),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2099> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2384),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2100> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2367),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2101> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2391),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2102> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2366),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2103> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2380),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2104> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2387),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2105> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2396),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2106> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2395),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2107> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2361),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2108> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2378),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2109> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            TokenType::String(_) => parser.shift(1336),
            TokenType::Integer(_) => parser.shift(1337),
            TokenType::Float(_) => parser.shift(1338),
            TokenType::False => parser.shift(1339),
            TokenType::Function => parser.shift(1586),
            TokenType::Nil => parser.shift(1340),
            TokenType::Not => parser.shift(1341),
            TokenType::True => parser.shift(1375),
            TokenType::Sub => parser.shift(1377),
            TokenType::Len => parser.shift(1474),
            TokenType::BitXor => parser.shift(1496),
            TokenType::LParen => parser.shift(1132),
            TokenType::LCurly => parser.shift(1587),
            TokenType::Dots => parser.shift(1533),
            TokenType::Var => parser.goto(1329),
            TokenType::Exp => parser.goto(2405),
            TokenType::Functioncall => parser.goto(1334),
            TokenType::Functiondef => parser.goto(1550),
            TokenType::Tableconstructor => parser.goto(1551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2110> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2404),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2111> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1063),
            TokenType::String(_) => parser.shift(1322),
            TokenType::Integer(_) => parser.shift(1323),
            TokenType::Float(_) => parser.shift(1324),
            TokenType::False => parser.shift(1325),
            TokenType::Function => parser.shift(1584),
            TokenType::Nil => parser.shift(1326),
            TokenType::Not => parser.shift(1330),
            TokenType::True => parser.shift(1362),
            TokenType::Sub => parser.shift(1366),
            TokenType::Len => parser.shift(1464),
            TokenType::BitXor => parser.shift(1488),
            TokenType::LParen => parser.shift(1108),
            TokenType::LCurly => parser.shift(1585),
            TokenType::Dots => parser.shift(1535),
            TokenType::Var => parser.goto(1317),
            TokenType::Exp => parser.goto(2390),
            TokenType::Functioncall => parser.goto(1318),
            TokenType::Functiondef => parser.goto(1552),
            TokenType::Tableconstructor => parser.goto(1553),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2112> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::End => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(1036),
            TokenType::AttnamelistCont => parser.goto(2436),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2113> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::Until => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(1034),
            TokenType::AttnamelistCont => parser.goto(2439),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2114> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2115> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2451),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2116> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<15>(),
            TokenType::Break => parser.reduce::<15>(),
            TokenType::Do => parser.reduce::<15>(),
            TokenType::For => parser.reduce::<15>(),
            TokenType::Function => parser.reduce::<15>(),
            TokenType::Goto => parser.reduce::<15>(),
            TokenType::If => parser.reduce::<15>(),
            TokenType::Local => parser.reduce::<15>(),
            TokenType::Repeat => parser.reduce::<15>(),
            TokenType::Return => parser.reduce::<15>(),
            TokenType::While => parser.reduce::<15>(),
            TokenType::LParen => parser.reduce::<15>(),
            TokenType::DoubleColon => parser.reduce::<15>(),
            TokenType::SemiColon => parser.reduce::<15>(),
            TokenType::Eof => parser.reduce::<15>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2117> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<34>(),
            TokenType::Elseif => parser.reduce::<34>(),
            TokenType::End => parser.reduce::<34>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2118> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(2441),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2119> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<25>(),
            TokenType::Break => parser.reduce::<25>(),
            TokenType::Do => parser.reduce::<25>(),
            TokenType::Else => parser.reduce::<25>(),
            TokenType::Elseif => parser.reduce::<25>(),
            TokenType::End => parser.reduce::<25>(),
            TokenType::For => parser.reduce::<25>(),
            TokenType::Function => parser.reduce::<25>(),
            TokenType::Goto => parser.reduce::<25>(),
            TokenType::If => parser.reduce::<25>(),
            TokenType::Local => parser.reduce::<25>(),
            TokenType::Repeat => parser.reduce::<25>(),
            TokenType::Return => parser.reduce::<25>(),
            TokenType::While => parser.reduce::<25>(),
            TokenType::LParen => parser.reduce::<25>(),
            TokenType::DoubleColon => parser.reduce::<25>(),
            TokenType::SemiColon => parser.reduce::<25>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2120> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<38>(),
            TokenType::Elseif => parser.reduce::<38>(),
            TokenType::End => parser.reduce::<38>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2121> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            TokenType::Eof => parser.reduce::<31>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2122> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::Else => parser.reduce::<29>(),
            TokenType::Elseif => parser.reduce::<29>(),
            TokenType::End => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2123> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Greater => parser.shift(2435),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2124> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(2452),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2125> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2438),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2126> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::Do => parser.reduce::<21>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Add => parser.shift(1299),
            TokenType::Sub => parser.shift(1316),
            TokenType::Mul => parser.shift(1342),
            TokenType::Div => parser.shift(1351),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Mod => parser.shift(1402),
            TokenType::Pow => parser.shift(1460),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitOr => parser.shift(1500),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::Eq => parser.shift(1534),
            TokenType::Neq => parser.shift(1557),
            TokenType::Leq => parser.shift(1569),
            TokenType::Geq => parser.shift(1575),
            TokenType::Less => parser.shift(1582),
            TokenType::Greater => parser.shift(1589),
            TokenType::Comma => parser.shift(2143),
            TokenType::Concat => parser.shift(1596),
            TokenType::StatForexp => parser.goto(2434),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2127> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<101>(),
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::Break => parser.reduce::<101>(),
            TokenType::Do => parser.reduce::<101>(),
            TokenType::Else => parser.reduce::<101>(),
            TokenType::Elseif => parser.reduce::<101>(),
            TokenType::End => parser.reduce::<101>(),
            TokenType::For => parser.reduce::<101>(),
            TokenType::Function => parser.reduce::<101>(),
            TokenType::Goto => parser.reduce::<101>(),
            TokenType::If => parser.reduce::<101>(),
            TokenType::Local => parser.reduce::<101>(),
            TokenType::Repeat => parser.reduce::<101>(),
            TokenType::Return => parser.reduce::<101>(),
            TokenType::While => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::DoubleColon => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2128> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<103>(),
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::Break => parser.reduce::<103>(),
            TokenType::Do => parser.reduce::<103>(),
            TokenType::End => parser.reduce::<103>(),
            TokenType::For => parser.reduce::<103>(),
            TokenType::Function => parser.reduce::<103>(),
            TokenType::Goto => parser.reduce::<103>(),
            TokenType::If => parser.reduce::<103>(),
            TokenType::Local => parser.reduce::<103>(),
            TokenType::Repeat => parser.reduce::<103>(),
            TokenType::Return => parser.reduce::<103>(),
            TokenType::While => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::DoubleColon => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2129> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1215),
            TokenType::Or => parser.shift(1286),
            TokenType::Add => parser.shift(1313),
            TokenType::Sub => parser.shift(1321),
            TokenType::Mul => parser.shift(1345),
            TokenType::Div => parser.shift(1352),
            TokenType::Idiv => parser.shift(1369),
            TokenType::Mod => parser.shift(1399),
            TokenType::Pow => parser.shift(1439),
            TokenType::BitAnd => parser.shift(1471),
            TokenType::BitXor => parser.shift(1480),
            TokenType::BitOr => parser.shift(1490),
            TokenType::ShiftL => parser.shift(1509),
            TokenType::ShiftR => parser.shift(1520),
            TokenType::Eq => parser.shift(1522),
            TokenType::Neq => parser.shift(1531),
            TokenType::Leq => parser.shift(1547),
            TokenType::Geq => parser.shift(1567),
            TokenType::Less => parser.shift(1572),
            TokenType::Greater => parser.shift(1577),
            TokenType::Comma => parser.shift(2454),
            TokenType::Concat => parser.shift(1583),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2130> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<103>(),
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::Break => parser.reduce::<103>(),
            TokenType::Do => parser.reduce::<103>(),
            TokenType::For => parser.reduce::<103>(),
            TokenType::Function => parser.reduce::<103>(),
            TokenType::Goto => parser.reduce::<103>(),
            TokenType::If => parser.reduce::<103>(),
            TokenType::Local => parser.reduce::<103>(),
            TokenType::Repeat => parser.reduce::<103>(),
            TokenType::Return => parser.reduce::<103>(),
            TokenType::Until => parser.reduce::<103>(),
            TokenType::While => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::DoubleColon => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2131> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2556),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2132> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::Do => parser.reduce::<21>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Add => parser.shift(1299),
            TokenType::Sub => parser.shift(1316),
            TokenType::Mul => parser.shift(1342),
            TokenType::Div => parser.shift(1351),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Mod => parser.shift(1402),
            TokenType::Pow => parser.shift(1460),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitOr => parser.shift(1500),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::Eq => parser.shift(1534),
            TokenType::Neq => parser.shift(1557),
            TokenType::Leq => parser.shift(1569),
            TokenType::Geq => parser.shift(1575),
            TokenType::Less => parser.shift(1582),
            TokenType::Greater => parser.shift(1589),
            TokenType::Comma => parser.shift(2143),
            TokenType::Concat => parser.shift(1596),
            TokenType::StatForexp => parser.goto(2437),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2133> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<102>(),
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Break => parser.reduce::<102>(),
            TokenType::Do => parser.reduce::<102>(),
            TokenType::For => parser.reduce::<102>(),
            TokenType::Function => parser.reduce::<102>(),
            TokenType::Goto => parser.reduce::<102>(),
            TokenType::If => parser.reduce::<102>(),
            TokenType::Local => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Repeat => parser.reduce::<102>(),
            TokenType::Return => parser.reduce::<102>(),
            TokenType::While => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::DoubleColon => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            TokenType::Eof => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2134> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2548),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2135> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2555),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2136> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2440),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2137> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(511),
            TokenType::Do => parser.shift(517),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(532),
            TokenType::Function => parser.shift(533),
            TokenType::Goto => parser.shift(535),
            TokenType::If => parser.shift(551),
            TokenType::Local => parser.shift(615),
            TokenType::Repeat => parser.shift(616),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(618),
            TokenType::LParen => parser.shift(652),
            TokenType::DoubleColon => parser.shift(648),
            TokenType::SemiColon => parser.shift(644),
            TokenType::Block => parser.goto(2520),
            TokenType::BlockStat => parser.goto(466),
            TokenType::Stat => parser.goto(498),
            TokenType::Label => parser.goto(645),
            TokenType::Varlist => parser.goto(646),
            TokenType::Var => parser.goto(650),
            TokenType::Functioncall => parser.goto(647),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2138> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2554),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2139> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2550),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2140> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2549),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2141> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2553),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2142> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<102>(),
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::Break => parser.reduce::<102>(),
            TokenType::Do => parser.reduce::<102>(),
            TokenType::Else => parser.reduce::<102>(),
            TokenType::Elseif => parser.reduce::<102>(),
            TokenType::End => parser.reduce::<102>(),
            TokenType::For => parser.reduce::<102>(),
            TokenType::Function => parser.reduce::<102>(),
            TokenType::Goto => parser.reduce::<102>(),
            TokenType::If => parser.reduce::<102>(),
            TokenType::Local => parser.reduce::<102>(),
            TokenType::Repeat => parser.reduce::<102>(),
            TokenType::Return => parser.reduce::<102>(),
            TokenType::While => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::DoubleColon => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2143> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(45),
            TokenType::String(_) => parser.shift(106),
            TokenType::Integer(_) => parser.shift(107),
            TokenType::Float(_) => parser.shift(108),
            TokenType::False => parser.shift(109),
            TokenType::Function => parser.shift(141),
            TokenType::Nil => parser.shift(110),
            TokenType::Not => parser.shift(111),
            TokenType::True => parser.shift(116),
            TokenType::Sub => parser.shift(117),
            TokenType::Len => parser.shift(125),
            TokenType::BitXor => parser.shift(129),
            TokenType::LParen => parser.shift(53),
            TokenType::LCurly => parser.shift(142),
            TokenType::Dots => parser.shift(133),
            TokenType::Var => parser.goto(104),
            TokenType::Exp => parser.goto(2445),
            TokenType::Functioncall => parser.goto(105),
            TokenType::Functiondef => parser.goto(134),
            TokenType::Tableconstructor => parser.goto(135),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2144> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Then => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2145> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Comma => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2146> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<101>(),
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Break => parser.reduce::<101>(),
            TokenType::Do => parser.reduce::<101>(),
            TokenType::For => parser.reduce::<101>(),
            TokenType::Function => parser.reduce::<101>(),
            TokenType::Goto => parser.reduce::<101>(),
            TokenType::If => parser.reduce::<101>(),
            TokenType::Local => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Repeat => parser.reduce::<101>(),
            TokenType::Return => parser.reduce::<101>(),
            TokenType::While => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::DoubleColon => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            TokenType::Eof => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2147> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<101>(),
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Break => parser.reduce::<101>(),
            TokenType::Do => parser.reduce::<101>(),
            TokenType::End => parser.reduce::<101>(),
            TokenType::For => parser.reduce::<101>(),
            TokenType::Function => parser.reduce::<101>(),
            TokenType::Goto => parser.reduce::<101>(),
            TokenType::If => parser.reduce::<101>(),
            TokenType::Local => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Repeat => parser.reduce::<101>(),
            TokenType::Return => parser.reduce::<101>(),
            TokenType::While => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::DoubleColon => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Comma => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2148> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Until => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Comma => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2149> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::RSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2150> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2442),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2151> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2152> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Comma => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2153> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Do => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2154> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<28>(),
            TokenType::Break => parser.reduce::<28>(),
            TokenType::Do => parser.reduce::<28>(),
            TokenType::Else => parser.reduce::<28>(),
            TokenType::Elseif => parser.reduce::<28>(),
            TokenType::End => parser.reduce::<28>(),
            TokenType::For => parser.reduce::<28>(),
            TokenType::Function => parser.reduce::<28>(),
            TokenType::Goto => parser.reduce::<28>(),
            TokenType::If => parser.reduce::<28>(),
            TokenType::Local => parser.reduce::<28>(),
            TokenType::Repeat => parser.reduce::<28>(),
            TokenType::Return => parser.reduce::<28>(),
            TokenType::While => parser.reduce::<28>(),
            TokenType::LParen => parser.reduce::<28>(),
            TokenType::DoubleColon => parser.reduce::<28>(),
            TokenType::SemiColon => parser.reduce::<28>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2155> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Do => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Comma => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2156> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(656),
            TokenType::LParen => parser.shift(660),
            TokenType::LCurly => parser.shift(682),
            TokenType::Args => parser.goto(2443),
            TokenType::Tableconstructor => parser.goto(681),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2157> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1788),
            TokenType::LParen => parser.shift(1789),
            TokenType::LCurly => parser.shift(1852),
            TokenType::Args => parser.goto(2444),
            TokenType::Tableconstructor => parser.goto(1850),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2158> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<52>(),
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Break => parser.reduce::<52>(),
            TokenType::Do => parser.reduce::<52>(),
            TokenType::End => parser.reduce::<52>(),
            TokenType::For => parser.reduce::<52>(),
            TokenType::Function => parser.reduce::<52>(),
            TokenType::Goto => parser.reduce::<52>(),
            TokenType::If => parser.reduce::<52>(),
            TokenType::Local => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Repeat => parser.reduce::<52>(),
            TokenType::Return => parser.reduce::<52>(),
            TokenType::While => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::DoubleColon => parser.reduce::<52>(),
            TokenType::SemiColon => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2159> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<102>(),
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Break => parser.reduce::<102>(),
            TokenType::Do => parser.reduce::<102>(),
            TokenType::For => parser.reduce::<102>(),
            TokenType::Function => parser.reduce::<102>(),
            TokenType::Goto => parser.reduce::<102>(),
            TokenType::If => parser.reduce::<102>(),
            TokenType::Local => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Repeat => parser.reduce::<102>(),
            TokenType::Return => parser.reduce::<102>(),
            TokenType::Until => parser.reduce::<102>(),
            TokenType::While => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::DoubleColon => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Comma => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2160> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Comma => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            TokenType::Eof => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2161> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1828),
            TokenType::LParen => parser.shift(1832),
            TokenType::LCurly => parser.shift(1855),
            TokenType::Args => parser.goto(2446),
            TokenType::Tableconstructor => parser.goto(1853),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2162> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Until => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Comma => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2163> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(545),
            TokenType::LParen => parser.shift(547),
            TokenType::LCurly => parser.shift(575),
            TokenType::Args => parser.goto(2447),
            TokenType::Tableconstructor => parser.goto(573),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2164> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<101>(),
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Break => parser.reduce::<101>(),
            TokenType::Do => parser.reduce::<101>(),
            TokenType::For => parser.reduce::<101>(),
            TokenType::Function => parser.reduce::<101>(),
            TokenType::Goto => parser.reduce::<101>(),
            TokenType::If => parser.reduce::<101>(),
            TokenType::Local => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Repeat => parser.reduce::<101>(),
            TokenType::Return => parser.reduce::<101>(),
            TokenType::Until => parser.reduce::<101>(),
            TokenType::While => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::DoubleColon => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Comma => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2165> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1828),
            TokenType::LParen => parser.shift(1832),
            TokenType::LCurly => parser.shift(1855),
            TokenType::Args => parser.goto(2449),
            TokenType::Tableconstructor => parser.goto(1853),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2166> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(622),
            TokenType::LParen => parser.shift(627),
            TokenType::LCurly => parser.shift(677),
            TokenType::Args => parser.goto(2448),
            TokenType::Tableconstructor => parser.goto(671),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2167> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2168> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<23>(),
            TokenType::Break => parser.reduce::<23>(),
            TokenType::Do => parser.reduce::<23>(),
            TokenType::For => parser.reduce::<23>(),
            TokenType::Function => parser.reduce::<23>(),
            TokenType::Goto => parser.reduce::<23>(),
            TokenType::If => parser.reduce::<23>(),
            TokenType::Local => parser.reduce::<23>(),
            TokenType::Repeat => parser.reduce::<23>(),
            TokenType::Return => parser.reduce::<23>(),
            TokenType::While => parser.reduce::<23>(),
            TokenType::LParen => parser.reduce::<23>(),
            TokenType::DoubleColon => parser.reduce::<23>(),
            TokenType::SemiColon => parser.reduce::<23>(),
            TokenType::Eof => parser.reduce::<23>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2169> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<14>(),
            TokenType::And => parser.shift(2468),
            TokenType::Break => parser.reduce::<14>(),
            TokenType::Do => parser.reduce::<14>(),
            TokenType::Else => parser.reduce::<14>(),
            TokenType::Elseif => parser.reduce::<14>(),
            TokenType::End => parser.reduce::<14>(),
            TokenType::For => parser.reduce::<14>(),
            TokenType::Function => parser.reduce::<14>(),
            TokenType::Goto => parser.reduce::<14>(),
            TokenType::If => parser.reduce::<14>(),
            TokenType::Local => parser.reduce::<14>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Repeat => parser.reduce::<14>(),
            TokenType::Return => parser.reduce::<14>(),
            TokenType::While => parser.reduce::<14>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Sub => parser.shift(2560),
            TokenType::Mul => parser.shift(2585),
            TokenType::Div => parser.shift(2590),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Mod => parser.shift(2603),
            TokenType::Pow => parser.shift(2615),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitOr => parser.shift(2618),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::Eq => parser.shift(2621),
            TokenType::Neq => parser.shift(2622),
            TokenType::Leq => parser.shift(2623),
            TokenType::Geq => parser.shift(2624),
            TokenType::Less => parser.shift(2625),
            TokenType::Greater => parser.shift(2626),
            TokenType::LParen => parser.reduce::<14>(),
            TokenType::DoubleColon => parser.reduce::<14>(),
            TokenType::SemiColon => parser.reduce::<14>(),
            TokenType::Concat => parser.shift(2627),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2170> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2527),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2171> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            TokenType::Eof => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2172> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2173> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            TokenType::Eof => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2174> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(633),
            TokenType::LParen => parser.shift(635),
            TokenType::LCurly => parser.shift(687),
            TokenType::Args => parser.goto(2450),
            TokenType::Tableconstructor => parser.goto(685),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2175> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::RCurly => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Comma => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2176> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Do => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2177> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::RParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2178> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::RParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2179> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::End => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2180> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::Until => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2181> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Until => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2182> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2522),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2183> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.shift(1828),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::Until => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            // Shift(1832)-Reduce(71)
            TokenType::LParen => parser.shift(1832),
            TokenType::LSquare => parser.shift(2455),
            TokenType::LCurly => parser.shift(1855),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.shift(2524),
            TokenType::Dot => parser.shift(2523),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(2525),
            TokenType::Tableconstructor => parser.goto(1853),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2184> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Then => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2185> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::RParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Comma => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2186> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2521),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2187> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<58>(),
            TokenType::Elseif => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2188> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1788),
            TokenType::LParen => parser.shift(1789),
            TokenType::LCurly => parser.shift(1852),
            TokenType::Args => parser.goto(2459),
            TokenType::Tableconstructor => parser.goto(1850),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2189> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<53>(),
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Break => parser.reduce::<53>(),
            TokenType::Do => parser.reduce::<53>(),
            TokenType::For => parser.reduce::<53>(),
            TokenType::Function => parser.reduce::<53>(),
            TokenType::Goto => parser.reduce::<53>(),
            TokenType::If => parser.reduce::<53>(),
            TokenType::Local => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Repeat => parser.reduce::<53>(),
            TokenType::Return => parser.reduce::<53>(),
            TokenType::Until => parser.reduce::<53>(),
            TokenType::While => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::DoubleColon => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2190> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2191> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::Else => parser.reduce::<48>(),
            TokenType::Elseif => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2192> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::End => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Comma => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2193> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::Until => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2194> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<110>(),
            TokenType::Break => parser.reduce::<110>(),
            TokenType::Do => parser.reduce::<110>(),
            TokenType::For => parser.reduce::<110>(),
            TokenType::Function => parser.reduce::<110>(),
            TokenType::Goto => parser.reduce::<110>(),
            TokenType::If => parser.reduce::<110>(),
            TokenType::Local => parser.reduce::<110>(),
            TokenType::Repeat => parser.reduce::<110>(),
            TokenType::Return => parser.reduce::<110>(),
            TokenType::While => parser.reduce::<110>(),
            TokenType::LParen => parser.reduce::<110>(),
            TokenType::DoubleColon => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            TokenType::Eof => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2195> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Do => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Comma => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2196> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2197> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Then => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2198> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(628),
            TokenType::LParen => parser.shift(629),
            TokenType::LCurly => parser.shift(686),
            TokenType::Args => parser.goto(2457),
            TokenType::Tableconstructor => parser.goto(684),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2199> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Comma => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            TokenType::Eof => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2200> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::Else => parser.reduce::<58>(),
            TokenType::Elseif => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2201> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::End => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2202> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2456),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2203> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2458),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2204> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2547),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2205> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2544),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2206> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::RParen => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2207> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2519),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2208> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2209> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::End => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Comma => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2210> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<110>(),
            TokenType::Do => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2211> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<104>(),
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Break => parser.reduce::<104>(),
            TokenType::Do => parser.reduce::<104>(),
            TokenType::For => parser.reduce::<104>(),
            TokenType::Function => parser.reduce::<104>(),
            TokenType::Goto => parser.reduce::<104>(),
            TokenType::If => parser.reduce::<104>(),
            TokenType::Local => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Repeat => parser.reduce::<104>(),
            TokenType::Return => parser.reduce::<104>(),
            TokenType::Until => parser.reduce::<104>(),
            TokenType::While => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::DoubleColon => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Comma => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2212> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2213> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<53>(),
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Break => parser.reduce::<53>(),
            TokenType::Do => parser.reduce::<53>(),
            TokenType::End => parser.reduce::<53>(),
            TokenType::For => parser.reduce::<53>(),
            TokenType::Function => parser.reduce::<53>(),
            TokenType::Goto => parser.reduce::<53>(),
            TokenType::If => parser.reduce::<53>(),
            TokenType::Local => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Repeat => parser.reduce::<53>(),
            TokenType::Return => parser.reduce::<53>(),
            TokenType::While => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::DoubleColon => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2214> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<104>(),
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::Break => parser.reduce::<104>(),
            TokenType::Do => parser.reduce::<104>(),
            TokenType::Else => parser.reduce::<104>(),
            TokenType::Elseif => parser.reduce::<104>(),
            TokenType::End => parser.reduce::<104>(),
            TokenType::For => parser.reduce::<104>(),
            TokenType::Function => parser.reduce::<104>(),
            TokenType::Goto => parser.reduce::<104>(),
            TokenType::If => parser.reduce::<104>(),
            TokenType::Local => parser.reduce::<104>(),
            TokenType::Repeat => parser.reduce::<104>(),
            TokenType::Return => parser.reduce::<104>(),
            TokenType::While => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::DoubleColon => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2215> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            TokenType::Eof => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2216> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::End => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2217> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.shift(1788),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            // Shift(1789)-Reduce(71)
            TokenType::LParen => parser.shift(1789),
            TokenType::LSquare => parser.shift(2477),
            TokenType::LCurly => parser.shift(1852),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.shift(2530),
            TokenType::Dot => parser.shift(2529),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(2531),
            TokenType::Tableconstructor => parser.goto(1850),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2218> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2219> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Comma => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2220> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::End => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2221> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<52>(),
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Break => parser.reduce::<52>(),
            TokenType::Do => parser.reduce::<52>(),
            TokenType::For => parser.reduce::<52>(),
            TokenType::Function => parser.reduce::<52>(),
            TokenType::Goto => parser.reduce::<52>(),
            TokenType::If => parser.reduce::<52>(),
            TokenType::Local => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Repeat => parser.reduce::<52>(),
            TokenType::Return => parser.reduce::<52>(),
            TokenType::Until => parser.reduce::<52>(),
            TokenType::While => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::DoubleColon => parser.reduce::<52>(),
            TokenType::SemiColon => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2222> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Do => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Comma => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2223> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2546),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2224> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::End => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Comma => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2225> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<102>(),
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Break => parser.reduce::<102>(),
            TokenType::Do => parser.reduce::<102>(),
            TokenType::End => parser.reduce::<102>(),
            TokenType::For => parser.reduce::<102>(),
            TokenType::Function => parser.reduce::<102>(),
            TokenType::Goto => parser.reduce::<102>(),
            TokenType::If => parser.reduce::<102>(),
            TokenType::Local => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Repeat => parser.reduce::<102>(),
            TokenType::Return => parser.reduce::<102>(),
            TokenType::While => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::DoubleColon => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Comma => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2226> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2227> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2545),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2228> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2533),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2229> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(675),
            TokenType::LParen => parser.shift(676),
            TokenType::LCurly => parser.shift(731),
            TokenType::Args => parser.goto(2487),
            TokenType::Tableconstructor => parser.goto(730),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2230> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::Until => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2231> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2232> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::End => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2233> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2526),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2234> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Until => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Comma => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2235> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Until => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2236> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2532),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2237> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2489),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2238> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2543),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2239> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2240> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<104>(),
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Break => parser.reduce::<104>(),
            TokenType::Do => parser.reduce::<104>(),
            TokenType::For => parser.reduce::<104>(),
            TokenType::Function => parser.reduce::<104>(),
            TokenType::Goto => parser.reduce::<104>(),
            TokenType::If => parser.reduce::<104>(),
            TokenType::Local => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Repeat => parser.reduce::<104>(),
            TokenType::Return => parser.reduce::<104>(),
            TokenType::While => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::DoubleColon => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            TokenType::Eof => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2241> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<109>(),
            TokenType::And => parser.reduce::<109>(),
            TokenType::Break => parser.reduce::<109>(),
            TokenType::Do => parser.reduce::<109>(),
            TokenType::Else => parser.reduce::<109>(),
            TokenType::Elseif => parser.reduce::<109>(),
            TokenType::End => parser.reduce::<109>(),
            TokenType::For => parser.reduce::<109>(),
            TokenType::Function => parser.reduce::<109>(),
            TokenType::Goto => parser.reduce::<109>(),
            TokenType::If => parser.reduce::<109>(),
            TokenType::Local => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Repeat => parser.reduce::<109>(),
            TokenType::Return => parser.reduce::<109>(),
            TokenType::While => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::LParen => parser.reduce::<109>(),
            TokenType::DoubleColon => parser.reduce::<109>(),
            TokenType::SemiColon => parser.reduce::<109>(),
            TokenType::Comma => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2242> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(2509),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2243> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<104>(),
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Break => parser.reduce::<104>(),
            TokenType::Do => parser.reduce::<104>(),
            TokenType::End => parser.reduce::<104>(),
            TokenType::For => parser.reduce::<104>(),
            TokenType::Function => parser.reduce::<104>(),
            TokenType::Goto => parser.reduce::<104>(),
            TokenType::If => parser.reduce::<104>(),
            TokenType::Local => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Repeat => parser.reduce::<104>(),
            TokenType::Return => parser.reduce::<104>(),
            TokenType::While => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::DoubleColon => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Comma => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2244> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(35),
            TokenType::String(_) => parser.shift(98),
            TokenType::Integer(_) => parser.shift(99),
            TokenType::Float(_) => parser.shift(100),
            TokenType::False => parser.shift(101),
            TokenType::Function => parser.shift(143),
            TokenType::Nil => parser.shift(102),
            TokenType::Not => parser.shift(103),
            TokenType::True => parser.shift(112),
            TokenType::Sub => parser.shift(113),
            TokenType::Len => parser.shift(124),
            TokenType::BitXor => parser.shift(128),
            TokenType::LParen => parser.shift(50),
            TokenType::LCurly => parser.shift(144),
            TokenType::Dots => parser.shift(132),
            TokenType::Var => parser.goto(96),
            TokenType::Exp => parser.goto(2528),
            TokenType::Functioncall => parser.goto(97),
            TokenType::Functiondef => parser.goto(136),
            TokenType::Tableconstructor => parser.goto(137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2245> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2557),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2246> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2581),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2247> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::Until => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2248> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::Else => parser.reduce::<117>(),
            TokenType::Elseif => parser.reduce::<117>(),
            TokenType::End => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2249> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Until => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2250> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2251> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2493),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2252> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<100>(),
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::Break => parser.reduce::<100>(),
            TokenType::Do => parser.reduce::<100>(),
            TokenType::Else => parser.reduce::<100>(),
            TokenType::Elseif => parser.reduce::<100>(),
            TokenType::End => parser.reduce::<100>(),
            TokenType::For => parser.reduce::<100>(),
            TokenType::Function => parser.reduce::<100>(),
            TokenType::Goto => parser.reduce::<100>(),
            TokenType::If => parser.reduce::<100>(),
            TokenType::Local => parser.reduce::<100>(),
            TokenType::Repeat => parser.reduce::<100>(),
            TokenType::Return => parser.reduce::<100>(),
            TokenType::While => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::DoubleColon => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2253> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<109>(),
            TokenType::Else => parser.reduce::<109>(),
            TokenType::Elseif => parser.reduce::<109>(),
            TokenType::End => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::SemiColon => parser.reduce::<109>(),
            TokenType::Comma => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2254> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(2516),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2255> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<16>(),
            TokenType::Elseif => parser.shift(1147),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatElseif => parser.goto(2465),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2256> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2257> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2460),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2258> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2484),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2259> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2466),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2260> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Else => parser.reduce::<98>(),
            TokenType::Elseif => parser.reduce::<98>(),
            TokenType::End => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Comma => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2261> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Else => parser.reduce::<108>(),
            TokenType::Elseif => parser.reduce::<108>(),
            TokenType::End => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Comma => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2262> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(2463),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2263> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2485),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2264> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Comma => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2265> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(2577),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2266> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2491),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2267> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2504),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2268> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2505),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2269> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Else => parser.reduce::<99>(),
            TokenType::Elseif => parser.reduce::<99>(),
            TokenType::End => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Comma => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2270> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2479),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2271> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2486),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2272> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::End => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Comma => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2273> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2497),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2274> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2517),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2275> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<19>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2276> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2498),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2277> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2495),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2278> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Do => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Comma => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2279> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(2475),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2280> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2496),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2281> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2502),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2282> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Until => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Comma => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2283> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2510),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2284> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2480),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2285> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2501),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2286> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<100>(),
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Break => parser.reduce::<100>(),
            TokenType::Do => parser.reduce::<100>(),
            TokenType::End => parser.reduce::<100>(),
            TokenType::For => parser.reduce::<100>(),
            TokenType::Function => parser.reduce::<100>(),
            TokenType::Goto => parser.reduce::<100>(),
            TokenType::If => parser.reduce::<100>(),
            TokenType::Local => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Repeat => parser.reduce::<100>(),
            TokenType::Return => parser.reduce::<100>(),
            TokenType::While => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::DoubleColon => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Comma => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2287> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2467),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2288> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2462),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2289> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::Until => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2290> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2596),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2291> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2511),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2292> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2503),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2293> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2514),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2294> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2513),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2295> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2488),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2296> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2492),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2297> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<100>(),
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Break => parser.reduce::<100>(),
            TokenType::Do => parser.reduce::<100>(),
            TokenType::For => parser.reduce::<100>(),
            TokenType::Function => parser.reduce::<100>(),
            TokenType::Goto => parser.reduce::<100>(),
            TokenType::If => parser.reduce::<100>(),
            TokenType::Local => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Repeat => parser.reduce::<100>(),
            TokenType::Return => parser.reduce::<100>(),
            TokenType::Until => parser.reduce::<100>(),
            TokenType::While => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::DoubleColon => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Comma => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2298> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<100>(),
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Break => parser.reduce::<100>(),
            TokenType::Do => parser.reduce::<100>(),
            TokenType::For => parser.reduce::<100>(),
            TokenType::Function => parser.reduce::<100>(),
            TokenType::Goto => parser.reduce::<100>(),
            TokenType::If => parser.reduce::<100>(),
            TokenType::Local => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Repeat => parser.reduce::<100>(),
            TokenType::Return => parser.reduce::<100>(),
            TokenType::While => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::DoubleColon => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            TokenType::Eof => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2299> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<99>(),
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Break => parser.reduce::<99>(),
            TokenType::Do => parser.reduce::<99>(),
            TokenType::Else => parser.reduce::<99>(),
            TokenType::Elseif => parser.reduce::<99>(),
            TokenType::End => parser.reduce::<99>(),
            TokenType::For => parser.reduce::<99>(),
            TokenType::Function => parser.reduce::<99>(),
            TokenType::Goto => parser.reduce::<99>(),
            TokenType::If => parser.reduce::<99>(),
            TokenType::Local => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Repeat => parser.reduce::<99>(),
            TokenType::Return => parser.reduce::<99>(),
            TokenType::While => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::DoubleColon => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Comma => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2300> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<108>(),
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Break => parser.reduce::<108>(),
            TokenType::Do => parser.reduce::<108>(),
            TokenType::Else => parser.reduce::<108>(),
            TokenType::Elseif => parser.reduce::<108>(),
            TokenType::End => parser.reduce::<108>(),
            TokenType::For => parser.reduce::<108>(),
            TokenType::Function => parser.reduce::<108>(),
            TokenType::Goto => parser.reduce::<108>(),
            TokenType::If => parser.reduce::<108>(),
            TokenType::Local => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Repeat => parser.reduce::<108>(),
            TokenType::Return => parser.reduce::<108>(),
            TokenType::While => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::DoubleColon => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Comma => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2301> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2461),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2302> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2515),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2303> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<98>(),
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Break => parser.reduce::<98>(),
            TokenType::Do => parser.reduce::<98>(),
            TokenType::Else => parser.reduce::<98>(),
            TokenType::Elseif => parser.reduce::<98>(),
            TokenType::End => parser.reduce::<98>(),
            TokenType::For => parser.reduce::<98>(),
            TokenType::Function => parser.reduce::<98>(),
            TokenType::Goto => parser.reduce::<98>(),
            TokenType::If => parser.reduce::<98>(),
            TokenType::Local => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Repeat => parser.reduce::<98>(),
            TokenType::Return => parser.reduce::<98>(),
            TokenType::While => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::DoubleColon => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Comma => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2304> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(2576),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2305> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2584),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2306> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Else => parser.reduce::<107>(),
            TokenType::Elseif => parser.reduce::<107>(),
            TokenType::End => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Comma => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2307> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(2587),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2308> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2482),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2309> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2481),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2310> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2518),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2311> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2507),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2312> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2499),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2313> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2490),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2314> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2506),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2315> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<107>(),
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Break => parser.reduce::<107>(),
            TokenType::Do => parser.reduce::<107>(),
            TokenType::Else => parser.reduce::<107>(),
            TokenType::Elseif => parser.reduce::<107>(),
            TokenType::End => parser.reduce::<107>(),
            TokenType::For => parser.reduce::<107>(),
            TokenType::Function => parser.reduce::<107>(),
            TokenType::Goto => parser.reduce::<107>(),
            TokenType::If => parser.reduce::<107>(),
            TokenType::Local => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Repeat => parser.reduce::<107>(),
            TokenType::Return => parser.reduce::<107>(),
            TokenType::While => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::DoubleColon => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Comma => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2316> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2500),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2317> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2566),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2318> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(2588),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2319> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2464),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2320> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2508),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2321> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2512),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2322> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.shift(2538),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::Else => parser.reduce::<69>(),
            TokenType::Elseif => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            // Shift(2541)-Reduce(69)
            TokenType::LParen => parser.shift(2541),
            TokenType::LSquare => parser.shift(2483),
            TokenType::LCurly => parser.shift(2552),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.shift(2539),
            TokenType::Dot => parser.shift(2534),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Args => parser.goto(2540),
            TokenType::Tableconstructor => parser.goto(2551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2323> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<93>(),
            TokenType::Else => parser.reduce::<93>(),
            TokenType::Elseif => parser.reduce::<93>(),
            TokenType::End => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::SemiColon => parser.reduce::<93>(),
            TokenType::Comma => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2324> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.shift(2538),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::Else => parser.reduce::<70>(),
            TokenType::Elseif => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            // Shift(2541)-Reduce(70)
            TokenType::LParen => parser.shift(2541),
            TokenType::LSquare => parser.shift(2494),
            TokenType::LCurly => parser.shift(2552),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.shift(2536),
            TokenType::Dot => parser.shift(2535),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Args => parser.goto(2537),
            TokenType::Tableconstructor => parser.goto(2551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2325> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2570),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2326> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::Else => parser.reduce::<64>(),
            TokenType::Elseif => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.reduce::<64>(),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Concat => parser.reduce::<64>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2327> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::Else => parser.reduce::<65>(),
            TokenType::Elseif => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2328> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => parser.reduce::<66>(),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::Else => parser.reduce::<66>(),
            TokenType::Elseif => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => parser.reduce::<66>(),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => parser.reduce::<66>(),
            TokenType::Sub => parser.reduce::<66>(),
            TokenType::Mul => parser.reduce::<66>(),
            TokenType::Div => parser.reduce::<66>(),
            TokenType::Idiv => parser.reduce::<66>(),
            TokenType::Mod => parser.reduce::<66>(),
            TokenType::Pow => parser.reduce::<66>(),
            TokenType::BitAnd => parser.reduce::<66>(),
            TokenType::BitXor => parser.reduce::<66>(),
            TokenType::BitOr => parser.reduce::<66>(),
            TokenType::ShiftL => parser.reduce::<66>(),
            TokenType::ShiftR => parser.reduce::<66>(),
            TokenType::Eq => parser.reduce::<66>(),
            TokenType::Neq => parser.reduce::<66>(),
            TokenType::Leq => parser.reduce::<66>(),
            TokenType::Geq => parser.reduce::<66>(),
            TokenType::Less => parser.reduce::<66>(),
            TokenType::Greater => parser.reduce::<66>(),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Concat => parser.reduce::<66>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2329> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::Else => parser.reduce::<62>(),
            TokenType::Elseif => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2330> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::Else => parser.reduce::<61>(),
            TokenType::Elseif => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2331> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2597),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2332> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2559),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2333> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<95>(),
            TokenType::Else => parser.reduce::<95>(),
            TokenType::Elseif => parser.reduce::<95>(),
            TokenType::End => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Comma => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2334> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2579),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2335> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2583),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2336> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::Else => parser.reduce::<63>(),
            TokenType::Elseif => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2337> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2572),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2338> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<94>(),
            TokenType::Else => parser.reduce::<94>(),
            TokenType::Elseif => parser.reduce::<94>(),
            TokenType::End => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::SemiColon => parser.reduce::<94>(),
            TokenType::Comma => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2339> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2607),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2340> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::And => parser.reduce::<96>(),
            TokenType::Else => parser.reduce::<96>(),
            TokenType::Elseif => parser.reduce::<96>(),
            TokenType::End => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Comma => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2341> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<93>(),
            TokenType::And => parser.reduce::<93>(),
            TokenType::Break => parser.reduce::<93>(),
            TokenType::Do => parser.reduce::<93>(),
            TokenType::Else => parser.reduce::<93>(),
            TokenType::Elseif => parser.reduce::<93>(),
            TokenType::End => parser.reduce::<93>(),
            TokenType::For => parser.reduce::<93>(),
            TokenType::Function => parser.reduce::<93>(),
            TokenType::Goto => parser.reduce::<93>(),
            TokenType::If => parser.reduce::<93>(),
            TokenType::Local => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Repeat => parser.reduce::<93>(),
            TokenType::Return => parser.reduce::<93>(),
            TokenType::While => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::LParen => parser.reduce::<93>(),
            TokenType::DoubleColon => parser.reduce::<93>(),
            TokenType::SemiColon => parser.reduce::<93>(),
            TokenType::Comma => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2342> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2569),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2343> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(577),
            TokenType::Or => parser.shift(668),
            TokenType::Add => parser.shift(732),
            TokenType::Sub => parser.shift(766),
            TokenType::Mul => parser.shift(786),
            TokenType::Div => parser.shift(799),
            TokenType::Idiv => parser.shift(838),
            TokenType::Mod => parser.shift(890),
            TokenType::Pow => parser.shift(897),
            TokenType::BitAnd => parser.shift(910),
            TokenType::BitXor => parser.shift(923),
            TokenType::BitOr => parser.shift(932),
            TokenType::ShiftL => parser.shift(950),
            TokenType::ShiftR => parser.shift(957),
            TokenType::Eq => parser.shift(963),
            TokenType::Neq => parser.shift(973),
            TokenType::Leq => parser.shift(980),
            TokenType::Geq => parser.shift(988),
            TokenType::Less => parser.shift(991),
            TokenType::Greater => parser.shift(993),
            TokenType::RCurly => parser.reduce::<124>(),
            TokenType::SemiColon => parser.reduce::<124>(),
            TokenType::Comma => parser.reduce::<124>(),
            TokenType::Concat => parser.shift(997),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2344> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2563),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2345> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<95>(),
            TokenType::And => parser.reduce::<95>(),
            TokenType::Break => parser.reduce::<95>(),
            TokenType::Do => parser.reduce::<95>(),
            TokenType::Else => parser.reduce::<95>(),
            TokenType::Elseif => parser.reduce::<95>(),
            TokenType::End => parser.reduce::<95>(),
            TokenType::For => parser.reduce::<95>(),
            TokenType::Function => parser.reduce::<95>(),
            TokenType::Goto => parser.reduce::<95>(),
            TokenType::If => parser.reduce::<95>(),
            TokenType::Local => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Repeat => parser.reduce::<95>(),
            TokenType::Return => parser.reduce::<95>(),
            TokenType::While => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::LParen => parser.reduce::<95>(),
            TokenType::DoubleColon => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Comma => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2346> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2589),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2347> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2473),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2348> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2595),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2349> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2568),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2350> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2471),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2351> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2472),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2352> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2580),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2353> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2474),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2354> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2469),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2355> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2470),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2356> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2592),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2357> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<94>(),
            TokenType::And => parser.reduce::<94>(),
            TokenType::Break => parser.reduce::<94>(),
            TokenType::Do => parser.reduce::<94>(),
            TokenType::Else => parser.reduce::<94>(),
            TokenType::Elseif => parser.reduce::<94>(),
            TokenType::End => parser.reduce::<94>(),
            TokenType::For => parser.reduce::<94>(),
            TokenType::Function => parser.reduce::<94>(),
            TokenType::Goto => parser.reduce::<94>(),
            TokenType::If => parser.reduce::<94>(),
            TokenType::Local => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Repeat => parser.reduce::<94>(),
            TokenType::Return => parser.reduce::<94>(),
            TokenType::While => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::LParen => parser.reduce::<94>(),
            TokenType::DoubleColon => parser.reduce::<94>(),
            TokenType::SemiColon => parser.reduce::<94>(),
            TokenType::Comma => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2358> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2565),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2359> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2611),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2360> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<97>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Break => parser.reduce::<97>(),
            TokenType::Do => parser.reduce::<97>(),
            TokenType::End => parser.reduce::<97>(),
            TokenType::For => parser.reduce::<97>(),
            TokenType::Function => parser.reduce::<97>(),
            TokenType::Goto => parser.reduce::<97>(),
            TokenType::If => parser.reduce::<97>(),
            TokenType::Local => parser.reduce::<97>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Repeat => parser.reduce::<97>(),
            TokenType::Return => parser.reduce::<97>(),
            TokenType::While => parser.reduce::<97>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::LParen => parser.reduce::<97>(),
            TokenType::DoubleColon => parser.reduce::<97>(),
            TokenType::SemiColon => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2361> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::End => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2362> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2571),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2363> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<89>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Break => parser.reduce::<89>(),
            TokenType::Do => parser.reduce::<89>(),
            TokenType::End => parser.reduce::<89>(),
            TokenType::For => parser.reduce::<89>(),
            TokenType::Function => parser.reduce::<89>(),
            TokenType::Goto => parser.reduce::<89>(),
            TokenType::If => parser.reduce::<89>(),
            TokenType::Local => parser.reduce::<89>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Repeat => parser.reduce::<89>(),
            TokenType::Return => parser.reduce::<89>(),
            TokenType::While => parser.reduce::<89>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::LParen => parser.reduce::<89>(),
            TokenType::DoubleColon => parser.reduce::<89>(),
            TokenType::SemiColon => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2364> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::Until => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2365> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<90>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Break => parser.reduce::<90>(),
            TokenType::Do => parser.reduce::<90>(),
            TokenType::For => parser.reduce::<90>(),
            TokenType::Function => parser.reduce::<90>(),
            TokenType::Goto => parser.reduce::<90>(),
            TokenType::If => parser.reduce::<90>(),
            TokenType::Local => parser.reduce::<90>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Repeat => parser.reduce::<90>(),
            TokenType::Return => parser.reduce::<90>(),
            TokenType::Until => parser.reduce::<90>(),
            TokenType::While => parser.reduce::<90>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::LParen => parser.reduce::<90>(),
            TokenType::DoubleColon => parser.reduce::<90>(),
            TokenType::SemiColon => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2366> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2367> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::End => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2368> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<82>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Break => parser.reduce::<82>(),
            TokenType::Do => parser.reduce::<82>(),
            TokenType::For => parser.reduce::<82>(),
            TokenType::Function => parser.reduce::<82>(),
            TokenType::Goto => parser.reduce::<82>(),
            TokenType::If => parser.reduce::<82>(),
            TokenType::Local => parser.reduce::<82>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Repeat => parser.reduce::<82>(),
            TokenType::Return => parser.reduce::<82>(),
            TokenType::Until => parser.reduce::<82>(),
            TokenType::While => parser.reduce::<82>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::LParen => parser.reduce::<82>(),
            TokenType::DoubleColon => parser.reduce::<82>(),
            TokenType::SemiColon => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2369> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<84>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Break => parser.reduce::<84>(),
            TokenType::Do => parser.reduce::<84>(),
            TokenType::For => parser.reduce::<84>(),
            TokenType::Function => parser.reduce::<84>(),
            TokenType::Goto => parser.reduce::<84>(),
            TokenType::If => parser.reduce::<84>(),
            TokenType::Local => parser.reduce::<84>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Repeat => parser.reduce::<84>(),
            TokenType::Return => parser.reduce::<84>(),
            TokenType::Until => parser.reduce::<84>(),
            TokenType::While => parser.reduce::<84>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::LParen => parser.reduce::<84>(),
            TokenType::DoubleColon => parser.reduce::<84>(),
            TokenType::SemiColon => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2370> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<85>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Break => parser.reduce::<85>(),
            TokenType::Do => parser.reduce::<85>(),
            TokenType::For => parser.reduce::<85>(),
            TokenType::Function => parser.reduce::<85>(),
            TokenType::Goto => parser.reduce::<85>(),
            TokenType::If => parser.reduce::<85>(),
            TokenType::Local => parser.reduce::<85>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Repeat => parser.reduce::<85>(),
            TokenType::Return => parser.reduce::<85>(),
            TokenType::Until => parser.reduce::<85>(),
            TokenType::While => parser.reduce::<85>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::LParen => parser.reduce::<85>(),
            TokenType::DoubleColon => parser.reduce::<85>(),
            TokenType::SemiColon => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2371> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::Until => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2372> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<82>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Break => parser.reduce::<82>(),
            TokenType::Do => parser.reduce::<82>(),
            TokenType::End => parser.reduce::<82>(),
            TokenType::For => parser.reduce::<82>(),
            TokenType::Function => parser.reduce::<82>(),
            TokenType::Goto => parser.reduce::<82>(),
            TokenType::If => parser.reduce::<82>(),
            TokenType::Local => parser.reduce::<82>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Repeat => parser.reduce::<82>(),
            TokenType::Return => parser.reduce::<82>(),
            TokenType::While => parser.reduce::<82>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::LParen => parser.reduce::<82>(),
            TokenType::DoubleColon => parser.reduce::<82>(),
            TokenType::SemiColon => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2373> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::End => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2374> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<92>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Break => parser.reduce::<92>(),
            TokenType::Do => parser.reduce::<92>(),
            TokenType::End => parser.reduce::<92>(),
            TokenType::For => parser.reduce::<92>(),
            TokenType::Function => parser.reduce::<92>(),
            TokenType::Goto => parser.reduce::<92>(),
            TokenType::If => parser.reduce::<92>(),
            TokenType::Local => parser.reduce::<92>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Repeat => parser.reduce::<92>(),
            TokenType::Return => parser.reduce::<92>(),
            TokenType::While => parser.reduce::<92>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::LParen => parser.reduce::<92>(),
            TokenType::DoubleColon => parser.reduce::<92>(),
            TokenType::SemiColon => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2375> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<81>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Break => parser.reduce::<81>(),
            TokenType::Do => parser.reduce::<81>(),
            TokenType::For => parser.reduce::<81>(),
            TokenType::Function => parser.reduce::<81>(),
            TokenType::Goto => parser.reduce::<81>(),
            TokenType::If => parser.reduce::<81>(),
            TokenType::Local => parser.reduce::<81>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Repeat => parser.reduce::<81>(),
            TokenType::Return => parser.reduce::<81>(),
            TokenType::Until => parser.reduce::<81>(),
            TokenType::While => parser.reduce::<81>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::LParen => parser.reduce::<81>(),
            TokenType::DoubleColon => parser.reduce::<81>(),
            TokenType::SemiColon => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2376> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<83>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Break => parser.reduce::<83>(),
            TokenType::Do => parser.reduce::<83>(),
            TokenType::End => parser.reduce::<83>(),
            TokenType::For => parser.reduce::<83>(),
            TokenType::Function => parser.reduce::<83>(),
            TokenType::Goto => parser.reduce::<83>(),
            TokenType::If => parser.reduce::<83>(),
            TokenType::Local => parser.reduce::<83>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Repeat => parser.reduce::<83>(),
            TokenType::Return => parser.reduce::<83>(),
            TokenType::While => parser.reduce::<83>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::LParen => parser.reduce::<83>(),
            TokenType::DoubleColon => parser.reduce::<83>(),
            TokenType::SemiColon => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2377> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<91>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Break => parser.reduce::<91>(),
            TokenType::Do => parser.reduce::<91>(),
            TokenType::For => parser.reduce::<91>(),
            TokenType::Function => parser.reduce::<91>(),
            TokenType::Goto => parser.reduce::<91>(),
            TokenType::If => parser.reduce::<91>(),
            TokenType::Local => parser.reduce::<91>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Repeat => parser.reduce::<91>(),
            TokenType::Return => parser.reduce::<91>(),
            TokenType::Until => parser.reduce::<91>(),
            TokenType::While => parser.reduce::<91>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::LParen => parser.reduce::<91>(),
            TokenType::DoubleColon => parser.reduce::<91>(),
            TokenType::SemiColon => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2378> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<75>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Break => parser.reduce::<75>(),
            TokenType::Do => parser.reduce::<75>(),
            TokenType::For => parser.reduce::<75>(),
            TokenType::Function => parser.reduce::<75>(),
            TokenType::Goto => parser.reduce::<75>(),
            TokenType::If => parser.reduce::<75>(),
            TokenType::Local => parser.reduce::<75>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Repeat => parser.reduce::<75>(),
            TokenType::Return => parser.reduce::<75>(),
            TokenType::Until => parser.reduce::<75>(),
            TokenType::While => parser.reduce::<75>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::LParen => parser.reduce::<75>(),
            TokenType::DoubleColon => parser.reduce::<75>(),
            TokenType::SemiColon => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2379> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<92>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Break => parser.reduce::<92>(),
            TokenType::Do => parser.reduce::<92>(),
            TokenType::For => parser.reduce::<92>(),
            TokenType::Function => parser.reduce::<92>(),
            TokenType::Goto => parser.reduce::<92>(),
            TokenType::If => parser.reduce::<92>(),
            TokenType::Local => parser.reduce::<92>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Repeat => parser.reduce::<92>(),
            TokenType::Return => parser.reduce::<92>(),
            TokenType::Until => parser.reduce::<92>(),
            TokenType::While => parser.reduce::<92>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::LParen => parser.reduce::<92>(),
            TokenType::DoubleColon => parser.reduce::<92>(),
            TokenType::SemiColon => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2380> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::Until => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2381> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<83>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Break => parser.reduce::<83>(),
            TokenType::Do => parser.reduce::<83>(),
            TokenType::For => parser.reduce::<83>(),
            TokenType::Function => parser.reduce::<83>(),
            TokenType::Goto => parser.reduce::<83>(),
            TokenType::If => parser.reduce::<83>(),
            TokenType::Local => parser.reduce::<83>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Repeat => parser.reduce::<83>(),
            TokenType::Return => parser.reduce::<83>(),
            TokenType::Until => parser.reduce::<83>(),
            TokenType::While => parser.reduce::<83>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::LParen => parser.reduce::<83>(),
            TokenType::DoubleColon => parser.reduce::<83>(),
            TokenType::SemiColon => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2382> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<89>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Break => parser.reduce::<89>(),
            TokenType::Do => parser.reduce::<89>(),
            TokenType::For => parser.reduce::<89>(),
            TokenType::Function => parser.reduce::<89>(),
            TokenType::Goto => parser.reduce::<89>(),
            TokenType::If => parser.reduce::<89>(),
            TokenType::Local => parser.reduce::<89>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Repeat => parser.reduce::<89>(),
            TokenType::Return => parser.reduce::<89>(),
            TokenType::Until => parser.reduce::<89>(),
            TokenType::While => parser.reduce::<89>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::LParen => parser.reduce::<89>(),
            TokenType::DoubleColon => parser.reduce::<89>(),
            TokenType::SemiColon => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2383> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<81>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Break => parser.reduce::<81>(),
            TokenType::Do => parser.reduce::<81>(),
            TokenType::End => parser.reduce::<81>(),
            TokenType::For => parser.reduce::<81>(),
            TokenType::Function => parser.reduce::<81>(),
            TokenType::Goto => parser.reduce::<81>(),
            TokenType::If => parser.reduce::<81>(),
            TokenType::Local => parser.reduce::<81>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Repeat => parser.reduce::<81>(),
            TokenType::Return => parser.reduce::<81>(),
            TokenType::While => parser.reduce::<81>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::LParen => parser.reduce::<81>(),
            TokenType::DoubleColon => parser.reduce::<81>(),
            TokenType::SemiColon => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2384> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::Until => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2385> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<85>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Break => parser.reduce::<85>(),
            TokenType::Do => parser.reduce::<85>(),
            TokenType::End => parser.reduce::<85>(),
            TokenType::For => parser.reduce::<85>(),
            TokenType::Function => parser.reduce::<85>(),
            TokenType::Goto => parser.reduce::<85>(),
            TokenType::If => parser.reduce::<85>(),
            TokenType::Local => parser.reduce::<85>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Repeat => parser.reduce::<85>(),
            TokenType::Return => parser.reduce::<85>(),
            TokenType::While => parser.reduce::<85>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::LParen => parser.reduce::<85>(),
            TokenType::DoubleColon => parser.reduce::<85>(),
            TokenType::SemiColon => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2386> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2567),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2387> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2388> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<97>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Break => parser.reduce::<97>(),
            TokenType::Do => parser.reduce::<97>(),
            TokenType::For => parser.reduce::<97>(),
            TokenType::Function => parser.reduce::<97>(),
            TokenType::Goto => parser.reduce::<97>(),
            TokenType::If => parser.reduce::<97>(),
            TokenType::Local => parser.reduce::<97>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Repeat => parser.reduce::<97>(),
            TokenType::Return => parser.reduce::<97>(),
            TokenType::Until => parser.reduce::<97>(),
            TokenType::While => parser.reduce::<97>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::LParen => parser.reduce::<97>(),
            TokenType::DoubleColon => parser.reduce::<97>(),
            TokenType::SemiColon => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2389> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<84>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Break => parser.reduce::<84>(),
            TokenType::Do => parser.reduce::<84>(),
            TokenType::End => parser.reduce::<84>(),
            TokenType::For => parser.reduce::<84>(),
            TokenType::Function => parser.reduce::<84>(),
            TokenType::Goto => parser.reduce::<84>(),
            TokenType::If => parser.reduce::<84>(),
            TokenType::Local => parser.reduce::<84>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Repeat => parser.reduce::<84>(),
            TokenType::Return => parser.reduce::<84>(),
            TokenType::While => parser.reduce::<84>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::LParen => parser.reduce::<84>(),
            TokenType::DoubleColon => parser.reduce::<84>(),
            TokenType::SemiColon => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2390> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<86>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Break => parser.reduce::<86>(),
            TokenType::Do => parser.reduce::<86>(),
            TokenType::For => parser.reduce::<86>(),
            TokenType::Function => parser.reduce::<86>(),
            TokenType::Goto => parser.reduce::<86>(),
            TokenType::If => parser.reduce::<86>(),
            TokenType::Local => parser.reduce::<86>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Repeat => parser.reduce::<86>(),
            TokenType::Return => parser.reduce::<86>(),
            TokenType::Until => parser.reduce::<86>(),
            TokenType::While => parser.reduce::<86>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::LParen => parser.reduce::<86>(),
            TokenType::DoubleColon => parser.reduce::<86>(),
            TokenType::SemiColon => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2391> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::Until => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2392> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::Until => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Div => parser.shift(2000),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Mod => parser.shift(2058),
            TokenType::Pow => parser.shift(2082),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2393> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2394> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Div => parser.shift(2002),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Mod => parser.shift(2060),
            TokenType::Pow => parser.shift(2083),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2395> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::Until => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2396> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<75>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Break => parser.reduce::<75>(),
            TokenType::Do => parser.reduce::<75>(),
            TokenType::End => parser.reduce::<75>(),
            TokenType::For => parser.reduce::<75>(),
            TokenType::Function => parser.reduce::<75>(),
            TokenType::Goto => parser.reduce::<75>(),
            TokenType::If => parser.reduce::<75>(),
            TokenType::Local => parser.reduce::<75>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Repeat => parser.reduce::<75>(),
            TokenType::Return => parser.reduce::<75>(),
            TokenType::While => parser.reduce::<75>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::LParen => parser.reduce::<75>(),
            TokenType::DoubleColon => parser.reduce::<75>(),
            TokenType::SemiColon => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2397> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2398> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<90>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Break => parser.reduce::<90>(),
            TokenType::Do => parser.reduce::<90>(),
            TokenType::End => parser.reduce::<90>(),
            TokenType::For => parser.reduce::<90>(),
            TokenType::Function => parser.reduce::<90>(),
            TokenType::Goto => parser.reduce::<90>(),
            TokenType::If => parser.reduce::<90>(),
            TokenType::Local => parser.reduce::<90>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Repeat => parser.reduce::<90>(),
            TokenType::Return => parser.reduce::<90>(),
            TokenType::While => parser.reduce::<90>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::LParen => parser.reduce::<90>(),
            TokenType::DoubleColon => parser.reduce::<90>(),
            TokenType::SemiColon => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2399> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Div => parser.shift(2002),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Mod => parser.shift(2060),
            TokenType::Pow => parser.shift(2083),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2400> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::Until => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Div => parser.shift(2000),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Mod => parser.shift(2058),
            TokenType::Pow => parser.shift(2082),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2401> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<91>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Break => parser.reduce::<91>(),
            TokenType::Do => parser.reduce::<91>(),
            TokenType::End => parser.reduce::<91>(),
            TokenType::For => parser.reduce::<91>(),
            TokenType::Function => parser.reduce::<91>(),
            TokenType::Goto => parser.reduce::<91>(),
            TokenType::If => parser.reduce::<91>(),
            TokenType::Local => parser.reduce::<91>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Repeat => parser.reduce::<91>(),
            TokenType::Return => parser.reduce::<91>(),
            TokenType::While => parser.reduce::<91>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::LParen => parser.reduce::<91>(),
            TokenType::DoubleColon => parser.reduce::<91>(),
            TokenType::SemiColon => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2402> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2601),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2403> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<96>(),
            TokenType::And => parser.reduce::<96>(),
            TokenType::Break => parser.reduce::<96>(),
            TokenType::Do => parser.reduce::<96>(),
            TokenType::Else => parser.reduce::<96>(),
            TokenType::Elseif => parser.reduce::<96>(),
            TokenType::End => parser.reduce::<96>(),
            TokenType::For => parser.reduce::<96>(),
            TokenType::Function => parser.reduce::<96>(),
            TokenType::Goto => parser.reduce::<96>(),
            TokenType::If => parser.reduce::<96>(),
            TokenType::Local => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Repeat => parser.reduce::<96>(),
            TokenType::Return => parser.reduce::<96>(),
            TokenType::While => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::LParen => parser.reduce::<96>(),
            TokenType::DoubleColon => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Comma => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2404> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::And => parser.shift(1694),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.shift(1841),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::Until => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.shift(1885),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(1898),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(1979),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(2000),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(2015),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(2058),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(2082),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(2086),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(2088),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(2093),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(2095),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(2097),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(2099),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(2101),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(2103),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(2106),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(2108),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(2110),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(2111),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2405> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<86>(),
            TokenType::And => parser.shift(1695),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Break => parser.reduce::<86>(),
            TokenType::Do => parser.reduce::<86>(),
            TokenType::End => parser.reduce::<86>(),
            TokenType::For => parser.reduce::<86>(),
            TokenType::Function => parser.reduce::<86>(),
            TokenType::Goto => parser.reduce::<86>(),
            TokenType::If => parser.reduce::<86>(),
            TokenType::Local => parser.reduce::<86>(),
            TokenType::Or => parser.shift(1845),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Repeat => parser.reduce::<86>(),
            TokenType::Return => parser.reduce::<86>(),
            TokenType::While => parser.reduce::<86>(),
            TokenType::Add => parser.shift(1886),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(1901),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(1983),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(2002),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(2013),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(2060),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(2083),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(2087),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(2091),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(2092),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(2094),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(2096),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(2098),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(2100),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(2102),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(2104),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(2105),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(2107),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::LParen => parser.reduce::<86>(),
            TokenType::DoubleColon => parser.reduce::<86>(),
            TokenType::SemiColon => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(2109),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2406> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2578),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2407> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::Else => parser.reduce::<67>(),
            TokenType::Elseif => parser.reduce::<67>(),
            TokenType::End => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.reduce::<67>(),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2408> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2582),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2409> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::Else => parser.reduce::<68>(),
            TokenType::Elseif => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2410> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::Else => parser.reduce::<72>(),
            TokenType::Elseif => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2411> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2600),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2412> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2575),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2413> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2561),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2414> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2606),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2415> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(2478),
            TokenType::Funcbody => parser.goto(2476),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2416> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2574),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2417> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(2586),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2418> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2564),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2419> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2591),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2420> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2573),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2421> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1653),
            TokenType::String(_) => parser.shift(1861),
            TokenType::Integer(_) => parser.shift(1862),
            TokenType::Float(_) => parser.shift(1863),
            TokenType::False => parser.shift(1864),
            TokenType::Function => parser.shift(2006),
            TokenType::Nil => parser.shift(1865),
            TokenType::Not => parser.shift(1867),
            TokenType::True => parser.shift(1875),
            TokenType::Sub => parser.shift(1877),
            TokenType::Len => parser.shift(1887),
            TokenType::BitXor => parser.shift(1889),
            TokenType::LParen => parser.shift(1684),
            TokenType::LCurly => parser.shift(2007),
            TokenType::Dots => parser.shift(1948),
            TokenType::Var => parser.goto(1851),
            TokenType::Exp => parser.goto(2562),
            TokenType::Functioncall => parser.goto(1857),
            TokenType::Functiondef => parser.goto(1984),
            TokenType::Tableconstructor => parser.goto(1985),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2422> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2609),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2423> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2614),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2424> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2605),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2425> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2613),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2426> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2602),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2427> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2594),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2428> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2608),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2429> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2610),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2430> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2604),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2431> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2612),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2432> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2599),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2433> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1696),
            TokenType::String(_) => parser.shift(1878),
            TokenType::Integer(_) => parser.shift(1879),
            TokenType::Float(_) => parser.shift(1880),
            TokenType::False => parser.shift(1881),
            TokenType::Function => parser.shift(2089),
            TokenType::Nil => parser.shift(1882),
            TokenType::Not => parser.shift(1883),
            TokenType::True => parser.shift(1920),
            TokenType::Sub => parser.shift(1923),
            TokenType::Len => parser.shift(1987),
            TokenType::BitXor => parser.shift(2010),
            TokenType::LParen => parser.shift(1770),
            TokenType::LCurly => parser.shift(2090),
            TokenType::Dots => parser.shift(2075),
            TokenType::Var => parser.goto(1872),
            TokenType::Exp => parser.goto(2598),
            TokenType::Functioncall => parser.goto(1874),
            TokenType::Functiondef => parser.goto(2084),
            TokenType::Tableconstructor => parser.goto(2085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2434> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(2642),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2435> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<33>(),
            TokenType::Break => parser.reduce::<33>(),
            TokenType::Do => parser.reduce::<33>(),
            TokenType::Else => parser.reduce::<33>(),
            TokenType::Elseif => parser.reduce::<33>(),
            TokenType::End => parser.reduce::<33>(),
            TokenType::For => parser.reduce::<33>(),
            TokenType::Function => parser.reduce::<33>(),
            TokenType::Goto => parser.reduce::<33>(),
            TokenType::If => parser.reduce::<33>(),
            TokenType::Local => parser.reduce::<33>(),
            TokenType::Repeat => parser.reduce::<33>(),
            TokenType::Return => parser.reduce::<33>(),
            TokenType::While => parser.reduce::<33>(),
            TokenType::Assign => parser.reduce::<33>(),
            TokenType::LParen => parser.reduce::<33>(),
            TokenType::DoubleColon => parser.reduce::<33>(),
            TokenType::SemiColon => parser.reduce::<33>(),
            TokenType::Comma => parser.reduce::<33>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2436> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::End => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2437> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(2633),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2438> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::Else => parser.reduce::<32>(),
            TokenType::Elseif => parser.reduce::<32>(),
            TokenType::End => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Less => parser.shift(1668),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Attrib => parser.goto(2628),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2439> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::Until => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2440> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<15>(),
            TokenType::Break => parser.reduce::<15>(),
            TokenType::Do => parser.reduce::<15>(),
            TokenType::End => parser.reduce::<15>(),
            TokenType::For => parser.reduce::<15>(),
            TokenType::Function => parser.reduce::<15>(),
            TokenType::Goto => parser.reduce::<15>(),
            TokenType::If => parser.reduce::<15>(),
            TokenType::Local => parser.reduce::<15>(),
            TokenType::Repeat => parser.reduce::<15>(),
            TokenType::Return => parser.reduce::<15>(),
            TokenType::While => parser.reduce::<15>(),
            TokenType::LParen => parser.reduce::<15>(),
            TokenType::DoubleColon => parser.reduce::<15>(),
            TokenType::SemiColon => parser.reduce::<15>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2441> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2685),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2442> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<15>(),
            TokenType::Break => parser.reduce::<15>(),
            TokenType::Do => parser.reduce::<15>(),
            TokenType::For => parser.reduce::<15>(),
            TokenType::Function => parser.reduce::<15>(),
            TokenType::Goto => parser.reduce::<15>(),
            TokenType::If => parser.reduce::<15>(),
            TokenType::Local => parser.reduce::<15>(),
            TokenType::Repeat => parser.reduce::<15>(),
            TokenType::Return => parser.reduce::<15>(),
            TokenType::Until => parser.reduce::<15>(),
            TokenType::While => parser.reduce::<15>(),
            TokenType::LParen => parser.reduce::<15>(),
            TokenType::DoubleColon => parser.reduce::<15>(),
            TokenType::SemiColon => parser.reduce::<15>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2443> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::RSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2444> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<101>(),
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Break => parser.reduce::<101>(),
            TokenType::Do => parser.reduce::<101>(),
            TokenType::End => parser.reduce::<101>(),
            TokenType::For => parser.reduce::<101>(),
            TokenType::Function => parser.reduce::<101>(),
            TokenType::Goto => parser.reduce::<101>(),
            TokenType::If => parser.reduce::<101>(),
            TokenType::Local => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Repeat => parser.reduce::<101>(),
            TokenType::Return => parser.reduce::<101>(),
            TokenType::While => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::DoubleColon => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2445> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(214),
            TokenType::Do => parser.reduce::<22>(),
            TokenType::Or => parser.shift(257),
            TokenType::Add => parser.shift(290),
            TokenType::Sub => parser.shift(329),
            TokenType::Mul => parser.shift(352),
            TokenType::Div => parser.shift(362),
            TokenType::Idiv => parser.shift(373),
            TokenType::Mod => parser.shift(383),
            TokenType::Pow => parser.shift(389),
            TokenType::BitAnd => parser.shift(393),
            TokenType::BitXor => parser.shift(403),
            TokenType::BitOr => parser.shift(417),
            TokenType::ShiftL => parser.shift(426),
            TokenType::ShiftR => parser.shift(432),
            TokenType::Eq => parser.shift(437),
            TokenType::Neq => parser.shift(440),
            TokenType::Leq => parser.shift(444),
            TokenType::Geq => parser.shift(450),
            TokenType::Less => parser.shift(452),
            TokenType::Greater => parser.shift(454),
            TokenType::Concat => parser.shift(455),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2446> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<101>(),
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Break => parser.reduce::<101>(),
            TokenType::Do => parser.reduce::<101>(),
            TokenType::For => parser.reduce::<101>(),
            TokenType::Function => parser.reduce::<101>(),
            TokenType::Goto => parser.reduce::<101>(),
            TokenType::If => parser.reduce::<101>(),
            TokenType::Local => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Repeat => parser.reduce::<101>(),
            TokenType::Return => parser.reduce::<101>(),
            TokenType::Until => parser.reduce::<101>(),
            TokenType::While => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::DoubleColon => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2447> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2448> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::RParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Comma => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2449> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<102>(),
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Break => parser.reduce::<102>(),
            TokenType::Do => parser.reduce::<102>(),
            TokenType::For => parser.reduce::<102>(),
            TokenType::Function => parser.reduce::<102>(),
            TokenType::Goto => parser.reduce::<102>(),
            TokenType::If => parser.reduce::<102>(),
            TokenType::Local => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Repeat => parser.reduce::<102>(),
            TokenType::Return => parser.reduce::<102>(),
            TokenType::Until => parser.reduce::<102>(),
            TokenType::While => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::DoubleColon => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2450> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::RCurly => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Comma => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2451> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2699),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2452> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2682),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2453> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2698),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2454> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(494),
            TokenType::String(_) => parser.shift(711),
            TokenType::Integer(_) => parser.shift(712),
            TokenType::Float(_) => parser.shift(713),
            TokenType::False => parser.shift(714),
            TokenType::Function => parser.shift(918),
            TokenType::Nil => parser.shift(715),
            TokenType::Not => parser.shift(718),
            TokenType::True => parser.shift(735),
            TokenType::Sub => parser.shift(736),
            TokenType::Len => parser.shift(772),
            TokenType::BitXor => parser.shift(792),
            TokenType::LParen => parser.shift(523),
            TokenType::LCurly => parser.shift(919),
            TokenType::Dots => parser.shift(843),
            TokenType::Var => parser.goto(695),
            TokenType::Exp => parser.goto(2629),
            TokenType::Functioncall => parser.goto(698),
            TokenType::Functiondef => parser.goto(888),
            TokenType::Tableconstructor => parser.goto(889),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2455> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2693),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2456> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<23>(),
            TokenType::Break => parser.reduce::<23>(),
            TokenType::Do => parser.reduce::<23>(),
            TokenType::For => parser.reduce::<23>(),
            TokenType::Function => parser.reduce::<23>(),
            TokenType::Goto => parser.reduce::<23>(),
            TokenType::If => parser.reduce::<23>(),
            TokenType::Local => parser.reduce::<23>(),
            TokenType::Repeat => parser.reduce::<23>(),
            TokenType::Return => parser.reduce::<23>(),
            TokenType::Until => parser.reduce::<23>(),
            TokenType::While => parser.reduce::<23>(),
            TokenType::LParen => parser.reduce::<23>(),
            TokenType::DoubleColon => parser.reduce::<23>(),
            TokenType::SemiColon => parser.reduce::<23>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2457> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Comma => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            TokenType::Eof => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2458> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2697),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2459> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<102>(),
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Break => parser.reduce::<102>(),
            TokenType::Do => parser.reduce::<102>(),
            TokenType::End => parser.reduce::<102>(),
            TokenType::For => parser.reduce::<102>(),
            TokenType::Function => parser.reduce::<102>(),
            TokenType::Goto => parser.reduce::<102>(),
            TokenType::If => parser.reduce::<102>(),
            TokenType::Local => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Repeat => parser.reduce::<102>(),
            TokenType::Return => parser.reduce::<102>(),
            TokenType::While => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::DoubleColon => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2460> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Comma => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2461> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<52>(),
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Break => parser.reduce::<52>(),
            TokenType::Do => parser.reduce::<52>(),
            TokenType::Else => parser.reduce::<52>(),
            TokenType::Elseif => parser.reduce::<52>(),
            TokenType::End => parser.reduce::<52>(),
            TokenType::For => parser.reduce::<52>(),
            TokenType::Function => parser.reduce::<52>(),
            TokenType::Goto => parser.reduce::<52>(),
            TokenType::If => parser.reduce::<52>(),
            TokenType::Local => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Repeat => parser.reduce::<52>(),
            TokenType::Return => parser.reduce::<52>(),
            TokenType::While => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::DoubleColon => parser.reduce::<52>(),
            TokenType::SemiColon => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Comma => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2462> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<51>(),
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Break => parser.reduce::<51>(),
            TokenType::Do => parser.reduce::<51>(),
            TokenType::For => parser.reduce::<51>(),
            TokenType::Function => parser.reduce::<51>(),
            TokenType::Goto => parser.reduce::<51>(),
            TokenType::If => parser.reduce::<51>(),
            TokenType::Local => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Repeat => parser.reduce::<51>(),
            TokenType::Return => parser.reduce::<51>(),
            TokenType::While => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::DoubleColon => parser.reduce::<51>(),
            TokenType::SemiColon => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Comma => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            TokenType::Eof => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2463> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(2261),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Else => parser.reduce::<71>(),
            TokenType::Elseif => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.shift(2265),
            TokenType::LSquare => parser.shift(2669),
            TokenType::LCurly => parser.shift(2307),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.shift(2688),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.shift(2687),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(2689),
            TokenType::Tableconstructor => parser.goto(2306),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2464> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            TokenType::Comma => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            TokenType::Eof => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2465> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.shift(1660),
            TokenType::End => parser.reduce::<18>(),
            TokenType::StatElse => parser.goto(2631),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2466> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(2261),
            TokenType::LParen => parser.shift(2265),
            TokenType::LCurly => parser.shift(2307),
            TokenType::Args => parser.goto(2630),
            TokenType::Tableconstructor => parser.goto(2306),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2467> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::RParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Comma => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2468> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2701),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2469> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<117>(),
            TokenType::Else => parser.reduce::<117>(),
            TokenType::Elseif => parser.reduce::<117>(),
            TokenType::End => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2470> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::End => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2471> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<104>(),
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Break => parser.reduce::<104>(),
            TokenType::Do => parser.reduce::<104>(),
            TokenType::For => parser.reduce::<104>(),
            TokenType::Function => parser.reduce::<104>(),
            TokenType::Goto => parser.reduce::<104>(),
            TokenType::If => parser.reduce::<104>(),
            TokenType::Local => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Repeat => parser.reduce::<104>(),
            TokenType::Return => parser.reduce::<104>(),
            TokenType::Until => parser.reduce::<104>(),
            TokenType::While => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::DoubleColon => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2472> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::Until => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2473> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<104>(),
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Break => parser.reduce::<104>(),
            TokenType::Do => parser.reduce::<104>(),
            TokenType::End => parser.reduce::<104>(),
            TokenType::For => parser.reduce::<104>(),
            TokenType::Function => parser.reduce::<104>(),
            TokenType::Goto => parser.reduce::<104>(),
            TokenType::If => parser.reduce::<104>(),
            TokenType::Local => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Repeat => parser.reduce::<104>(),
            TokenType::Return => parser.reduce::<104>(),
            TokenType::While => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::DoubleColon => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2474> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::Else => parser.reduce::<117>(),
            TokenType::Elseif => parser.reduce::<117>(),
            TokenType::End => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2475> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.shift(2300),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::Else => parser.reduce::<71>(),
            TokenType::Elseif => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            // Shift(2304)-Reduce(71)
            TokenType::LParen => parser.shift(2304),
            TokenType::LSquare => parser.shift(2660),
            TokenType::LCurly => parser.shift(2318),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.shift(2691),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.shift(2690),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(2692),
            TokenType::Tableconstructor => parser.goto(2315),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2476> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<109>(),
            TokenType::And => parser.reduce::<109>(),
            TokenType::Break => parser.reduce::<109>(),
            TokenType::Do => parser.reduce::<109>(),
            TokenType::Else => parser.reduce::<109>(),
            TokenType::Elseif => parser.reduce::<109>(),
            TokenType::End => parser.reduce::<109>(),
            TokenType::For => parser.reduce::<109>(),
            TokenType::Function => parser.reduce::<109>(),
            TokenType::Goto => parser.reduce::<109>(),
            TokenType::If => parser.reduce::<109>(),
            TokenType::Local => parser.reduce::<109>(),
            TokenType::Or => parser.reduce::<109>(),
            TokenType::Repeat => parser.reduce::<109>(),
            TokenType::Return => parser.reduce::<109>(),
            TokenType::While => parser.reduce::<109>(),
            TokenType::Add => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Mul => parser.reduce::<109>(),
            TokenType::Div => parser.reduce::<109>(),
            TokenType::Idiv => parser.reduce::<109>(),
            TokenType::Mod => parser.reduce::<109>(),
            TokenType::Pow => parser.reduce::<109>(),
            TokenType::BitAnd => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::BitOr => parser.reduce::<109>(),
            TokenType::ShiftL => parser.reduce::<109>(),
            TokenType::ShiftR => parser.reduce::<109>(),
            TokenType::Eq => parser.reduce::<109>(),
            TokenType::Neq => parser.reduce::<109>(),
            TokenType::Leq => parser.reduce::<109>(),
            TokenType::Geq => parser.reduce::<109>(),
            TokenType::Less => parser.reduce::<109>(),
            TokenType::Greater => parser.reduce::<109>(),
            TokenType::LParen => parser.reduce::<109>(),
            TokenType::DoubleColon => parser.reduce::<109>(),
            TokenType::SemiColon => parser.reduce::<109>(),
            TokenType::Concat => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2477> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2686),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2478> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(463),
            TokenType::RParen => parser.reduce::<111>(),
            TokenType::Dots => parser.shift(469),
            TokenType::Namelist => parser.goto(470),
            TokenType::FuncbodyParlist => parser.goto(2632),
            TokenType::Parlist => parser.goto(467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2479> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Comma => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2480> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Comma => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2481> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::Until => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2482> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2483> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2695),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2484> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Else => parser.reduce::<52>(),
            TokenType::Elseif => parser.reduce::<52>(),
            TokenType::End => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::SemiColon => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Comma => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2485> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1204),
            TokenType::LParen => parser.shift(1206),
            TokenType::LCurly => parser.shift(1285),
            TokenType::Args => parser.goto(2638),
            TokenType::Tableconstructor => parser.goto(1284),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2486> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1214),
            TokenType::LParen => parser.shift(1218),
            TokenType::LCurly => parser.shift(1279),
            TokenType::Args => parser.goto(2634),
            TokenType::Tableconstructor => parser.goto(1277),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2487> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<103>(),
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Break => parser.reduce::<103>(),
            TokenType::Do => parser.reduce::<103>(),
            TokenType::For => parser.reduce::<103>(),
            TokenType::Function => parser.reduce::<103>(),
            TokenType::Goto => parser.reduce::<103>(),
            TokenType::If => parser.reduce::<103>(),
            TokenType::Local => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Repeat => parser.reduce::<103>(),
            TokenType::Return => parser.reduce::<103>(),
            TokenType::While => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::DoubleColon => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Comma => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            TokenType::Eof => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2488> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1269),
            TokenType::LParen => parser.shift(1278),
            TokenType::LCurly => parser.shift(1312),
            TokenType::Args => parser.goto(2635),
            TokenType::Tableconstructor => parser.goto(1310),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2489> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<23>(),
            TokenType::Break => parser.reduce::<23>(),
            TokenType::Do => parser.reduce::<23>(),
            TokenType::End => parser.reduce::<23>(),
            TokenType::For => parser.reduce::<23>(),
            TokenType::Function => parser.reduce::<23>(),
            TokenType::Goto => parser.reduce::<23>(),
            TokenType::If => parser.reduce::<23>(),
            TokenType::Local => parser.reduce::<23>(),
            TokenType::Repeat => parser.reduce::<23>(),
            TokenType::Return => parser.reduce::<23>(),
            TokenType::While => parser.reduce::<23>(),
            TokenType::LParen => parser.reduce::<23>(),
            TokenType::DoubleColon => parser.reduce::<23>(),
            TokenType::SemiColon => parser.reduce::<23>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2490> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<110>(),
            TokenType::Break => parser.reduce::<110>(),
            TokenType::Do => parser.reduce::<110>(),
            TokenType::End => parser.reduce::<110>(),
            TokenType::For => parser.reduce::<110>(),
            TokenType::Function => parser.reduce::<110>(),
            TokenType::Goto => parser.reduce::<110>(),
            TokenType::If => parser.reduce::<110>(),
            TokenType::Local => parser.reduce::<110>(),
            TokenType::Repeat => parser.reduce::<110>(),
            TokenType::Return => parser.reduce::<110>(),
            TokenType::While => parser.reduce::<110>(),
            TokenType::LParen => parser.reduce::<110>(),
            TokenType::DoubleColon => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2491> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::RSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2492> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(2300),
            TokenType::LParen => parser.shift(2304),
            TokenType::LCurly => parser.shift(2318),
            TokenType::Args => parser.goto(2639),
            TokenType::Tableconstructor => parser.goto(2315),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2493> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1159),
            TokenType::LParen => parser.shift(1188),
            TokenType::LCurly => parser.shift(1239),
            TokenType::Args => parser.goto(2637),
            TokenType::Tableconstructor => parser.goto(1231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2494> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2696),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2495> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1221),
            TokenType::LParen => parser.shift(1223),
            TokenType::LCurly => parser.shift(1288),
            TokenType::Args => parser.goto(2636),
            TokenType::Tableconstructor => parser.goto(1287),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2496> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Until => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Comma => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2497> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<13>(),
            TokenType::Break => parser.reduce::<13>(),
            TokenType::Do => parser.reduce::<13>(),
            TokenType::Else => parser.reduce::<13>(),
            TokenType::Elseif => parser.reduce::<13>(),
            TokenType::End => parser.reduce::<13>(),
            TokenType::For => parser.reduce::<13>(),
            TokenType::Function => parser.reduce::<13>(),
            TokenType::Goto => parser.reduce::<13>(),
            TokenType::If => parser.reduce::<13>(),
            TokenType::Local => parser.reduce::<13>(),
            TokenType::Repeat => parser.reduce::<13>(),
            TokenType::Return => parser.reduce::<13>(),
            TokenType::While => parser.reduce::<13>(),
            TokenType::LParen => parser.reduce::<13>(),
            TokenType::DoubleColon => parser.reduce::<13>(),
            TokenType::SemiColon => parser.reduce::<13>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2498> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Comma => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2499> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::Until => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2500> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<110>(),
            TokenType::And => parser.reduce::<110>(),
            TokenType::Break => parser.reduce::<110>(),
            TokenType::Do => parser.reduce::<110>(),
            TokenType::For => parser.reduce::<110>(),
            TokenType::Function => parser.reduce::<110>(),
            TokenType::Goto => parser.reduce::<110>(),
            TokenType::If => parser.reduce::<110>(),
            TokenType::Local => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Repeat => parser.reduce::<110>(),
            TokenType::Return => parser.reduce::<110>(),
            TokenType::While => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::LParen => parser.reduce::<110>(),
            TokenType::DoubleColon => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            TokenType::Comma => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            TokenType::Eof => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2501> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1262),
            TokenType::LParen => parser.shift(1264),
            TokenType::LCurly => parser.shift(1309),
            TokenType::Args => parser.goto(2640),
            TokenType::Tableconstructor => parser.goto(1308),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2502> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1241),
            TokenType::LParen => parser.shift(1248),
            TokenType::LCurly => parser.shift(1294),
            TokenType::Args => parser.goto(2641),
            TokenType::Tableconstructor => parser.goto(1293),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2503> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            TokenType::Eof => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2504> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Else => parser.reduce::<53>(),
            TokenType::Elseif => parser.reduce::<53>(),
            TokenType::End => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Comma => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2505> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(2261),
            TokenType::LParen => parser.shift(2265),
            TokenType::LCurly => parser.shift(2307),
            TokenType::Args => parser.goto(2643),
            TokenType::Tableconstructor => parser.goto(2306),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2506> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<110>(),
            TokenType::Break => parser.reduce::<110>(),
            TokenType::Do => parser.reduce::<110>(),
            TokenType::For => parser.reduce::<110>(),
            TokenType::Function => parser.reduce::<110>(),
            TokenType::Goto => parser.reduce::<110>(),
            TokenType::If => parser.reduce::<110>(),
            TokenType::Local => parser.reduce::<110>(),
            TokenType::Repeat => parser.reduce::<110>(),
            TokenType::Return => parser.reduce::<110>(),
            TokenType::Until => parser.reduce::<110>(),
            TokenType::While => parser.reduce::<110>(),
            TokenType::LParen => parser.reduce::<110>(),
            TokenType::DoubleColon => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2507> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::RParen => parser.reduce::<110>(),
            TokenType::Comma => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2508> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::RCurly => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            TokenType::Comma => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2509> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2644),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2510> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::SemiColon => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Comma => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            TokenType::Eof => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2511> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::Until => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Comma => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2512> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::RSquare => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2513> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<53>(),
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Break => parser.reduce::<53>(),
            TokenType::Do => parser.reduce::<53>(),
            TokenType::Else => parser.reduce::<53>(),
            TokenType::Elseif => parser.reduce::<53>(),
            TokenType::End => parser.reduce::<53>(),
            TokenType::For => parser.reduce::<53>(),
            TokenType::Function => parser.reduce::<53>(),
            TokenType::Goto => parser.reduce::<53>(),
            TokenType::If => parser.reduce::<53>(),
            TokenType::Local => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Repeat => parser.reduce::<53>(),
            TokenType::Return => parser.reduce::<53>(),
            TokenType::While => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::DoubleColon => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Comma => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2514> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1202),
            TokenType::LParen => parser.shift(1205),
            TokenType::LCurly => parser.shift(1292),
            TokenType::Args => parser.goto(2657),
            TokenType::Tableconstructor => parser.goto(1289),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2515> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(2300),
            TokenType::LParen => parser.shift(2304),
            TokenType::LCurly => parser.shift(2318),
            TokenType::Args => parser.goto(2646),
            TokenType::Tableconstructor => parser.goto(2315),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2516> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2666),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2517> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::RCurly => parser.reduce::<51>(),
            TokenType::SemiColon => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Comma => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2518> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::End => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2519> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2658),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2520> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<16>(),
            TokenType::Elseif => parser.shift(1147),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatElseif => parser.goto(2684),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2521> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2645),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2522> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2676),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2523> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2674),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2524> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2680),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2525> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<100>(),
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Break => parser.reduce::<100>(),
            TokenType::Do => parser.reduce::<100>(),
            TokenType::For => parser.reduce::<100>(),
            TokenType::Function => parser.reduce::<100>(),
            TokenType::Goto => parser.reduce::<100>(),
            TokenType::If => parser.reduce::<100>(),
            TokenType::Local => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Repeat => parser.reduce::<100>(),
            TokenType::Return => parser.reduce::<100>(),
            TokenType::Until => parser.reduce::<100>(),
            TokenType::While => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::DoubleColon => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2526> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2652),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2527> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2651),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2528> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(232),
            TokenType::Or => parser.shift(280),
            TokenType::Add => parser.shift(294),
            TokenType::Sub => parser.shift(349),
            TokenType::Mul => parser.shift(364),
            TokenType::Div => parser.shift(375),
            TokenType::Idiv => parser.shift(386),
            TokenType::Mod => parser.shift(391),
            TokenType::Pow => parser.shift(396),
            TokenType::BitAnd => parser.shift(405),
            TokenType::BitXor => parser.shift(416),
            TokenType::BitOr => parser.shift(419),
            TokenType::ShiftL => parser.shift(425),
            TokenType::ShiftR => parser.shift(431),
            TokenType::Eq => parser.shift(434),
            TokenType::Neq => parser.shift(438),
            TokenType::Leq => parser.shift(441),
            TokenType::Geq => parser.shift(445),
            TokenType::Less => parser.shift(449),
            TokenType::Greater => parser.shift(451),
            TokenType::RParen => parser.shift(2650),
            TokenType::Concat => parser.shift(453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2529> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2663),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2530> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2656),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2531> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<100>(),
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Break => parser.reduce::<100>(),
            TokenType::Do => parser.reduce::<100>(),
            TokenType::End => parser.reduce::<100>(),
            TokenType::For => parser.reduce::<100>(),
            TokenType::Function => parser.reduce::<100>(),
            TokenType::Goto => parser.reduce::<100>(),
            TokenType::If => parser.reduce::<100>(),
            TokenType::Local => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Repeat => parser.reduce::<100>(),
            TokenType::Return => parser.reduce::<100>(),
            TokenType::While => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::DoubleColon => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2532> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2667),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2533> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2649),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2534> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2668),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2535> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2661),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2536> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2677),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2537> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<99>(),
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::And => parser.reduce::<99>(),
            TokenType::Break => parser.reduce::<99>(),
            TokenType::Do => parser.reduce::<99>(),
            TokenType::Else => parser.reduce::<99>(),
            TokenType::Elseif => parser.reduce::<99>(),
            TokenType::End => parser.reduce::<99>(),
            TokenType::For => parser.reduce::<99>(),
            TokenType::Function => parser.reduce::<99>(),
            TokenType::Goto => parser.reduce::<99>(),
            TokenType::If => parser.reduce::<99>(),
            TokenType::Local => parser.reduce::<99>(),
            TokenType::Or => parser.reduce::<99>(),
            TokenType::Repeat => parser.reduce::<99>(),
            TokenType::Return => parser.reduce::<99>(),
            TokenType::While => parser.reduce::<99>(),
            TokenType::Add => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Mul => parser.reduce::<99>(),
            TokenType::Div => parser.reduce::<99>(),
            TokenType::Idiv => parser.reduce::<99>(),
            TokenType::Mod => parser.reduce::<99>(),
            TokenType::Pow => parser.reduce::<99>(),
            TokenType::BitAnd => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::BitOr => parser.reduce::<99>(),
            TokenType::ShiftL => parser.reduce::<99>(),
            TokenType::ShiftR => parser.reduce::<99>(),
            TokenType::Eq => parser.reduce::<99>(),
            TokenType::Neq => parser.reduce::<99>(),
            TokenType::Leq => parser.reduce::<99>(),
            TokenType::Geq => parser.reduce::<99>(),
            TokenType::Less => parser.reduce::<99>(),
            TokenType::Greater => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LSquare => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::DoubleColon => parser.reduce::<99>(),
            TokenType::SemiColon => parser.reduce::<99>(),
            TokenType::Colon => parser.reduce::<99>(),
            TokenType::Dot => parser.reduce::<99>(),
            TokenType::Concat => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2538> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<108>(),
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::And => parser.reduce::<108>(),
            TokenType::Break => parser.reduce::<108>(),
            TokenType::Do => parser.reduce::<108>(),
            TokenType::Else => parser.reduce::<108>(),
            TokenType::Elseif => parser.reduce::<108>(),
            TokenType::End => parser.reduce::<108>(),
            TokenType::For => parser.reduce::<108>(),
            TokenType::Function => parser.reduce::<108>(),
            TokenType::Goto => parser.reduce::<108>(),
            TokenType::If => parser.reduce::<108>(),
            TokenType::Local => parser.reduce::<108>(),
            TokenType::Or => parser.reduce::<108>(),
            TokenType::Repeat => parser.reduce::<108>(),
            TokenType::Return => parser.reduce::<108>(),
            TokenType::While => parser.reduce::<108>(),
            TokenType::Add => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Mul => parser.reduce::<108>(),
            TokenType::Div => parser.reduce::<108>(),
            TokenType::Idiv => parser.reduce::<108>(),
            TokenType::Mod => parser.reduce::<108>(),
            TokenType::Pow => parser.reduce::<108>(),
            TokenType::BitAnd => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::BitOr => parser.reduce::<108>(),
            TokenType::ShiftL => parser.reduce::<108>(),
            TokenType::ShiftR => parser.reduce::<108>(),
            TokenType::Eq => parser.reduce::<108>(),
            TokenType::Neq => parser.reduce::<108>(),
            TokenType::Leq => parser.reduce::<108>(),
            TokenType::Geq => parser.reduce::<108>(),
            TokenType::Less => parser.reduce::<108>(),
            TokenType::Greater => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LSquare => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::DoubleColon => parser.reduce::<108>(),
            TokenType::SemiColon => parser.reduce::<108>(),
            TokenType::Colon => parser.reduce::<108>(),
            TokenType::Dot => parser.reduce::<108>(),
            TokenType::Concat => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2539> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2678),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2540> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<98>(),
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::And => parser.reduce::<98>(),
            TokenType::Break => parser.reduce::<98>(),
            TokenType::Do => parser.reduce::<98>(),
            TokenType::Else => parser.reduce::<98>(),
            TokenType::Elseif => parser.reduce::<98>(),
            TokenType::End => parser.reduce::<98>(),
            TokenType::For => parser.reduce::<98>(),
            TokenType::Function => parser.reduce::<98>(),
            TokenType::Goto => parser.reduce::<98>(),
            TokenType::If => parser.reduce::<98>(),
            TokenType::Local => parser.reduce::<98>(),
            TokenType::Or => parser.reduce::<98>(),
            TokenType::Repeat => parser.reduce::<98>(),
            TokenType::Return => parser.reduce::<98>(),
            TokenType::While => parser.reduce::<98>(),
            TokenType::Add => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Mul => parser.reduce::<98>(),
            TokenType::Div => parser.reduce::<98>(),
            TokenType::Idiv => parser.reduce::<98>(),
            TokenType::Mod => parser.reduce::<98>(),
            TokenType::Pow => parser.reduce::<98>(),
            TokenType::BitAnd => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::BitOr => parser.reduce::<98>(),
            TokenType::ShiftL => parser.reduce::<98>(),
            TokenType::ShiftR => parser.reduce::<98>(),
            TokenType::Eq => parser.reduce::<98>(),
            TokenType::Neq => parser.reduce::<98>(),
            TokenType::Leq => parser.reduce::<98>(),
            TokenType::Geq => parser.reduce::<98>(),
            TokenType::Less => parser.reduce::<98>(),
            TokenType::Greater => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::DoubleColon => parser.reduce::<98>(),
            TokenType::SemiColon => parser.reduce::<98>(),
            TokenType::Colon => parser.reduce::<98>(),
            TokenType::Dot => parser.reduce::<98>(),
            TokenType::Concat => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2541> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(182),
            TokenType::String(_) => parser.shift(303),
            TokenType::Integer(_) => parser.shift(304),
            TokenType::Float(_) => parser.shift(305),
            TokenType::False => parser.shift(307),
            TokenType::Function => parser.shift(407),
            TokenType::Nil => parser.shift(308),
            TokenType::Not => parser.shift(312),
            TokenType::True => parser.shift(338),
            TokenType::Sub => parser.shift(344),
            TokenType::Len => parser.shift(354),
            TokenType::BitXor => parser.shift(363),
            TokenType::LParen => parser.shift(206),
            TokenType::RParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.shift(408),
            TokenType::Dots => parser.shift(378),
            TokenType::Var => parser.goto(291),
            TokenType::Explist => parser.goto(406),
            TokenType::Exp => parser.goto(302),
            TokenType::Functioncall => parser.goto(293),
            TokenType::ArgsExplist => parser.goto(2702),
            TokenType::Functiondef => parser.goto(387),
            TokenType::Tableconstructor => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2542> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2706),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2543> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2654),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2544> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2653),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2545> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2659),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2546> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2672),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2547> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::Else => parser.reduce::<59>(),
            TokenType::Elseif => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Add => parser.shift(2317),
            TokenType::Sub => parser.shift(2325),
            TokenType::Mul => parser.shift(2334),
            TokenType::Div => parser.shift(2335),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Mod => parser.shift(2344),
            TokenType::Pow => parser.shift(2349),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitOr => parser.shift(2362),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::Eq => parser.shift(2408),
            TokenType::Neq => parser.shift(2412),
            TokenType::Leq => parser.shift(2413),
            TokenType::Geq => parser.shift(2416),
            TokenType::Less => parser.shift(2418),
            TokenType::Greater => parser.shift(2420),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(2204),
            TokenType::Concat => parser.shift(2421),
            TokenType::ExplistCont => parser.goto(2683),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2548> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2655),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2549> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2673),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2550> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2665),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2551> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<107>(),
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::And => parser.reduce::<107>(),
            TokenType::Break => parser.reduce::<107>(),
            TokenType::Do => parser.reduce::<107>(),
            TokenType::Else => parser.reduce::<107>(),
            TokenType::Elseif => parser.reduce::<107>(),
            TokenType::End => parser.reduce::<107>(),
            TokenType::For => parser.reduce::<107>(),
            TokenType::Function => parser.reduce::<107>(),
            TokenType::Goto => parser.reduce::<107>(),
            TokenType::If => parser.reduce::<107>(),
            TokenType::Local => parser.reduce::<107>(),
            TokenType::Or => parser.reduce::<107>(),
            TokenType::Repeat => parser.reduce::<107>(),
            TokenType::Return => parser.reduce::<107>(),
            TokenType::While => parser.reduce::<107>(),
            TokenType::Add => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Mul => parser.reduce::<107>(),
            TokenType::Div => parser.reduce::<107>(),
            TokenType::Idiv => parser.reduce::<107>(),
            TokenType::Mod => parser.reduce::<107>(),
            TokenType::Pow => parser.reduce::<107>(),
            TokenType::BitAnd => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::BitOr => parser.reduce::<107>(),
            TokenType::ShiftL => parser.reduce::<107>(),
            TokenType::ShiftR => parser.reduce::<107>(),
            TokenType::Eq => parser.reduce::<107>(),
            TokenType::Neq => parser.reduce::<107>(),
            TokenType::Leq => parser.reduce::<107>(),
            TokenType::Geq => parser.reduce::<107>(),
            TokenType::Less => parser.reduce::<107>(),
            TokenType::Greater => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LSquare => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::DoubleColon => parser.reduce::<107>(),
            TokenType::SemiColon => parser.reduce::<107>(),
            TokenType::Colon => parser.reduce::<107>(),
            TokenType::Dot => parser.reduce::<107>(),
            TokenType::Concat => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2552> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(192),
            TokenType::String(_) => parser.shift(322),
            TokenType::Integer(_) => parser.shift(323),
            TokenType::Float(_) => parser.shift(324),
            TokenType::False => parser.shift(325),
            TokenType::Function => parser.shift(399),
            TokenType::Nil => parser.shift(326),
            TokenType::Not => parser.shift(327),
            TokenType::True => parser.shift(348),
            TokenType::Sub => parser.shift(350),
            TokenType::Len => parser.shift(358),
            TokenType::BitXor => parser.shift(366),
            TokenType::LParen => parser.shift(207),
            TokenType::LSquare => parser.shift(412),
            TokenType::LCurly => parser.shift(400),
            TokenType::RCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.shift(377),
            TokenType::Var => parser.goto(309),
            TokenType::Exp => parser.goto(379),
            TokenType::Functioncall => parser.goto(319),
            TokenType::Functiondef => parser.goto(381),
            TokenType::Tableconstructor => parser.goto(382),
            TokenType::TableconstructorFieldlist => parser.goto(2700),
            TokenType::Fieldlist => parser.goto(410),
            TokenType::Field => parser.goto(411),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2553> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2648),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2554> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2664),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2555> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2679),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2556> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2647),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2557> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.shift(2290),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::Else => parser.reduce::<59>(),
            TokenType::Elseif => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Sub => parser.shift(2348),
            TokenType::Mul => parser.shift(2359),
            TokenType::Div => parser.shift(2402),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Mod => parser.shift(2414),
            TokenType::Pow => parser.shift(2419),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitOr => parser.shift(2424),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::Eq => parser.shift(2427),
            TokenType::Neq => parser.shift(2428),
            TokenType::Leq => parser.shift(2429),
            TokenType::Geq => parser.shift(2430),
            TokenType::Less => parser.shift(2431),
            TokenType::Greater => parser.shift(2432),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.shift(2245),
            TokenType::Concat => parser.shift(2433),
            TokenType::ExplistCont => parser.goto(2694),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2558> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2722),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2559> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<93>(),
            TokenType::And => parser.reduce::<93>(),
            TokenType::Break => parser.reduce::<93>(),
            TokenType::Do => parser.reduce::<93>(),
            TokenType::Else => parser.reduce::<93>(),
            TokenType::Elseif => parser.reduce::<93>(),
            TokenType::End => parser.reduce::<93>(),
            TokenType::For => parser.reduce::<93>(),
            TokenType::Function => parser.reduce::<93>(),
            TokenType::Goto => parser.reduce::<93>(),
            TokenType::If => parser.reduce::<93>(),
            TokenType::Local => parser.reduce::<93>(),
            TokenType::Or => parser.reduce::<93>(),
            TokenType::Repeat => parser.reduce::<93>(),
            TokenType::Return => parser.reduce::<93>(),
            TokenType::While => parser.reduce::<93>(),
            TokenType::Add => parser.reduce::<93>(),
            TokenType::Sub => parser.reduce::<93>(),
            TokenType::Mul => parser.reduce::<93>(),
            TokenType::Div => parser.reduce::<93>(),
            TokenType::Idiv => parser.reduce::<93>(),
            TokenType::Mod => parser.reduce::<93>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::BitAnd => parser.reduce::<93>(),
            TokenType::BitXor => parser.reduce::<93>(),
            TokenType::BitOr => parser.reduce::<93>(),
            TokenType::ShiftL => parser.reduce::<93>(),
            TokenType::ShiftR => parser.reduce::<93>(),
            TokenType::Eq => parser.reduce::<93>(),
            TokenType::Neq => parser.reduce::<93>(),
            TokenType::Leq => parser.reduce::<93>(),
            TokenType::Geq => parser.reduce::<93>(),
            TokenType::Less => parser.reduce::<93>(),
            TokenType::Greater => parser.reduce::<93>(),
            TokenType::LParen => parser.reduce::<93>(),
            TokenType::DoubleColon => parser.reduce::<93>(),
            TokenType::SemiColon => parser.reduce::<93>(),
            TokenType::Concat => parser.reduce::<93>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2560> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2720),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2561> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Else => parser.reduce::<77>(),
            TokenType::Elseif => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2562> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Else => parser.reduce::<86>(),
            TokenType::Elseif => parser.reduce::<86>(),
            TokenType::End => parser.reduce::<86>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::SemiColon => parser.reduce::<86>(),
            TokenType::Comma => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2563> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Else => parser.reduce::<92>(),
            TokenType::Elseif => parser.reduce::<92>(),
            TokenType::End => parser.reduce::<92>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::SemiColon => parser.reduce::<92>(),
            TokenType::Comma => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2564> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Else => parser.reduce::<75>(),
            TokenType::Elseif => parser.reduce::<75>(),
            TokenType::End => parser.reduce::<75>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::SemiColon => parser.reduce::<75>(),
            TokenType::Comma => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2565> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Else => parser.reduce::<82>(),
            TokenType::Elseif => parser.reduce::<82>(),
            TokenType::End => parser.reduce::<82>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::SemiColon => parser.reduce::<82>(),
            TokenType::Comma => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2566> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Else => parser.reduce::<87>(),
            TokenType::Elseif => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Div => parser.shift(2335),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Mod => parser.shift(2344),
            TokenType::Pow => parser.shift(2349),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2567> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Else => parser.reduce::<84>(),
            TokenType::Elseif => parser.reduce::<84>(),
            TokenType::End => parser.reduce::<84>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::SemiColon => parser.reduce::<84>(),
            TokenType::Comma => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2568> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Else => parser.reduce::<97>(),
            TokenType::Elseif => parser.reduce::<97>(),
            TokenType::End => parser.reduce::<97>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::SemiColon => parser.reduce::<97>(),
            TokenType::Comma => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2569> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Else => parser.reduce::<91>(),
            TokenType::Elseif => parser.reduce::<91>(),
            TokenType::End => parser.reduce::<91>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::SemiColon => parser.reduce::<91>(),
            TokenType::Comma => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2570> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::And => parser.reduce::<88>(),
            TokenType::Else => parser.reduce::<88>(),
            TokenType::Elseif => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Div => parser.shift(2335),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Mod => parser.shift(2344),
            TokenType::Pow => parser.shift(2349),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2571> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Else => parser.reduce::<81>(),
            TokenType::Elseif => parser.reduce::<81>(),
            TokenType::End => parser.reduce::<81>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::SemiColon => parser.reduce::<81>(),
            TokenType::Comma => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2572> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator - has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<95>(),
            TokenType::And => parser.reduce::<95>(),
            TokenType::Break => parser.reduce::<95>(),
            TokenType::Do => parser.reduce::<95>(),
            TokenType::Else => parser.reduce::<95>(),
            TokenType::Elseif => parser.reduce::<95>(),
            TokenType::End => parser.reduce::<95>(),
            TokenType::For => parser.reduce::<95>(),
            TokenType::Function => parser.reduce::<95>(),
            TokenType::Goto => parser.reduce::<95>(),
            TokenType::If => parser.reduce::<95>(),
            TokenType::Local => parser.reduce::<95>(),
            TokenType::Or => parser.reduce::<95>(),
            TokenType::Repeat => parser.reduce::<95>(),
            TokenType::Return => parser.reduce::<95>(),
            TokenType::While => parser.reduce::<95>(),
            TokenType::Add => parser.reduce::<95>(),
            TokenType::Sub => parser.reduce::<95>(),
            TokenType::Mul => parser.reduce::<95>(),
            TokenType::Div => parser.reduce::<95>(),
            TokenType::Idiv => parser.reduce::<95>(),
            TokenType::Mod => parser.reduce::<95>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::BitAnd => parser.reduce::<95>(),
            TokenType::BitXor => parser.reduce::<95>(),
            TokenType::BitOr => parser.reduce::<95>(),
            TokenType::ShiftL => parser.reduce::<95>(),
            TokenType::ShiftR => parser.reduce::<95>(),
            TokenType::Eq => parser.reduce::<95>(),
            TokenType::Neq => parser.reduce::<95>(),
            TokenType::Leq => parser.reduce::<95>(),
            TokenType::Geq => parser.reduce::<95>(),
            TokenType::Less => parser.reduce::<95>(),
            TokenType::Greater => parser.reduce::<95>(),
            TokenType::LParen => parser.reduce::<95>(),
            TokenType::DoubleColon => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Concat => parser.reduce::<95>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2573> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Else => parser.reduce::<76>(),
            TokenType::Elseif => parser.reduce::<76>(),
            TokenType::End => parser.reduce::<76>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2574> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Else => parser.reduce::<78>(),
            TokenType::Elseif => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2575> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Else => parser.reduce::<80>(),
            TokenType::Elseif => parser.reduce::<80>(),
            TokenType::End => parser.reduce::<80>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2576> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2670),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2577> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2675),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2578> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Else => parser.reduce::<85>(),
            TokenType::Elseif => parser.reduce::<85>(),
            TokenType::End => parser.reduce::<85>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::SemiColon => parser.reduce::<85>(),
            TokenType::Comma => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2579> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Else => parser.reduce::<89>(),
            TokenType::Elseif => parser.reduce::<89>(),
            TokenType::End => parser.reduce::<89>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::SemiColon => parser.reduce::<89>(),
            TokenType::Comma => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2580> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Else => parser.reduce::<83>(),
            TokenType::Elseif => parser.reduce::<83>(),
            TokenType::End => parser.reduce::<83>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::SemiColon => parser.reduce::<83>(),
            TokenType::Comma => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2581> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Else => parser.reduce::<74>(),
            TokenType::Elseif => parser.reduce::<74>(),
            TokenType::End => parser.reduce::<74>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2582> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Else => parser.reduce::<79>(),
            TokenType::Elseif => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2583> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Else => parser.reduce::<90>(),
            TokenType::Elseif => parser.reduce::<90>(),
            TokenType::End => parser.reduce::<90>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::SemiColon => parser.reduce::<90>(),
            TokenType::Comma => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2584> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(2246),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Else => parser.reduce::<73>(),
            TokenType::Elseif => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::Or => parser.shift(2305),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.shift(2317),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(2325),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(2334),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(2335),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(2342),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(2344),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(2349),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(2352),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(2358),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(2362),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(2386),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(2406),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(2408),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(2412),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(2413),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(2416),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(2418),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(2420),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(2421),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2585> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2709),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2586> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2671),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2587> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2681),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2588> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2662),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2589> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `len` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<94>(),
            TokenType::And => parser.reduce::<94>(),
            TokenType::Break => parser.reduce::<94>(),
            TokenType::Do => parser.reduce::<94>(),
            TokenType::Else => parser.reduce::<94>(),
            TokenType::Elseif => parser.reduce::<94>(),
            TokenType::End => parser.reduce::<94>(),
            TokenType::For => parser.reduce::<94>(),
            TokenType::Function => parser.reduce::<94>(),
            TokenType::Goto => parser.reduce::<94>(),
            TokenType::If => parser.reduce::<94>(),
            TokenType::Local => parser.reduce::<94>(),
            TokenType::Or => parser.reduce::<94>(),
            TokenType::Repeat => parser.reduce::<94>(),
            TokenType::Return => parser.reduce::<94>(),
            TokenType::While => parser.reduce::<94>(),
            TokenType::Add => parser.reduce::<94>(),
            TokenType::Sub => parser.reduce::<94>(),
            TokenType::Mul => parser.reduce::<94>(),
            TokenType::Div => parser.reduce::<94>(),
            TokenType::Idiv => parser.reduce::<94>(),
            TokenType::Mod => parser.reduce::<94>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::BitAnd => parser.reduce::<94>(),
            TokenType::BitXor => parser.reduce::<94>(),
            TokenType::BitOr => parser.reduce::<94>(),
            TokenType::ShiftL => parser.reduce::<94>(),
            TokenType::ShiftR => parser.reduce::<94>(),
            TokenType::Eq => parser.reduce::<94>(),
            TokenType::Neq => parser.reduce::<94>(),
            TokenType::Leq => parser.reduce::<94>(),
            TokenType::Geq => parser.reduce::<94>(),
            TokenType::Less => parser.reduce::<94>(),
            TokenType::Greater => parser.reduce::<94>(),
            TokenType::LParen => parser.reduce::<94>(),
            TokenType::DoubleColon => parser.reduce::<94>(),
            TokenType::SemiColon => parser.reduce::<94>(),
            TokenType::Concat => parser.reduce::<94>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2590> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2705),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2591> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<97>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Break => parser.reduce::<97>(),
            TokenType::Do => parser.reduce::<97>(),
            TokenType::Else => parser.reduce::<97>(),
            TokenType::Elseif => parser.reduce::<97>(),
            TokenType::End => parser.reduce::<97>(),
            TokenType::For => parser.reduce::<97>(),
            TokenType::Function => parser.reduce::<97>(),
            TokenType::Goto => parser.reduce::<97>(),
            TokenType::If => parser.reduce::<97>(),
            TokenType::Local => parser.reduce::<97>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Repeat => parser.reduce::<97>(),
            TokenType::Return => parser.reduce::<97>(),
            TokenType::While => parser.reduce::<97>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::LParen => parser.reduce::<97>(),
            TokenType::DoubleColon => parser.reduce::<97>(),
            TokenType::SemiColon => parser.reduce::<97>(),
            TokenType::Comma => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2592> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Unary operator `bit not` has precedence higher than all binary operators
        // except Pow
        match lookahead {
            TokenType::Name(_) => parser.reduce::<96>(),
            TokenType::And => parser.reduce::<96>(),
            TokenType::Break => parser.reduce::<96>(),
            TokenType::Do => parser.reduce::<96>(),
            TokenType::Else => parser.reduce::<96>(),
            TokenType::Elseif => parser.reduce::<96>(),
            TokenType::End => parser.reduce::<96>(),
            TokenType::For => parser.reduce::<96>(),
            TokenType::Function => parser.reduce::<96>(),
            TokenType::Goto => parser.reduce::<96>(),
            TokenType::If => parser.reduce::<96>(),
            TokenType::Local => parser.reduce::<96>(),
            TokenType::Or => parser.reduce::<96>(),
            TokenType::Repeat => parser.reduce::<96>(),
            TokenType::Return => parser.reduce::<96>(),
            TokenType::While => parser.reduce::<96>(),
            TokenType::Add => parser.reduce::<96>(),
            TokenType::Sub => parser.reduce::<96>(),
            TokenType::Mul => parser.reduce::<96>(),
            TokenType::Div => parser.reduce::<96>(),
            TokenType::Idiv => parser.reduce::<96>(),
            TokenType::Mod => parser.reduce::<96>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::BitAnd => parser.reduce::<96>(),
            TokenType::BitXor => parser.reduce::<96>(),
            TokenType::BitOr => parser.reduce::<96>(),
            TokenType::ShiftL => parser.reduce::<96>(),
            TokenType::ShiftR => parser.reduce::<96>(),
            TokenType::Eq => parser.reduce::<96>(),
            TokenType::Neq => parser.reduce::<96>(),
            TokenType::Leq => parser.reduce::<96>(),
            TokenType::Geq => parser.reduce::<96>(),
            TokenType::Less => parser.reduce::<96>(),
            TokenType::Greater => parser.reduce::<96>(),
            TokenType::LParen => parser.reduce::<96>(),
            TokenType::DoubleColon => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Concat => parser.reduce::<96>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2593> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2713),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2594> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::Else => parser.reduce::<79>(),
            TokenType::Elseif => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2595> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::Else => parser.reduce::<88>(),
            TokenType::Elseif => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Div => parser.shift(2402),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Mod => parser.shift(2414),
            TokenType::Pow => parser.shift(2419),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Comma => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2596> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::Else => parser.reduce::<74>(),
            TokenType::Elseif => parser.reduce::<74>(),
            TokenType::End => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Comma => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2597> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::Else => parser.reduce::<73>(),
            TokenType::Elseif => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2598> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<86>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Break => parser.reduce::<86>(),
            TokenType::Do => parser.reduce::<86>(),
            TokenType::Else => parser.reduce::<86>(),
            TokenType::Elseif => parser.reduce::<86>(),
            TokenType::End => parser.reduce::<86>(),
            TokenType::For => parser.reduce::<86>(),
            TokenType::Function => parser.reduce::<86>(),
            TokenType::Goto => parser.reduce::<86>(),
            TokenType::If => parser.reduce::<86>(),
            TokenType::Local => parser.reduce::<86>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Repeat => parser.reduce::<86>(),
            TokenType::Return => parser.reduce::<86>(),
            TokenType::While => parser.reduce::<86>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::LParen => parser.reduce::<86>(),
            TokenType::DoubleColon => parser.reduce::<86>(),
            TokenType::SemiColon => parser.reduce::<86>(),
            TokenType::Comma => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2599> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::Else => parser.reduce::<76>(),
            TokenType::Elseif => parser.reduce::<76>(),
            TokenType::End => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2600> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<91>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Break => parser.reduce::<91>(),
            TokenType::Do => parser.reduce::<91>(),
            TokenType::Else => parser.reduce::<91>(),
            TokenType::Elseif => parser.reduce::<91>(),
            TokenType::End => parser.reduce::<91>(),
            TokenType::For => parser.reduce::<91>(),
            TokenType::Function => parser.reduce::<91>(),
            TokenType::Goto => parser.reduce::<91>(),
            TokenType::If => parser.reduce::<91>(),
            TokenType::Local => parser.reduce::<91>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Repeat => parser.reduce::<91>(),
            TokenType::Return => parser.reduce::<91>(),
            TokenType::While => parser.reduce::<91>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::LParen => parser.reduce::<91>(),
            TokenType::DoubleColon => parser.reduce::<91>(),
            TokenType::SemiColon => parser.reduce::<91>(),
            TokenType::Comma => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2601> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<90>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Break => parser.reduce::<90>(),
            TokenType::Do => parser.reduce::<90>(),
            TokenType::Else => parser.reduce::<90>(),
            TokenType::Elseif => parser.reduce::<90>(),
            TokenType::End => parser.reduce::<90>(),
            TokenType::For => parser.reduce::<90>(),
            TokenType::Function => parser.reduce::<90>(),
            TokenType::Goto => parser.reduce::<90>(),
            TokenType::If => parser.reduce::<90>(),
            TokenType::Local => parser.reduce::<90>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Repeat => parser.reduce::<90>(),
            TokenType::Return => parser.reduce::<90>(),
            TokenType::While => parser.reduce::<90>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::LParen => parser.reduce::<90>(),
            TokenType::DoubleColon => parser.reduce::<90>(),
            TokenType::SemiColon => parser.reduce::<90>(),
            TokenType::Comma => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2602> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<85>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Break => parser.reduce::<85>(),
            TokenType::Do => parser.reduce::<85>(),
            TokenType::Else => parser.reduce::<85>(),
            TokenType::Elseif => parser.reduce::<85>(),
            TokenType::End => parser.reduce::<85>(),
            TokenType::For => parser.reduce::<85>(),
            TokenType::Function => parser.reduce::<85>(),
            TokenType::Goto => parser.reduce::<85>(),
            TokenType::If => parser.reduce::<85>(),
            TokenType::Local => parser.reduce::<85>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Repeat => parser.reduce::<85>(),
            TokenType::Return => parser.reduce::<85>(),
            TokenType::While => parser.reduce::<85>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::LParen => parser.reduce::<85>(),
            TokenType::DoubleColon => parser.reduce::<85>(),
            TokenType::SemiColon => parser.reduce::<85>(),
            TokenType::Comma => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2603> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2703),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2604> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::Else => parser.reduce::<78>(),
            TokenType::Elseif => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2605> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<81>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Break => parser.reduce::<81>(),
            TokenType::Do => parser.reduce::<81>(),
            TokenType::Else => parser.reduce::<81>(),
            TokenType::Elseif => parser.reduce::<81>(),
            TokenType::End => parser.reduce::<81>(),
            TokenType::For => parser.reduce::<81>(),
            TokenType::Function => parser.reduce::<81>(),
            TokenType::Goto => parser.reduce::<81>(),
            TokenType::If => parser.reduce::<81>(),
            TokenType::Local => parser.reduce::<81>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Repeat => parser.reduce::<81>(),
            TokenType::Return => parser.reduce::<81>(),
            TokenType::While => parser.reduce::<81>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::LParen => parser.reduce::<81>(),
            TokenType::DoubleColon => parser.reduce::<81>(),
            TokenType::SemiColon => parser.reduce::<81>(),
            TokenType::Comma => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2606> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<92>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Break => parser.reduce::<92>(),
            TokenType::Do => parser.reduce::<92>(),
            TokenType::Else => parser.reduce::<92>(),
            TokenType::Elseif => parser.reduce::<92>(),
            TokenType::End => parser.reduce::<92>(),
            TokenType::For => parser.reduce::<92>(),
            TokenType::Function => parser.reduce::<92>(),
            TokenType::Goto => parser.reduce::<92>(),
            TokenType::If => parser.reduce::<92>(),
            TokenType::Local => parser.reduce::<92>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Repeat => parser.reduce::<92>(),
            TokenType::Return => parser.reduce::<92>(),
            TokenType::While => parser.reduce::<92>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::LParen => parser.reduce::<92>(),
            TokenType::DoubleColon => parser.reduce::<92>(),
            TokenType::SemiColon => parser.reduce::<92>(),
            TokenType::Comma => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2607> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::Else => parser.reduce::<87>(),
            TokenType::Elseif => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Div => parser.shift(2402),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Mod => parser.shift(2414),
            TokenType::Pow => parser.shift(2419),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2608> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::Else => parser.reduce::<80>(),
            TokenType::Elseif => parser.reduce::<80>(),
            TokenType::End => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Comma => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2609> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<83>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Break => parser.reduce::<83>(),
            TokenType::Do => parser.reduce::<83>(),
            TokenType::Else => parser.reduce::<83>(),
            TokenType::Elseif => parser.reduce::<83>(),
            TokenType::End => parser.reduce::<83>(),
            TokenType::For => parser.reduce::<83>(),
            TokenType::Function => parser.reduce::<83>(),
            TokenType::Goto => parser.reduce::<83>(),
            TokenType::If => parser.reduce::<83>(),
            TokenType::Local => parser.reduce::<83>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Repeat => parser.reduce::<83>(),
            TokenType::Return => parser.reduce::<83>(),
            TokenType::While => parser.reduce::<83>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::LParen => parser.reduce::<83>(),
            TokenType::DoubleColon => parser.reduce::<83>(),
            TokenType::SemiColon => parser.reduce::<83>(),
            TokenType::Comma => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2610> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::Else => parser.reduce::<77>(),
            TokenType::Elseif => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2611> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<89>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Break => parser.reduce::<89>(),
            TokenType::Do => parser.reduce::<89>(),
            TokenType::Else => parser.reduce::<89>(),
            TokenType::Elseif => parser.reduce::<89>(),
            TokenType::End => parser.reduce::<89>(),
            TokenType::For => parser.reduce::<89>(),
            TokenType::Function => parser.reduce::<89>(),
            TokenType::Goto => parser.reduce::<89>(),
            TokenType::If => parser.reduce::<89>(),
            TokenType::Local => parser.reduce::<89>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Repeat => parser.reduce::<89>(),
            TokenType::Return => parser.reduce::<89>(),
            TokenType::While => parser.reduce::<89>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::LParen => parser.reduce::<89>(),
            TokenType::DoubleColon => parser.reduce::<89>(),
            TokenType::SemiColon => parser.reduce::<89>(),
            TokenType::Comma => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2612> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<75>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Break => parser.reduce::<75>(),
            TokenType::Do => parser.reduce::<75>(),
            TokenType::Else => parser.reduce::<75>(),
            TokenType::Elseif => parser.reduce::<75>(),
            TokenType::End => parser.reduce::<75>(),
            TokenType::For => parser.reduce::<75>(),
            TokenType::Function => parser.reduce::<75>(),
            TokenType::Goto => parser.reduce::<75>(),
            TokenType::If => parser.reduce::<75>(),
            TokenType::Local => parser.reduce::<75>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Repeat => parser.reduce::<75>(),
            TokenType::Return => parser.reduce::<75>(),
            TokenType::While => parser.reduce::<75>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::LParen => parser.reduce::<75>(),
            TokenType::DoubleColon => parser.reduce::<75>(),
            TokenType::SemiColon => parser.reduce::<75>(),
            TokenType::Comma => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2613> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<84>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Break => parser.reduce::<84>(),
            TokenType::Do => parser.reduce::<84>(),
            TokenType::Else => parser.reduce::<84>(),
            TokenType::Elseif => parser.reduce::<84>(),
            TokenType::End => parser.reduce::<84>(),
            TokenType::For => parser.reduce::<84>(),
            TokenType::Function => parser.reduce::<84>(),
            TokenType::Goto => parser.reduce::<84>(),
            TokenType::If => parser.reduce::<84>(),
            TokenType::Local => parser.reduce::<84>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Repeat => parser.reduce::<84>(),
            TokenType::Return => parser.reduce::<84>(),
            TokenType::While => parser.reduce::<84>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::LParen => parser.reduce::<84>(),
            TokenType::DoubleColon => parser.reduce::<84>(),
            TokenType::SemiColon => parser.reduce::<84>(),
            TokenType::Comma => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2614> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<82>(),
            TokenType::And => parser.shift(2290),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Break => parser.reduce::<82>(),
            TokenType::Do => parser.reduce::<82>(),
            TokenType::Else => parser.reduce::<82>(),
            TokenType::Elseif => parser.reduce::<82>(),
            TokenType::End => parser.reduce::<82>(),
            TokenType::For => parser.reduce::<82>(),
            TokenType::Function => parser.reduce::<82>(),
            TokenType::Goto => parser.reduce::<82>(),
            TokenType::If => parser.reduce::<82>(),
            TokenType::Local => parser.reduce::<82>(),
            TokenType::Or => parser.shift(2331),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Repeat => parser.reduce::<82>(),
            TokenType::Return => parser.reduce::<82>(),
            TokenType::While => parser.reduce::<82>(),
            TokenType::Add => parser.shift(2339),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(2348),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(2359),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(2402),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(2411),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(2414),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(2419),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(2422),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(2423),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(2424),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(2425),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(2426),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(2427),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(2428),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(2429),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(2430),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(2431),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(2432),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::LParen => parser.reduce::<82>(),
            TokenType::DoubleColon => parser.reduce::<82>(),
            TokenType::SemiColon => parser.reduce::<82>(),
            TokenType::Comma => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(2433),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2615> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2721),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2616> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2719),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2617> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2715),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2618> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2711),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2619> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2714),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2620> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2708),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2621> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2716),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2622> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2712),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2623> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2704),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2624> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2717),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2625> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2710),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2626> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2707),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2627> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2191),
            TokenType::String(_) => parser.shift(2326),
            TokenType::Integer(_) => parser.shift(2327),
            TokenType::Float(_) => parser.shift(2328),
            TokenType::False => parser.shift(2329),
            TokenType::Function => parser.shift(2415),
            TokenType::Nil => parser.shift(2330),
            TokenType::Not => parser.shift(2332),
            TokenType::True => parser.shift(2336),
            TokenType::Sub => parser.shift(2337),
            TokenType::Len => parser.shift(2346),
            TokenType::BitXor => parser.shift(2356),
            TokenType::LParen => parser.shift(2244),
            TokenType::LCurly => parser.shift(2417),
            TokenType::Dots => parser.shift(2407),
            TokenType::Var => parser.goto(2322),
            TokenType::Exp => parser.goto(2718),
            TokenType::Functioncall => parser.goto(2324),
            TokenType::Functiondef => parser.goto(2409),
            TokenType::Tableconstructor => parser.goto(2410),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2628> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::Else => parser.reduce::<30>(),
            TokenType::Elseif => parser.reduce::<30>(),
            TokenType::End => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Comma => parser.shift(2125),
            TokenType::AttnamelistCont => parser.goto(2726),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2629> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(1177),
            TokenType::Do => parser.reduce::<21>(),
            TokenType::Or => parser.shift(1254),
            TokenType::Add => parser.shift(1299),
            TokenType::Sub => parser.shift(1316),
            TokenType::Mul => parser.shift(1342),
            TokenType::Div => parser.shift(1351),
            TokenType::Idiv => parser.shift(1364),
            TokenType::Mod => parser.shift(1402),
            TokenType::Pow => parser.shift(1460),
            TokenType::BitAnd => parser.shift(1479),
            TokenType::BitXor => parser.shift(1485),
            TokenType::BitOr => parser.shift(1500),
            TokenType::ShiftL => parser.shift(1517),
            TokenType::ShiftR => parser.shift(1523),
            TokenType::Eq => parser.shift(1534),
            TokenType::Neq => parser.shift(1557),
            TokenType::Leq => parser.shift(1569),
            TokenType::Geq => parser.shift(1575),
            TokenType::Less => parser.shift(1582),
            TokenType::Greater => parser.shift(1589),
            TokenType::Comma => parser.shift(2143),
            TokenType::Concat => parser.shift(1596),
            TokenType::StatForexp => parser.goto(2723),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2630> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Else => parser.reduce::<101>(),
            TokenType::Elseif => parser.reduce::<101>(),
            TokenType::End => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Comma => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2631> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2724),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2632> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2744),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2633> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2748),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2634> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::End => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Comma => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2635> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<103>(),
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Break => parser.reduce::<103>(),
            TokenType::Do => parser.reduce::<103>(),
            TokenType::For => parser.reduce::<103>(),
            TokenType::Function => parser.reduce::<103>(),
            TokenType::Goto => parser.reduce::<103>(),
            TokenType::If => parser.reduce::<103>(),
            TokenType::Local => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Repeat => parser.reduce::<103>(),
            TokenType::Return => parser.reduce::<103>(),
            TokenType::Until => parser.reduce::<103>(),
            TokenType::While => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::DoubleColon => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Comma => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2636> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Do => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Comma => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2637> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<103>(),
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::Break => parser.reduce::<103>(),
            TokenType::Do => parser.reduce::<103>(),
            TokenType::Else => parser.reduce::<103>(),
            TokenType::Elseif => parser.reduce::<103>(),
            TokenType::End => parser.reduce::<103>(),
            TokenType::For => parser.reduce::<103>(),
            TokenType::Function => parser.reduce::<103>(),
            TokenType::Goto => parser.reduce::<103>(),
            TokenType::If => parser.reduce::<103>(),
            TokenType::Local => parser.reduce::<103>(),
            TokenType::Repeat => parser.reduce::<103>(),
            TokenType::Return => parser.reduce::<103>(),
            TokenType::While => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::DoubleColon => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2638> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Comma => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2639> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<102>(),
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Break => parser.reduce::<102>(),
            TokenType::Do => parser.reduce::<102>(),
            TokenType::Else => parser.reduce::<102>(),
            TokenType::Elseif => parser.reduce::<102>(),
            TokenType::End => parser.reduce::<102>(),
            TokenType::For => parser.reduce::<102>(),
            TokenType::Function => parser.reduce::<102>(),
            TokenType::Goto => parser.reduce::<102>(),
            TokenType::If => parser.reduce::<102>(),
            TokenType::Local => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Repeat => parser.reduce::<102>(),
            TokenType::Return => parser.reduce::<102>(),
            TokenType::While => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::DoubleColon => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Comma => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2640> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<103>(),
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Break => parser.reduce::<103>(),
            TokenType::Do => parser.reduce::<103>(),
            TokenType::End => parser.reduce::<103>(),
            TokenType::For => parser.reduce::<103>(),
            TokenType::Function => parser.reduce::<103>(),
            TokenType::Goto => parser.reduce::<103>(),
            TokenType::If => parser.reduce::<103>(),
            TokenType::Local => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Repeat => parser.reduce::<103>(),
            TokenType::Return => parser.reduce::<103>(),
            TokenType::While => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::DoubleColon => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Comma => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2641> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Until => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Comma => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2642> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2747),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2643> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Else => parser.reduce::<102>(),
            TokenType::Elseif => parser.reduce::<102>(),
            TokenType::End => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Comma => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2644> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2755),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2645> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::End => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::SemiColon => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Comma => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2646> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<101>(),
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Break => parser.reduce::<101>(),
            TokenType::Do => parser.reduce::<101>(),
            TokenType::Else => parser.reduce::<101>(),
            TokenType::Elseif => parser.reduce::<101>(),
            TokenType::End => parser.reduce::<101>(),
            TokenType::For => parser.reduce::<101>(),
            TokenType::Function => parser.reduce::<101>(),
            TokenType::Goto => parser.reduce::<101>(),
            TokenType::If => parser.reduce::<101>(),
            TokenType::Local => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Repeat => parser.reduce::<101>(),
            TokenType::Return => parser.reduce::<101>(),
            TokenType::While => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::DoubleColon => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Comma => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2647> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<110>(),
            TokenType::End => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            TokenType::Comma => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2648> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<110>(),
            TokenType::And => parser.reduce::<110>(),
            TokenType::Break => parser.reduce::<110>(),
            TokenType::Do => parser.reduce::<110>(),
            TokenType::For => parser.reduce::<110>(),
            TokenType::Function => parser.reduce::<110>(),
            TokenType::Goto => parser.reduce::<110>(),
            TokenType::If => parser.reduce::<110>(),
            TokenType::Local => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Repeat => parser.reduce::<110>(),
            TokenType::Return => parser.reduce::<110>(),
            TokenType::While => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::LParen => parser.reduce::<110>(),
            TokenType::DoubleColon => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            TokenType::Eof => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2649> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Do => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Comma => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2650> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.shift(2538),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::Else => parser.reduce::<71>(),
            TokenType::Elseif => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            // Shift(2541)-Reduce(71)
            TokenType::LParen => parser.shift(2541),
            TokenType::LSquare => parser.shift(2746),
            TokenType::LCurly => parser.shift(2552),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.shift(2752),
            TokenType::Dot => parser.shift(2751),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Args => parser.goto(2753),
            TokenType::Tableconstructor => parser.goto(2551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2651> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<51>(),
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Break => parser.reduce::<51>(),
            TokenType::Do => parser.reduce::<51>(),
            TokenType::End => parser.reduce::<51>(),
            TokenType::For => parser.reduce::<51>(),
            TokenType::Function => parser.reduce::<51>(),
            TokenType::Goto => parser.reduce::<51>(),
            TokenType::If => parser.reduce::<51>(),
            TokenType::Local => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Repeat => parser.reduce::<51>(),
            TokenType::Return => parser.reduce::<51>(),
            TokenType::While => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::DoubleColon => parser.reduce::<51>(),
            TokenType::SemiColon => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Comma => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2652> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<51>(),
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Break => parser.reduce::<51>(),
            TokenType::Do => parser.reduce::<51>(),
            TokenType::For => parser.reduce::<51>(),
            TokenType::Function => parser.reduce::<51>(),
            TokenType::Goto => parser.reduce::<51>(),
            TokenType::If => parser.reduce::<51>(),
            TokenType::Local => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Repeat => parser.reduce::<51>(),
            TokenType::Return => parser.reduce::<51>(),
            TokenType::Until => parser.reduce::<51>(),
            TokenType::While => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::DoubleColon => parser.reduce::<51>(),
            TokenType::SemiColon => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Comma => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2653> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Else => parser.reduce::<49>(),
            TokenType::Elseif => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2654> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Else => parser.reduce::<50>(),
            TokenType::Elseif => parser.reduce::<50>(),
            TokenType::End => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2655> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<110>(),
            TokenType::Do => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::Comma => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2656> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1788),
            TokenType::LParen => parser.shift(1789),
            TokenType::LCurly => parser.shift(1852),
            TokenType::Args => parser.goto(2725),
            TokenType::Tableconstructor => parser.goto(1850),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2657> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<103>(),
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Break => parser.reduce::<103>(),
            TokenType::Do => parser.reduce::<103>(),
            TokenType::For => parser.reduce::<103>(),
            TokenType::Function => parser.reduce::<103>(),
            TokenType::Goto => parser.reduce::<103>(),
            TokenType::If => parser.reduce::<103>(),
            TokenType::Local => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Repeat => parser.reduce::<103>(),
            TokenType::Return => parser.reduce::<103>(),
            TokenType::While => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::DoubleColon => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            TokenType::Eof => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2658> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Comma => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2659> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::Else => parser.reduce::<50>(),
            TokenType::Elseif => parser.reduce::<50>(),
            TokenType::End => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Comma => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2660> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2750),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2661> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<53>(),
            TokenType::String(_) => parser.reduce::<53>(),
            TokenType::And => parser.reduce::<53>(),
            TokenType::Break => parser.reduce::<53>(),
            TokenType::Do => parser.reduce::<53>(),
            TokenType::Else => parser.reduce::<53>(),
            TokenType::Elseif => parser.reduce::<53>(),
            TokenType::End => parser.reduce::<53>(),
            TokenType::For => parser.reduce::<53>(),
            TokenType::Function => parser.reduce::<53>(),
            TokenType::Goto => parser.reduce::<53>(),
            TokenType::If => parser.reduce::<53>(),
            TokenType::Local => parser.reduce::<53>(),
            TokenType::Or => parser.reduce::<53>(),
            TokenType::Repeat => parser.reduce::<53>(),
            TokenType::Return => parser.reduce::<53>(),
            TokenType::While => parser.reduce::<53>(),
            TokenType::Add => parser.reduce::<53>(),
            TokenType::Sub => parser.reduce::<53>(),
            TokenType::Mul => parser.reduce::<53>(),
            TokenType::Div => parser.reduce::<53>(),
            TokenType::Idiv => parser.reduce::<53>(),
            TokenType::Mod => parser.reduce::<53>(),
            TokenType::Pow => parser.reduce::<53>(),
            TokenType::BitAnd => parser.reduce::<53>(),
            TokenType::BitXor => parser.reduce::<53>(),
            TokenType::BitOr => parser.reduce::<53>(),
            TokenType::ShiftL => parser.reduce::<53>(),
            TokenType::ShiftR => parser.reduce::<53>(),
            TokenType::Eq => parser.reduce::<53>(),
            TokenType::Neq => parser.reduce::<53>(),
            TokenType::Leq => parser.reduce::<53>(),
            TokenType::Geq => parser.reduce::<53>(),
            TokenType::Less => parser.reduce::<53>(),
            TokenType::Greater => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::LSquare => parser.reduce::<53>(),
            TokenType::LCurly => parser.reduce::<53>(),
            TokenType::DoubleColon => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Colon => parser.reduce::<53>(),
            TokenType::Dot => parser.reduce::<53>(),
            TokenType::Concat => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2662> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::Else => parser.reduce::<117>(),
            TokenType::Elseif => parser.reduce::<117>(),
            TokenType::End => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2663> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2664> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<110>(),
            TokenType::And => parser.reduce::<110>(),
            TokenType::Break => parser.reduce::<110>(),
            TokenType::Do => parser.reduce::<110>(),
            TokenType::For => parser.reduce::<110>(),
            TokenType::Function => parser.reduce::<110>(),
            TokenType::Goto => parser.reduce::<110>(),
            TokenType::If => parser.reduce::<110>(),
            TokenType::Local => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Repeat => parser.reduce::<110>(),
            TokenType::Return => parser.reduce::<110>(),
            TokenType::Until => parser.reduce::<110>(),
            TokenType::While => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::LParen => parser.reduce::<110>(),
            TokenType::DoubleColon => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            TokenType::Comma => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2665> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<110>(),
            TokenType::And => parser.reduce::<110>(),
            TokenType::Break => parser.reduce::<110>(),
            TokenType::Do => parser.reduce::<110>(),
            TokenType::End => parser.reduce::<110>(),
            TokenType::For => parser.reduce::<110>(),
            TokenType::Function => parser.reduce::<110>(),
            TokenType::Goto => parser.reduce::<110>(),
            TokenType::If => parser.reduce::<110>(),
            TokenType::Local => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Repeat => parser.reduce::<110>(),
            TokenType::Return => parser.reduce::<110>(),
            TokenType::While => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::LParen => parser.reduce::<110>(),
            TokenType::DoubleColon => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            TokenType::Comma => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2666> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2754),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2667> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<51>(),
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Break => parser.reduce::<51>(),
            TokenType::Do => parser.reduce::<51>(),
            TokenType::For => parser.reduce::<51>(),
            TokenType::Function => parser.reduce::<51>(),
            TokenType::Goto => parser.reduce::<51>(),
            TokenType::If => parser.reduce::<51>(),
            TokenType::Local => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Repeat => parser.reduce::<51>(),
            TokenType::Return => parser.reduce::<51>(),
            TokenType::While => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::DoubleColon => parser.reduce::<51>(),
            TokenType::SemiColon => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            TokenType::Eof => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2668> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<52>(),
            TokenType::String(_) => parser.reduce::<52>(),
            TokenType::And => parser.reduce::<52>(),
            TokenType::Break => parser.reduce::<52>(),
            TokenType::Do => parser.reduce::<52>(),
            TokenType::Else => parser.reduce::<52>(),
            TokenType::Elseif => parser.reduce::<52>(),
            TokenType::End => parser.reduce::<52>(),
            TokenType::For => parser.reduce::<52>(),
            TokenType::Function => parser.reduce::<52>(),
            TokenType::Goto => parser.reduce::<52>(),
            TokenType::If => parser.reduce::<52>(),
            TokenType::Local => parser.reduce::<52>(),
            TokenType::Or => parser.reduce::<52>(),
            TokenType::Repeat => parser.reduce::<52>(),
            TokenType::Return => parser.reduce::<52>(),
            TokenType::While => parser.reduce::<52>(),
            TokenType::Add => parser.reduce::<52>(),
            TokenType::Sub => parser.reduce::<52>(),
            TokenType::Mul => parser.reduce::<52>(),
            TokenType::Div => parser.reduce::<52>(),
            TokenType::Idiv => parser.reduce::<52>(),
            TokenType::Mod => parser.reduce::<52>(),
            TokenType::Pow => parser.reduce::<52>(),
            TokenType::BitAnd => parser.reduce::<52>(),
            TokenType::BitXor => parser.reduce::<52>(),
            TokenType::BitOr => parser.reduce::<52>(),
            TokenType::ShiftL => parser.reduce::<52>(),
            TokenType::ShiftR => parser.reduce::<52>(),
            TokenType::Eq => parser.reduce::<52>(),
            TokenType::Neq => parser.reduce::<52>(),
            TokenType::Leq => parser.reduce::<52>(),
            TokenType::Geq => parser.reduce::<52>(),
            TokenType::Less => parser.reduce::<52>(),
            TokenType::Greater => parser.reduce::<52>(),
            TokenType::LParen => parser.reduce::<52>(),
            TokenType::LSquare => parser.reduce::<52>(),
            TokenType::LCurly => parser.reduce::<52>(),
            TokenType::DoubleColon => parser.reduce::<52>(),
            TokenType::SemiColon => parser.reduce::<52>(),
            TokenType::Colon => parser.reduce::<52>(),
            TokenType::Dot => parser.reduce::<52>(),
            TokenType::Concat => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2669> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2749),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2670> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<104>(),
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Break => parser.reduce::<104>(),
            TokenType::Do => parser.reduce::<104>(),
            TokenType::Else => parser.reduce::<104>(),
            TokenType::Elseif => parser.reduce::<104>(),
            TokenType::End => parser.reduce::<104>(),
            TokenType::For => parser.reduce::<104>(),
            TokenType::Function => parser.reduce::<104>(),
            TokenType::Goto => parser.reduce::<104>(),
            TokenType::If => parser.reduce::<104>(),
            TokenType::Local => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Repeat => parser.reduce::<104>(),
            TokenType::Return => parser.reduce::<104>(),
            TokenType::While => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::DoubleColon => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Comma => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2671> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::Else => parser.reduce::<117>(),
            TokenType::Elseif => parser.reduce::<117>(),
            TokenType::End => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2672> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::Else => parser.reduce::<49>(),
            TokenType::Elseif => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2673> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Until => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            TokenType::Comma => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2674> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::Until => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2675> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Else => parser.reduce::<104>(),
            TokenType::Elseif => parser.reduce::<104>(),
            TokenType::End => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Comma => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2676> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Until => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::SemiColon => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Comma => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2677> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(2538),
            TokenType::LParen => parser.shift(2541),
            TokenType::LCurly => parser.shift(2552),
            TokenType::Args => parser.goto(2727),
            TokenType::Tableconstructor => parser.goto(2551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2678> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(2538),
            TokenType::LParen => parser.shift(2541),
            TokenType::LCurly => parser.shift(2552),
            TokenType::Args => parser.goto(2728),
            TokenType::Tableconstructor => parser.goto(2551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2679> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::Comma => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2680> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1828),
            TokenType::LParen => parser.shift(1832),
            TokenType::LCurly => parser.shift(1855),
            TokenType::Args => parser.goto(2729),
            TokenType::Tableconstructor => parser.goto(1853),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2681> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Else => parser.reduce::<117>(),
            TokenType::Elseif => parser.reduce::<117>(),
            TokenType::End => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Comma => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2682> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2730),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2683> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<60>(),
            TokenType::Elseif => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2684> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<17>(),
            TokenType::End => parser.reduce::<17>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2685> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2731),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2686> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2735),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2687> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2732),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2688> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2734),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2689> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Else => parser.reduce::<100>(),
            TokenType::Elseif => parser.reduce::<100>(),
            TokenType::End => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Comma => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2690> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2733),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2691> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2743),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2692> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<100>(),
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Break => parser.reduce::<100>(),
            TokenType::Do => parser.reduce::<100>(),
            TokenType::Else => parser.reduce::<100>(),
            TokenType::Elseif => parser.reduce::<100>(),
            TokenType::End => parser.reduce::<100>(),
            TokenType::For => parser.reduce::<100>(),
            TokenType::Function => parser.reduce::<100>(),
            TokenType::Goto => parser.reduce::<100>(),
            TokenType::If => parser.reduce::<100>(),
            TokenType::Local => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Repeat => parser.reduce::<100>(),
            TokenType::Return => parser.reduce::<100>(),
            TokenType::While => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::DoubleColon => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Comma => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2693> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2737),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2694> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::Else => parser.reduce::<60>(),
            TokenType::Elseif => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2695> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2736),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2696> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2739),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2697> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2740),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2698> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2741),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2699> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2738),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2700> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(2745),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2701> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<74>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<74>(),
            TokenType::Break => parser.reduce::<74>(),
            TokenType::Do => parser.reduce::<74>(),
            TokenType::Else => parser.reduce::<74>(),
            TokenType::Elseif => parser.reduce::<74>(),
            TokenType::End => parser.reduce::<74>(),
            TokenType::For => parser.reduce::<74>(),
            TokenType::Function => parser.reduce::<74>(),
            TokenType::Goto => parser.reduce::<74>(),
            TokenType::If => parser.reduce::<74>(),
            TokenType::Local => parser.reduce::<74>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<74>(),
            TokenType::Repeat => parser.reduce::<74>(),
            TokenType::Return => parser.reduce::<74>(),
            TokenType::While => parser.reduce::<74>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<74>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<74>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<74>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<74>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<74>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<74>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<74>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<74>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<74>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<74>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<74>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<74>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<74>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<74>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<74>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<74>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<74>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<74>(),
            TokenType::LParen => parser.reduce::<74>(),
            TokenType::DoubleColon => parser.reduce::<74>(),
            TokenType::SemiColon => parser.reduce::<74>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<74>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2702> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(2742),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2703> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<92>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<92>(),
            TokenType::Break => parser.reduce::<92>(),
            TokenType::Do => parser.reduce::<92>(),
            TokenType::Else => parser.reduce::<92>(),
            TokenType::Elseif => parser.reduce::<92>(),
            TokenType::End => parser.reduce::<92>(),
            TokenType::For => parser.reduce::<92>(),
            TokenType::Function => parser.reduce::<92>(),
            TokenType::Goto => parser.reduce::<92>(),
            TokenType::If => parser.reduce::<92>(),
            TokenType::Local => parser.reduce::<92>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<92>(),
            TokenType::Repeat => parser.reduce::<92>(),
            TokenType::Return => parser.reduce::<92>(),
            TokenType::While => parser.reduce::<92>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<92>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<92>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<92>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<92>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<92>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<92>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<92>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<92>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<92>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<92>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<92>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<92>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<92>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<92>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<92>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<92>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<92>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<92>(),
            TokenType::LParen => parser.reduce::<92>(),
            TokenType::DoubleColon => parser.reduce::<92>(),
            TokenType::SemiColon => parser.reduce::<92>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2704> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::Else => parser.reduce::<77>(),
            TokenType::Elseif => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2705> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<90>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<90>(),
            TokenType::Break => parser.reduce::<90>(),
            TokenType::Do => parser.reduce::<90>(),
            TokenType::Else => parser.reduce::<90>(),
            TokenType::Elseif => parser.reduce::<90>(),
            TokenType::End => parser.reduce::<90>(),
            TokenType::For => parser.reduce::<90>(),
            TokenType::Function => parser.reduce::<90>(),
            TokenType::Goto => parser.reduce::<90>(),
            TokenType::If => parser.reduce::<90>(),
            TokenType::Local => parser.reduce::<90>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<90>(),
            TokenType::Repeat => parser.reduce::<90>(),
            TokenType::Return => parser.reduce::<90>(),
            TokenType::While => parser.reduce::<90>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<90>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<90>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<90>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<90>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<90>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<90>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<90>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<90>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<90>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<90>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<90>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<90>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<90>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<90>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<90>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<90>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<90>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<90>(),
            TokenType::LParen => parser.reduce::<90>(),
            TokenType::DoubleColon => parser.reduce::<90>(),
            TokenType::SemiColon => parser.reduce::<90>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2706> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::Else => parser.reduce::<73>(),
            TokenType::Elseif => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2707> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::Else => parser.reduce::<76>(),
            TokenType::Elseif => parser.reduce::<76>(),
            TokenType::End => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2708> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<85>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<85>(),
            TokenType::Break => parser.reduce::<85>(),
            TokenType::Do => parser.reduce::<85>(),
            TokenType::Else => parser.reduce::<85>(),
            TokenType::Elseif => parser.reduce::<85>(),
            TokenType::End => parser.reduce::<85>(),
            TokenType::For => parser.reduce::<85>(),
            TokenType::Function => parser.reduce::<85>(),
            TokenType::Goto => parser.reduce::<85>(),
            TokenType::If => parser.reduce::<85>(),
            TokenType::Local => parser.reduce::<85>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<85>(),
            TokenType::Repeat => parser.reduce::<85>(),
            TokenType::Return => parser.reduce::<85>(),
            TokenType::While => parser.reduce::<85>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<85>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<85>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<85>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<85>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<85>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<85>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<85>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<85>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<85>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<85>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<85>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<85>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<85>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<85>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<85>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<85>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<85>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<85>(),
            TokenType::LParen => parser.reduce::<85>(),
            TokenType::DoubleColon => parser.reduce::<85>(),
            TokenType::SemiColon => parser.reduce::<85>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2709> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<89>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<89>(),
            TokenType::Break => parser.reduce::<89>(),
            TokenType::Do => parser.reduce::<89>(),
            TokenType::Else => parser.reduce::<89>(),
            TokenType::Elseif => parser.reduce::<89>(),
            TokenType::End => parser.reduce::<89>(),
            TokenType::For => parser.reduce::<89>(),
            TokenType::Function => parser.reduce::<89>(),
            TokenType::Goto => parser.reduce::<89>(),
            TokenType::If => parser.reduce::<89>(),
            TokenType::Local => parser.reduce::<89>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<89>(),
            TokenType::Repeat => parser.reduce::<89>(),
            TokenType::Return => parser.reduce::<89>(),
            TokenType::While => parser.reduce::<89>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<89>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<89>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<89>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<89>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<89>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<89>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<89>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<89>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<89>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<89>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<89>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<89>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<89>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<89>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<89>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<89>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<89>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<89>(),
            TokenType::LParen => parser.reduce::<89>(),
            TokenType::DoubleColon => parser.reduce::<89>(),
            TokenType::SemiColon => parser.reduce::<89>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2710> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<75>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<75>(),
            TokenType::Break => parser.reduce::<75>(),
            TokenType::Do => parser.reduce::<75>(),
            TokenType::Else => parser.reduce::<75>(),
            TokenType::Elseif => parser.reduce::<75>(),
            TokenType::End => parser.reduce::<75>(),
            TokenType::For => parser.reduce::<75>(),
            TokenType::Function => parser.reduce::<75>(),
            TokenType::Goto => parser.reduce::<75>(),
            TokenType::If => parser.reduce::<75>(),
            TokenType::Local => parser.reduce::<75>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<75>(),
            TokenType::Repeat => parser.reduce::<75>(),
            TokenType::Return => parser.reduce::<75>(),
            TokenType::While => parser.reduce::<75>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<75>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<75>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<75>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<75>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<75>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<75>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<75>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<75>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<75>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<75>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<75>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<75>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<75>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<75>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<75>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<75>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<75>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<75>(),
            TokenType::LParen => parser.reduce::<75>(),
            TokenType::DoubleColon => parser.reduce::<75>(),
            TokenType::SemiColon => parser.reduce::<75>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2711> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<81>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<81>(),
            TokenType::Break => parser.reduce::<81>(),
            TokenType::Do => parser.reduce::<81>(),
            TokenType::Else => parser.reduce::<81>(),
            TokenType::Elseif => parser.reduce::<81>(),
            TokenType::End => parser.reduce::<81>(),
            TokenType::For => parser.reduce::<81>(),
            TokenType::Function => parser.reduce::<81>(),
            TokenType::Goto => parser.reduce::<81>(),
            TokenType::If => parser.reduce::<81>(),
            TokenType::Local => parser.reduce::<81>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<81>(),
            TokenType::Repeat => parser.reduce::<81>(),
            TokenType::Return => parser.reduce::<81>(),
            TokenType::While => parser.reduce::<81>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<81>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<81>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<81>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<81>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<81>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<81>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<81>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<81>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<81>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<81>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<81>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<81>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<81>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<81>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<81>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<81>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<81>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<81>(),
            TokenType::LParen => parser.reduce::<81>(),
            TokenType::DoubleColon => parser.reduce::<81>(),
            TokenType::SemiColon => parser.reduce::<81>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2712> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<80>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<80>(),
            TokenType::Break => parser.reduce::<80>(),
            TokenType::Do => parser.reduce::<80>(),
            TokenType::Else => parser.reduce::<80>(),
            TokenType::Elseif => parser.reduce::<80>(),
            TokenType::End => parser.reduce::<80>(),
            TokenType::For => parser.reduce::<80>(),
            TokenType::Function => parser.reduce::<80>(),
            TokenType::Goto => parser.reduce::<80>(),
            TokenType::If => parser.reduce::<80>(),
            TokenType::Local => parser.reduce::<80>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<80>(),
            TokenType::Repeat => parser.reduce::<80>(),
            TokenType::Return => parser.reduce::<80>(),
            TokenType::While => parser.reduce::<80>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<80>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<80>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<80>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<80>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<80>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<80>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<80>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<80>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<80>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<80>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<80>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<80>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<80>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<80>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<80>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<80>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<80>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<80>(),
            TokenType::LParen => parser.reduce::<80>(),
            TokenType::DoubleColon => parser.reduce::<80>(),
            TokenType::SemiColon => parser.reduce::<80>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<80>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2713> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<91>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<91>(),
            TokenType::Break => parser.reduce::<91>(),
            TokenType::Do => parser.reduce::<91>(),
            TokenType::Else => parser.reduce::<91>(),
            TokenType::Elseif => parser.reduce::<91>(),
            TokenType::End => parser.reduce::<91>(),
            TokenType::For => parser.reduce::<91>(),
            TokenType::Function => parser.reduce::<91>(),
            TokenType::Goto => parser.reduce::<91>(),
            TokenType::If => parser.reduce::<91>(),
            TokenType::Local => parser.reduce::<91>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<91>(),
            TokenType::Repeat => parser.reduce::<91>(),
            TokenType::Return => parser.reduce::<91>(),
            TokenType::While => parser.reduce::<91>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<91>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<91>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<91>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<91>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<91>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<91>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<91>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<91>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<91>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<91>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<91>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<91>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<91>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<91>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<91>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<91>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<91>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<91>(),
            TokenType::LParen => parser.reduce::<91>(),
            TokenType::DoubleColon => parser.reduce::<91>(),
            TokenType::SemiColon => parser.reduce::<91>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<91>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2714> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<84>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<84>(),
            TokenType::Break => parser.reduce::<84>(),
            TokenType::Do => parser.reduce::<84>(),
            TokenType::Else => parser.reduce::<84>(),
            TokenType::Elseif => parser.reduce::<84>(),
            TokenType::End => parser.reduce::<84>(),
            TokenType::For => parser.reduce::<84>(),
            TokenType::Function => parser.reduce::<84>(),
            TokenType::Goto => parser.reduce::<84>(),
            TokenType::If => parser.reduce::<84>(),
            TokenType::Local => parser.reduce::<84>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<84>(),
            TokenType::Repeat => parser.reduce::<84>(),
            TokenType::Return => parser.reduce::<84>(),
            TokenType::While => parser.reduce::<84>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<84>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<84>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<84>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<84>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<84>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<84>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<84>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<84>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<84>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<84>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<84>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<84>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<84>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<84>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<84>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<84>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<84>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<84>(),
            TokenType::LParen => parser.reduce::<84>(),
            TokenType::DoubleColon => parser.reduce::<84>(),
            TokenType::SemiColon => parser.reduce::<84>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2715> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<82>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<82>(),
            TokenType::Break => parser.reduce::<82>(),
            TokenType::Do => parser.reduce::<82>(),
            TokenType::Else => parser.reduce::<82>(),
            TokenType::Elseif => parser.reduce::<82>(),
            TokenType::End => parser.reduce::<82>(),
            TokenType::For => parser.reduce::<82>(),
            TokenType::Function => parser.reduce::<82>(),
            TokenType::Goto => parser.reduce::<82>(),
            TokenType::If => parser.reduce::<82>(),
            TokenType::Local => parser.reduce::<82>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<82>(),
            TokenType::Repeat => parser.reduce::<82>(),
            TokenType::Return => parser.reduce::<82>(),
            TokenType::While => parser.reduce::<82>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<82>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<82>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<82>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<82>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<82>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<82>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<82>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<82>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<82>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<82>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<82>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<82>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<82>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<82>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<82>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<82>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<82>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<82>(),
            TokenType::LParen => parser.reduce::<82>(),
            TokenType::DoubleColon => parser.reduce::<82>(),
            TokenType::SemiColon => parser.reduce::<82>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2716> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::Else => parser.reduce::<79>(),
            TokenType::Elseif => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2717> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::Else => parser.reduce::<78>(),
            TokenType::Elseif => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2718> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<86>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<86>(),
            TokenType::Break => parser.reduce::<86>(),
            TokenType::Do => parser.reduce::<86>(),
            TokenType::Else => parser.reduce::<86>(),
            TokenType::Elseif => parser.reduce::<86>(),
            TokenType::End => parser.reduce::<86>(),
            TokenType::For => parser.reduce::<86>(),
            TokenType::Function => parser.reduce::<86>(),
            TokenType::Goto => parser.reduce::<86>(),
            TokenType::If => parser.reduce::<86>(),
            TokenType::Local => parser.reduce::<86>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<86>(),
            TokenType::Repeat => parser.reduce::<86>(),
            TokenType::Return => parser.reduce::<86>(),
            TokenType::While => parser.reduce::<86>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<86>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<86>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<86>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<86>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<86>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<86>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<86>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<86>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<86>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<86>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<86>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<86>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<86>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<86>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<86>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<86>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<86>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<86>(),
            TokenType::LParen => parser.reduce::<86>(),
            TokenType::DoubleColon => parser.reduce::<86>(),
            TokenType::SemiColon => parser.reduce::<86>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2719> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<83>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<83>(),
            TokenType::Break => parser.reduce::<83>(),
            TokenType::Do => parser.reduce::<83>(),
            TokenType::Else => parser.reduce::<83>(),
            TokenType::Elseif => parser.reduce::<83>(),
            TokenType::End => parser.reduce::<83>(),
            TokenType::For => parser.reduce::<83>(),
            TokenType::Function => parser.reduce::<83>(),
            TokenType::Goto => parser.reduce::<83>(),
            TokenType::If => parser.reduce::<83>(),
            TokenType::Local => parser.reduce::<83>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<83>(),
            TokenType::Repeat => parser.reduce::<83>(),
            TokenType::Return => parser.reduce::<83>(),
            TokenType::While => parser.reduce::<83>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<83>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<83>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<83>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<83>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<83>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<83>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<83>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<83>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<83>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<83>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<83>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<83>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<83>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<83>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<83>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<83>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<83>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<83>(),
            TokenType::LParen => parser.reduce::<83>(),
            TokenType::DoubleColon => parser.reduce::<83>(),
            TokenType::SemiColon => parser.reduce::<83>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<83>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2720> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `-` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `+`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<88>(),
            TokenType::And => parser.reduce::<88>(),
            TokenType::Break => parser.reduce::<88>(),
            TokenType::Do => parser.reduce::<88>(),
            TokenType::Else => parser.reduce::<88>(),
            TokenType::Elseif => parser.reduce::<88>(),
            TokenType::End => parser.reduce::<88>(),
            TokenType::For => parser.reduce::<88>(),
            TokenType::Function => parser.reduce::<88>(),
            TokenType::Goto => parser.reduce::<88>(),
            TokenType::If => parser.reduce::<88>(),
            TokenType::Local => parser.reduce::<88>(),
            TokenType::Or => parser.reduce::<88>(),
            TokenType::Repeat => parser.reduce::<88>(),
            TokenType::Return => parser.reduce::<88>(),
            TokenType::While => parser.reduce::<88>(),
            TokenType::Add => parser.reduce::<88>(),
            TokenType::Sub => parser.reduce::<88>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Div => parser.shift(2590),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Mod => parser.shift(2603),
            TokenType::Pow => parser.shift(2615),
            TokenType::BitAnd => parser.reduce::<88>(),
            TokenType::BitXor => parser.reduce::<88>(),
            TokenType::BitOr => parser.reduce::<88>(),
            TokenType::ShiftL => parser.reduce::<88>(),
            TokenType::ShiftR => parser.reduce::<88>(),
            TokenType::Eq => parser.reduce::<88>(),
            TokenType::Neq => parser.reduce::<88>(),
            TokenType::Leq => parser.reduce::<88>(),
            TokenType::Geq => parser.reduce::<88>(),
            TokenType::Less => parser.reduce::<88>(),
            TokenType::Greater => parser.reduce::<88>(),
            TokenType::LParen => parser.reduce::<88>(),
            TokenType::DoubleColon => parser.reduce::<88>(),
            TokenType::SemiColon => parser.reduce::<88>(),
            TokenType::Concat => parser.reduce::<88>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2721> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<97>(),
            TokenType::And => parser.shift(2468),
            TokenType::And => parser.reduce::<97>(),
            TokenType::Break => parser.reduce::<97>(),
            TokenType::Do => parser.reduce::<97>(),
            TokenType::Else => parser.reduce::<97>(),
            TokenType::Elseif => parser.reduce::<97>(),
            TokenType::End => parser.reduce::<97>(),
            TokenType::For => parser.reduce::<97>(),
            TokenType::Function => parser.reduce::<97>(),
            TokenType::Goto => parser.reduce::<97>(),
            TokenType::If => parser.reduce::<97>(),
            TokenType::Local => parser.reduce::<97>(),
            TokenType::Or => parser.shift(2542),
            TokenType::Or => parser.reduce::<97>(),
            TokenType::Repeat => parser.reduce::<97>(),
            TokenType::Return => parser.reduce::<97>(),
            TokenType::While => parser.reduce::<97>(),
            TokenType::Add => parser.shift(2558),
            TokenType::Add => parser.reduce::<97>(),
            TokenType::Sub => parser.shift(2560),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Mul => parser.reduce::<97>(),
            TokenType::Div => parser.shift(2590),
            TokenType::Div => parser.reduce::<97>(),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Idiv => parser.reduce::<97>(),
            TokenType::Mod => parser.shift(2603),
            TokenType::Mod => parser.reduce::<97>(),
            TokenType::Pow => parser.shift(2615),
            TokenType::Pow => parser.reduce::<97>(),
            TokenType::BitAnd => parser.shift(2616),
            TokenType::BitAnd => parser.reduce::<97>(),
            TokenType::BitXor => parser.shift(2617),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::BitOr => parser.shift(2618),
            TokenType::BitOr => parser.reduce::<97>(),
            TokenType::ShiftL => parser.shift(2619),
            TokenType::ShiftL => parser.reduce::<97>(),
            TokenType::ShiftR => parser.shift(2620),
            TokenType::ShiftR => parser.reduce::<97>(),
            TokenType::Eq => parser.shift(2621),
            TokenType::Eq => parser.reduce::<97>(),
            TokenType::Neq => parser.shift(2622),
            TokenType::Neq => parser.reduce::<97>(),
            TokenType::Leq => parser.shift(2623),
            TokenType::Leq => parser.reduce::<97>(),
            TokenType::Geq => parser.shift(2624),
            TokenType::Geq => parser.reduce::<97>(),
            TokenType::Less => parser.shift(2625),
            TokenType::Less => parser.reduce::<97>(),
            TokenType::Greater => parser.shift(2626),
            TokenType::Greater => parser.reduce::<97>(),
            TokenType::LParen => parser.reduce::<97>(),
            TokenType::DoubleColon => parser.reduce::<97>(),
            TokenType::SemiColon => parser.reduce::<97>(),
            TokenType::Concat => parser.shift(2627),
            TokenType::Concat => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2722> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Operator Precedence
        // Operator `+` has smaller precedente to unary operators
        // and `*`, `/`, `//`, `%` and `^`, and is left associative with
        // `-`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::Else => parser.reduce::<87>(),
            TokenType::Elseif => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.shift(2585),
            TokenType::Div => parser.shift(2590),
            TokenType::Idiv => parser.shift(2593),
            TokenType::Mod => parser.shift(2603),
            TokenType::Pow => parser.shift(2615),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2723> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(2766),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2724> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<15>(),
            TokenType::Break => parser.reduce::<15>(),
            TokenType::Do => parser.reduce::<15>(),
            TokenType::Else => parser.reduce::<15>(),
            TokenType::Elseif => parser.reduce::<15>(),
            TokenType::End => parser.reduce::<15>(),
            TokenType::For => parser.reduce::<15>(),
            TokenType::Function => parser.reduce::<15>(),
            TokenType::Goto => parser.reduce::<15>(),
            TokenType::If => parser.reduce::<15>(),
            TokenType::Local => parser.reduce::<15>(),
            TokenType::Repeat => parser.reduce::<15>(),
            TokenType::Return => parser.reduce::<15>(),
            TokenType::While => parser.reduce::<15>(),
            TokenType::LParen => parser.reduce::<15>(),
            TokenType::DoubleColon => parser.reduce::<15>(),
            TokenType::SemiColon => parser.reduce::<15>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2725> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<103>(),
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Break => parser.reduce::<103>(),
            TokenType::Do => parser.reduce::<103>(),
            TokenType::End => parser.reduce::<103>(),
            TokenType::For => parser.reduce::<103>(),
            TokenType::Function => parser.reduce::<103>(),
            TokenType::Goto => parser.reduce::<103>(),
            TokenType::If => parser.reduce::<103>(),
            TokenType::Local => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Repeat => parser.reduce::<103>(),
            TokenType::Return => parser.reduce::<103>(),
            TokenType::While => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::DoubleColon => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2726> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::Else => parser.reduce::<31>(),
            TokenType::Elseif => parser.reduce::<31>(),
            TokenType::End => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2727> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<102>(),
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::And => parser.reduce::<102>(),
            TokenType::Break => parser.reduce::<102>(),
            TokenType::Do => parser.reduce::<102>(),
            TokenType::Else => parser.reduce::<102>(),
            TokenType::Elseif => parser.reduce::<102>(),
            TokenType::End => parser.reduce::<102>(),
            TokenType::For => parser.reduce::<102>(),
            TokenType::Function => parser.reduce::<102>(),
            TokenType::Goto => parser.reduce::<102>(),
            TokenType::If => parser.reduce::<102>(),
            TokenType::Local => parser.reduce::<102>(),
            TokenType::Or => parser.reduce::<102>(),
            TokenType::Repeat => parser.reduce::<102>(),
            TokenType::Return => parser.reduce::<102>(),
            TokenType::While => parser.reduce::<102>(),
            TokenType::Add => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Mul => parser.reduce::<102>(),
            TokenType::Div => parser.reduce::<102>(),
            TokenType::Idiv => parser.reduce::<102>(),
            TokenType::Mod => parser.reduce::<102>(),
            TokenType::Pow => parser.reduce::<102>(),
            TokenType::BitAnd => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::BitOr => parser.reduce::<102>(),
            TokenType::ShiftL => parser.reduce::<102>(),
            TokenType::ShiftR => parser.reduce::<102>(),
            TokenType::Eq => parser.reduce::<102>(),
            TokenType::Neq => parser.reduce::<102>(),
            TokenType::Leq => parser.reduce::<102>(),
            TokenType::Geq => parser.reduce::<102>(),
            TokenType::Less => parser.reduce::<102>(),
            TokenType::Greater => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LSquare => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::DoubleColon => parser.reduce::<102>(),
            TokenType::SemiColon => parser.reduce::<102>(),
            TokenType::Colon => parser.reduce::<102>(),
            TokenType::Dot => parser.reduce::<102>(),
            TokenType::Concat => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2728> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<101>(),
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::And => parser.reduce::<101>(),
            TokenType::Break => parser.reduce::<101>(),
            TokenType::Do => parser.reduce::<101>(),
            TokenType::Else => parser.reduce::<101>(),
            TokenType::Elseif => parser.reduce::<101>(),
            TokenType::End => parser.reduce::<101>(),
            TokenType::For => parser.reduce::<101>(),
            TokenType::Function => parser.reduce::<101>(),
            TokenType::Goto => parser.reduce::<101>(),
            TokenType::If => parser.reduce::<101>(),
            TokenType::Local => parser.reduce::<101>(),
            TokenType::Or => parser.reduce::<101>(),
            TokenType::Repeat => parser.reduce::<101>(),
            TokenType::Return => parser.reduce::<101>(),
            TokenType::While => parser.reduce::<101>(),
            TokenType::Add => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Mul => parser.reduce::<101>(),
            TokenType::Div => parser.reduce::<101>(),
            TokenType::Idiv => parser.reduce::<101>(),
            TokenType::Mod => parser.reduce::<101>(),
            TokenType::Pow => parser.reduce::<101>(),
            TokenType::BitAnd => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::BitOr => parser.reduce::<101>(),
            TokenType::ShiftL => parser.reduce::<101>(),
            TokenType::ShiftR => parser.reduce::<101>(),
            TokenType::Eq => parser.reduce::<101>(),
            TokenType::Neq => parser.reduce::<101>(),
            TokenType::Leq => parser.reduce::<101>(),
            TokenType::Geq => parser.reduce::<101>(),
            TokenType::Less => parser.reduce::<101>(),
            TokenType::Greater => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LSquare => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::DoubleColon => parser.reduce::<101>(),
            TokenType::SemiColon => parser.reduce::<101>(),
            TokenType::Colon => parser.reduce::<101>(),
            TokenType::Dot => parser.reduce::<101>(),
            TokenType::Concat => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2729> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<103>(),
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Break => parser.reduce::<103>(),
            TokenType::Do => parser.reduce::<103>(),
            TokenType::For => parser.reduce::<103>(),
            TokenType::Function => parser.reduce::<103>(),
            TokenType::Goto => parser.reduce::<103>(),
            TokenType::If => parser.reduce::<103>(),
            TokenType::Local => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Repeat => parser.reduce::<103>(),
            TokenType::Return => parser.reduce::<103>(),
            TokenType::Until => parser.reduce::<103>(),
            TokenType::While => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::DoubleColon => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2730> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<23>(),
            TokenType::Break => parser.reduce::<23>(),
            TokenType::Do => parser.reduce::<23>(),
            TokenType::Else => parser.reduce::<23>(),
            TokenType::Elseif => parser.reduce::<23>(),
            TokenType::End => parser.reduce::<23>(),
            TokenType::For => parser.reduce::<23>(),
            TokenType::Function => parser.reduce::<23>(),
            TokenType::Goto => parser.reduce::<23>(),
            TokenType::If => parser.reduce::<23>(),
            TokenType::Local => parser.reduce::<23>(),
            TokenType::Repeat => parser.reduce::<23>(),
            TokenType::Return => parser.reduce::<23>(),
            TokenType::While => parser.reduce::<23>(),
            TokenType::LParen => parser.reduce::<23>(),
            TokenType::DoubleColon => parser.reduce::<23>(),
            TokenType::SemiColon => parser.reduce::<23>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2731> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<20>(),
            TokenType::Break => parser.reduce::<20>(),
            TokenType::Do => parser.reduce::<20>(),
            TokenType::For => parser.reduce::<20>(),
            TokenType::Function => parser.reduce::<20>(),
            TokenType::Goto => parser.reduce::<20>(),
            TokenType::If => parser.reduce::<20>(),
            TokenType::Local => parser.reduce::<20>(),
            TokenType::Repeat => parser.reduce::<20>(),
            TokenType::Return => parser.reduce::<20>(),
            TokenType::While => parser.reduce::<20>(),
            TokenType::LParen => parser.reduce::<20>(),
            TokenType::DoubleColon => parser.reduce::<20>(),
            TokenType::SemiColon => parser.reduce::<20>(),
            TokenType::Eof => parser.reduce::<20>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2732> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Else => parser.reduce::<54>(),
            TokenType::Elseif => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Comma => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2733> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::Else => parser.reduce::<54>(),
            TokenType::Elseif => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Comma => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2734> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(2261),
            TokenType::LParen => parser.shift(2265),
            TokenType::LCurly => parser.shift(2307),
            TokenType::Args => parser.goto(2756),
            TokenType::Tableconstructor => parser.goto(2306),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2735> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<51>(),
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Break => parser.reduce::<51>(),
            TokenType::Do => parser.reduce::<51>(),
            TokenType::End => parser.reduce::<51>(),
            TokenType::For => parser.reduce::<51>(),
            TokenType::Function => parser.reduce::<51>(),
            TokenType::Goto => parser.reduce::<51>(),
            TokenType::If => parser.reduce::<51>(),
            TokenType::Local => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Repeat => parser.reduce::<51>(),
            TokenType::Return => parser.reduce::<51>(),
            TokenType::While => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::DoubleColon => parser.reduce::<51>(),
            TokenType::SemiColon => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2736> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::Else => parser.reduce::<49>(),
            TokenType::Elseif => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2737> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<51>(),
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Break => parser.reduce::<51>(),
            TokenType::Do => parser.reduce::<51>(),
            TokenType::For => parser.reduce::<51>(),
            TokenType::Function => parser.reduce::<51>(),
            TokenType::Goto => parser.reduce::<51>(),
            TokenType::If => parser.reduce::<51>(),
            TokenType::Local => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Repeat => parser.reduce::<51>(),
            TokenType::Return => parser.reduce::<51>(),
            TokenType::Until => parser.reduce::<51>(),
            TokenType::While => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::DoubleColon => parser.reduce::<51>(),
            TokenType::SemiColon => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2738> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<110>(),
            TokenType::Break => parser.reduce::<110>(),
            TokenType::Do => parser.reduce::<110>(),
            TokenType::Else => parser.reduce::<110>(),
            TokenType::Elseif => parser.reduce::<110>(),
            TokenType::End => parser.reduce::<110>(),
            TokenType::For => parser.reduce::<110>(),
            TokenType::Function => parser.reduce::<110>(),
            TokenType::Goto => parser.reduce::<110>(),
            TokenType::If => parser.reduce::<110>(),
            TokenType::Local => parser.reduce::<110>(),
            TokenType::Repeat => parser.reduce::<110>(),
            TokenType::Return => parser.reduce::<110>(),
            TokenType::While => parser.reduce::<110>(),
            TokenType::LParen => parser.reduce::<110>(),
            TokenType::DoubleColon => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2739> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<50>(),
            TokenType::String(_) => parser.reduce::<50>(),
            TokenType::And => parser.reduce::<50>(),
            TokenType::Break => parser.reduce::<50>(),
            TokenType::Do => parser.reduce::<50>(),
            TokenType::Else => parser.reduce::<50>(),
            TokenType::Elseif => parser.reduce::<50>(),
            TokenType::End => parser.reduce::<50>(),
            TokenType::For => parser.reduce::<50>(),
            TokenType::Function => parser.reduce::<50>(),
            TokenType::Goto => parser.reduce::<50>(),
            TokenType::If => parser.reduce::<50>(),
            TokenType::Local => parser.reduce::<50>(),
            TokenType::Or => parser.reduce::<50>(),
            TokenType::Repeat => parser.reduce::<50>(),
            TokenType::Return => parser.reduce::<50>(),
            TokenType::While => parser.reduce::<50>(),
            TokenType::Add => parser.reduce::<50>(),
            TokenType::Sub => parser.reduce::<50>(),
            TokenType::Mul => parser.reduce::<50>(),
            TokenType::Div => parser.reduce::<50>(),
            TokenType::Idiv => parser.reduce::<50>(),
            TokenType::Mod => parser.reduce::<50>(),
            TokenType::Pow => parser.reduce::<50>(),
            TokenType::BitAnd => parser.reduce::<50>(),
            TokenType::BitXor => parser.reduce::<50>(),
            TokenType::BitOr => parser.reduce::<50>(),
            TokenType::ShiftL => parser.reduce::<50>(),
            TokenType::ShiftR => parser.reduce::<50>(),
            TokenType::Eq => parser.reduce::<50>(),
            TokenType::Neq => parser.reduce::<50>(),
            TokenType::Leq => parser.reduce::<50>(),
            TokenType::Geq => parser.reduce::<50>(),
            TokenType::Less => parser.reduce::<50>(),
            TokenType::Greater => parser.reduce::<50>(),
            TokenType::LParen => parser.reduce::<50>(),
            TokenType::LSquare => parser.reduce::<50>(),
            TokenType::LCurly => parser.reduce::<50>(),
            TokenType::DoubleColon => parser.reduce::<50>(),
            TokenType::SemiColon => parser.reduce::<50>(),
            TokenType::Colon => parser.reduce::<50>(),
            TokenType::Dot => parser.reduce::<50>(),
            TokenType::Concat => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2740> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<110>(),
            TokenType::And => parser.reduce::<110>(),
            TokenType::Break => parser.reduce::<110>(),
            TokenType::Do => parser.reduce::<110>(),
            TokenType::For => parser.reduce::<110>(),
            TokenType::Function => parser.reduce::<110>(),
            TokenType::Goto => parser.reduce::<110>(),
            TokenType::If => parser.reduce::<110>(),
            TokenType::Local => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Repeat => parser.reduce::<110>(),
            TokenType::Return => parser.reduce::<110>(),
            TokenType::Until => parser.reduce::<110>(),
            TokenType::While => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::LParen => parser.reduce::<110>(),
            TokenType::DoubleColon => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2741> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<110>(),
            TokenType::And => parser.reduce::<110>(),
            TokenType::Break => parser.reduce::<110>(),
            TokenType::Do => parser.reduce::<110>(),
            TokenType::End => parser.reduce::<110>(),
            TokenType::For => parser.reduce::<110>(),
            TokenType::Function => parser.reduce::<110>(),
            TokenType::Goto => parser.reduce::<110>(),
            TokenType::If => parser.reduce::<110>(),
            TokenType::Local => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Repeat => parser.reduce::<110>(),
            TokenType::Return => parser.reduce::<110>(),
            TokenType::While => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::LParen => parser.reduce::<110>(),
            TokenType::DoubleColon => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2742> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<104>(),
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::And => parser.reduce::<104>(),
            TokenType::Break => parser.reduce::<104>(),
            TokenType::Do => parser.reduce::<104>(),
            TokenType::Else => parser.reduce::<104>(),
            TokenType::Elseif => parser.reduce::<104>(),
            TokenType::End => parser.reduce::<104>(),
            TokenType::For => parser.reduce::<104>(),
            TokenType::Function => parser.reduce::<104>(),
            TokenType::Goto => parser.reduce::<104>(),
            TokenType::If => parser.reduce::<104>(),
            TokenType::Local => parser.reduce::<104>(),
            TokenType::Or => parser.reduce::<104>(),
            TokenType::Repeat => parser.reduce::<104>(),
            TokenType::Return => parser.reduce::<104>(),
            TokenType::While => parser.reduce::<104>(),
            TokenType::Add => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Mul => parser.reduce::<104>(),
            TokenType::Div => parser.reduce::<104>(),
            TokenType::Idiv => parser.reduce::<104>(),
            TokenType::Mod => parser.reduce::<104>(),
            TokenType::Pow => parser.reduce::<104>(),
            TokenType::BitAnd => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::BitOr => parser.reduce::<104>(),
            TokenType::ShiftL => parser.reduce::<104>(),
            TokenType::ShiftR => parser.reduce::<104>(),
            TokenType::Eq => parser.reduce::<104>(),
            TokenType::Neq => parser.reduce::<104>(),
            TokenType::Leq => parser.reduce::<104>(),
            TokenType::Geq => parser.reduce::<104>(),
            TokenType::Less => parser.reduce::<104>(),
            TokenType::Greater => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LSquare => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::DoubleColon => parser.reduce::<104>(),
            TokenType::SemiColon => parser.reduce::<104>(),
            TokenType::Colon => parser.reduce::<104>(),
            TokenType::Dot => parser.reduce::<104>(),
            TokenType::Concat => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2743> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(2300),
            TokenType::LParen => parser.shift(2304),
            TokenType::LCurly => parser.shift(2318),
            TokenType::Args => parser.goto(2757),
            TokenType::Tableconstructor => parser.goto(2315),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2744> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2768),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2745> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::And => parser.reduce::<117>(),
            TokenType::Break => parser.reduce::<117>(),
            TokenType::Do => parser.reduce::<117>(),
            TokenType::Else => parser.reduce::<117>(),
            TokenType::Elseif => parser.reduce::<117>(),
            TokenType::End => parser.reduce::<117>(),
            TokenType::For => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Goto => parser.reduce::<117>(),
            TokenType::If => parser.reduce::<117>(),
            TokenType::Local => parser.reduce::<117>(),
            TokenType::Or => parser.reduce::<117>(),
            TokenType::Repeat => parser.reduce::<117>(),
            TokenType::Return => parser.reduce::<117>(),
            TokenType::While => parser.reduce::<117>(),
            TokenType::Add => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Mul => parser.reduce::<117>(),
            TokenType::Div => parser.reduce::<117>(),
            TokenType::Idiv => parser.reduce::<117>(),
            TokenType::Mod => parser.reduce::<117>(),
            TokenType::Pow => parser.reduce::<117>(),
            TokenType::BitAnd => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::BitOr => parser.reduce::<117>(),
            TokenType::ShiftL => parser.reduce::<117>(),
            TokenType::ShiftR => parser.reduce::<117>(),
            TokenType::Eq => parser.reduce::<117>(),
            TokenType::Neq => parser.reduce::<117>(),
            TokenType::Leq => parser.reduce::<117>(),
            TokenType::Geq => parser.reduce::<117>(),
            TokenType::Less => parser.reduce::<117>(),
            TokenType::Greater => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LSquare => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::DoubleColon => parser.reduce::<117>(),
            TokenType::SemiColon => parser.reduce::<117>(),
            TokenType::Colon => parser.reduce::<117>(),
            TokenType::Dot => parser.reduce::<117>(),
            TokenType::Concat => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2746> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(314),
            TokenType::Integer(_) => parser.shift(315),
            TokenType::Float(_) => parser.shift(316),
            TokenType::False => parser.shift(317),
            TokenType::Function => parser.shift(420),
            TokenType::Nil => parser.shift(318),
            TokenType::Not => parser.shift(321),
            TokenType::True => parser.shift(331),
            TokenType::Sub => parser.shift(332),
            TokenType::Len => parser.shift(361),
            TokenType::BitXor => parser.shift(374),
            TokenType::LParen => parser.shift(201),
            TokenType::LCurly => parser.shift(422),
            TokenType::Dots => parser.shift(392),
            TokenType::Var => parser.goto(301),
            TokenType::Exp => parser.goto(2767),
            TokenType::Functioncall => parser.goto(310),
            TokenType::Functiondef => parser.goto(397),
            TokenType::Tableconstructor => parser.goto(398),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2747> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2760),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2748> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2759),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2749> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2758),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2750> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2763),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2751> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2765),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2752> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(2764),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2753> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<100>(),
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::And => parser.reduce::<100>(),
            TokenType::Break => parser.reduce::<100>(),
            TokenType::Do => parser.reduce::<100>(),
            TokenType::Else => parser.reduce::<100>(),
            TokenType::Elseif => parser.reduce::<100>(),
            TokenType::End => parser.reduce::<100>(),
            TokenType::For => parser.reduce::<100>(),
            TokenType::Function => parser.reduce::<100>(),
            TokenType::Goto => parser.reduce::<100>(),
            TokenType::If => parser.reduce::<100>(),
            TokenType::Local => parser.reduce::<100>(),
            TokenType::Or => parser.reduce::<100>(),
            TokenType::Repeat => parser.reduce::<100>(),
            TokenType::Return => parser.reduce::<100>(),
            TokenType::While => parser.reduce::<100>(),
            TokenType::Add => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Mul => parser.reduce::<100>(),
            TokenType::Div => parser.reduce::<100>(),
            TokenType::Idiv => parser.reduce::<100>(),
            TokenType::Mod => parser.reduce::<100>(),
            TokenType::Pow => parser.reduce::<100>(),
            TokenType::BitAnd => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::BitOr => parser.reduce::<100>(),
            TokenType::ShiftL => parser.reduce::<100>(),
            TokenType::ShiftR => parser.reduce::<100>(),
            TokenType::Eq => parser.reduce::<100>(),
            TokenType::Neq => parser.reduce::<100>(),
            TokenType::Leq => parser.reduce::<100>(),
            TokenType::Geq => parser.reduce::<100>(),
            TokenType::Less => parser.reduce::<100>(),
            TokenType::Greater => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LSquare => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::DoubleColon => parser.reduce::<100>(),
            TokenType::SemiColon => parser.reduce::<100>(),
            TokenType::Colon => parser.reduce::<100>(),
            TokenType::Dot => parser.reduce::<100>(),
            TokenType::Concat => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2754> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2761),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2755> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2762),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2756> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Else => parser.reduce::<103>(),
            TokenType::Elseif => parser.reduce::<103>(),
            TokenType::End => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Comma => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2757> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<103>(),
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Break => parser.reduce::<103>(),
            TokenType::Do => parser.reduce::<103>(),
            TokenType::Else => parser.reduce::<103>(),
            TokenType::Elseif => parser.reduce::<103>(),
            TokenType::End => parser.reduce::<103>(),
            TokenType::For => parser.reduce::<103>(),
            TokenType::Function => parser.reduce::<103>(),
            TokenType::Goto => parser.reduce::<103>(),
            TokenType::If => parser.reduce::<103>(),
            TokenType::Local => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Repeat => parser.reduce::<103>(),
            TokenType::Return => parser.reduce::<103>(),
            TokenType::While => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::DoubleColon => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Comma => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2758> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Else => parser.reduce::<51>(),
            TokenType::Elseif => parser.reduce::<51>(),
            TokenType::End => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::SemiColon => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Comma => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2759> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<20>(),
            TokenType::Break => parser.reduce::<20>(),
            TokenType::Do => parser.reduce::<20>(),
            TokenType::For => parser.reduce::<20>(),
            TokenType::Function => parser.reduce::<20>(),
            TokenType::Goto => parser.reduce::<20>(),
            TokenType::If => parser.reduce::<20>(),
            TokenType::Local => parser.reduce::<20>(),
            TokenType::Repeat => parser.reduce::<20>(),
            TokenType::Return => parser.reduce::<20>(),
            TokenType::Until => parser.reduce::<20>(),
            TokenType::While => parser.reduce::<20>(),
            TokenType::LParen => parser.reduce::<20>(),
            TokenType::DoubleColon => parser.reduce::<20>(),
            TokenType::SemiColon => parser.reduce::<20>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2760> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<20>(),
            TokenType::Break => parser.reduce::<20>(),
            TokenType::Do => parser.reduce::<20>(),
            TokenType::End => parser.reduce::<20>(),
            TokenType::For => parser.reduce::<20>(),
            TokenType::Function => parser.reduce::<20>(),
            TokenType::Goto => parser.reduce::<20>(),
            TokenType::If => parser.reduce::<20>(),
            TokenType::Local => parser.reduce::<20>(),
            TokenType::Repeat => parser.reduce::<20>(),
            TokenType::Return => parser.reduce::<20>(),
            TokenType::While => parser.reduce::<20>(),
            TokenType::LParen => parser.reduce::<20>(),
            TokenType::DoubleColon => parser.reduce::<20>(),
            TokenType::SemiColon => parser.reduce::<20>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2761> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<110>(),
            TokenType::Else => parser.reduce::<110>(),
            TokenType::Elseif => parser.reduce::<110>(),
            TokenType::End => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            TokenType::Comma => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2762> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<110>(),
            TokenType::And => parser.reduce::<110>(),
            TokenType::Break => parser.reduce::<110>(),
            TokenType::Do => parser.reduce::<110>(),
            TokenType::Else => parser.reduce::<110>(),
            TokenType::Elseif => parser.reduce::<110>(),
            TokenType::End => parser.reduce::<110>(),
            TokenType::For => parser.reduce::<110>(),
            TokenType::Function => parser.reduce::<110>(),
            TokenType::Goto => parser.reduce::<110>(),
            TokenType::If => parser.reduce::<110>(),
            TokenType::Local => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Repeat => parser.reduce::<110>(),
            TokenType::Return => parser.reduce::<110>(),
            TokenType::While => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::LParen => parser.reduce::<110>(),
            TokenType::DoubleColon => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            TokenType::Comma => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2763> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<51>(),
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Break => parser.reduce::<51>(),
            TokenType::Do => parser.reduce::<51>(),
            TokenType::Else => parser.reduce::<51>(),
            TokenType::Elseif => parser.reduce::<51>(),
            TokenType::End => parser.reduce::<51>(),
            TokenType::For => parser.reduce::<51>(),
            TokenType::Function => parser.reduce::<51>(),
            TokenType::Goto => parser.reduce::<51>(),
            TokenType::If => parser.reduce::<51>(),
            TokenType::Local => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Repeat => parser.reduce::<51>(),
            TokenType::Return => parser.reduce::<51>(),
            TokenType::While => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::DoubleColon => parser.reduce::<51>(),
            TokenType::SemiColon => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Comma => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2764> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(2538),
            TokenType::LParen => parser.shift(2541),
            TokenType::LCurly => parser.shift(2552),
            TokenType::Args => parser.goto(2769),
            TokenType::Tableconstructor => parser.goto(2551),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2765> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::String(_) => parser.reduce::<54>(),
            TokenType::And => parser.reduce::<54>(),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::Else => parser.reduce::<54>(),
            TokenType::Elseif => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.reduce::<54>(),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.reduce::<54>(),
            TokenType::Sub => parser.reduce::<54>(),
            TokenType::Mul => parser.reduce::<54>(),
            TokenType::Div => parser.reduce::<54>(),
            TokenType::Idiv => parser.reduce::<54>(),
            TokenType::Mod => parser.reduce::<54>(),
            TokenType::Pow => parser.reduce::<54>(),
            TokenType::BitAnd => parser.reduce::<54>(),
            TokenType::BitXor => parser.reduce::<54>(),
            TokenType::BitOr => parser.reduce::<54>(),
            TokenType::ShiftL => parser.reduce::<54>(),
            TokenType::ShiftR => parser.reduce::<54>(),
            TokenType::Eq => parser.reduce::<54>(),
            TokenType::Neq => parser.reduce::<54>(),
            TokenType::Leq => parser.reduce::<54>(),
            TokenType::Geq => parser.reduce::<54>(),
            TokenType::Less => parser.reduce::<54>(),
            TokenType::Greater => parser.reduce::<54>(),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::LSquare => parser.reduce::<54>(),
            TokenType::LCurly => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Colon => parser.reduce::<54>(),
            TokenType::Dot => parser.reduce::<54>(),
            TokenType::Concat => parser.reduce::<54>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2766> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(46),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(57),
            TokenType::Function => parser.shift(59),
            TokenType::Goto => parser.shift(61),
            TokenType::If => parser.shift(63),
            TokenType::Local => parser.shift(74),
            TokenType::Repeat => parser.shift(75),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(79),
            TokenType::LParen => parser.shift(95),
            TokenType::DoubleColon => parser.shift(93),
            TokenType::SemiColon => parser.shift(89),
            TokenType::Block => parser.goto(2772),
            TokenType::BlockStat => parser.goto(23),
            TokenType::Stat => parser.goto(39),
            TokenType::Label => parser.goto(90),
            TokenType::Varlist => parser.goto(91),
            TokenType::Var => parser.goto(94),
            TokenType::Functioncall => parser.goto(92),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2767> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(583),
            TokenType::Or => parser.shift(638),
            TokenType::Add => parser.shift(691),
            TokenType::Sub => parser.shift(733),
            TokenType::Mul => parser.shift(758),
            TokenType::Div => parser.shift(783),
            TokenType::Idiv => parser.shift(789),
            TokenType::Mod => parser.shift(796),
            TokenType::Pow => parser.shift(809),
            TokenType::BitAnd => parser.shift(864),
            TokenType::BitXor => parser.shift(894),
            TokenType::BitOr => parser.shift(904),
            TokenType::ShiftL => parser.shift(916),
            TokenType::ShiftR => parser.shift(928),
            TokenType::Eq => parser.shift(945),
            TokenType::Neq => parser.shift(949),
            TokenType::Leq => parser.shift(956),
            TokenType::Geq => parser.shift(966),
            TokenType::Less => parser.shift(971),
            TokenType::Greater => parser.shift(975),
            TokenType::RSquare => parser.shift(2770),
            TokenType::Concat => parser.shift(986),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2768> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2771),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2769> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<103>(),
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::And => parser.reduce::<103>(),
            TokenType::Break => parser.reduce::<103>(),
            TokenType::Do => parser.reduce::<103>(),
            TokenType::Else => parser.reduce::<103>(),
            TokenType::Elseif => parser.reduce::<103>(),
            TokenType::End => parser.reduce::<103>(),
            TokenType::For => parser.reduce::<103>(),
            TokenType::Function => parser.reduce::<103>(),
            TokenType::Goto => parser.reduce::<103>(),
            TokenType::If => parser.reduce::<103>(),
            TokenType::Local => parser.reduce::<103>(),
            TokenType::Or => parser.reduce::<103>(),
            TokenType::Repeat => parser.reduce::<103>(),
            TokenType::Return => parser.reduce::<103>(),
            TokenType::While => parser.reduce::<103>(),
            TokenType::Add => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Mul => parser.reduce::<103>(),
            TokenType::Div => parser.reduce::<103>(),
            TokenType::Idiv => parser.reduce::<103>(),
            TokenType::Mod => parser.reduce::<103>(),
            TokenType::Pow => parser.reduce::<103>(),
            TokenType::BitAnd => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::BitOr => parser.reduce::<103>(),
            TokenType::ShiftL => parser.reduce::<103>(),
            TokenType::ShiftR => parser.reduce::<103>(),
            TokenType::Eq => parser.reduce::<103>(),
            TokenType::Neq => parser.reduce::<103>(),
            TokenType::Leq => parser.reduce::<103>(),
            TokenType::Geq => parser.reduce::<103>(),
            TokenType::Less => parser.reduce::<103>(),
            TokenType::Greater => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LSquare => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::DoubleColon => parser.reduce::<103>(),
            TokenType::SemiColon => parser.reduce::<103>(),
            TokenType::Colon => parser.reduce::<103>(),
            TokenType::Dot => parser.reduce::<103>(),
            TokenType::Concat => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2770> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<51>(),
            TokenType::String(_) => parser.reduce::<51>(),
            TokenType::And => parser.reduce::<51>(),
            TokenType::Break => parser.reduce::<51>(),
            TokenType::Do => parser.reduce::<51>(),
            TokenType::Else => parser.reduce::<51>(),
            TokenType::Elseif => parser.reduce::<51>(),
            TokenType::End => parser.reduce::<51>(),
            TokenType::For => parser.reduce::<51>(),
            TokenType::Function => parser.reduce::<51>(),
            TokenType::Goto => parser.reduce::<51>(),
            TokenType::If => parser.reduce::<51>(),
            TokenType::Local => parser.reduce::<51>(),
            TokenType::Or => parser.reduce::<51>(),
            TokenType::Repeat => parser.reduce::<51>(),
            TokenType::Return => parser.reduce::<51>(),
            TokenType::While => parser.reduce::<51>(),
            TokenType::Add => parser.reduce::<51>(),
            TokenType::Sub => parser.reduce::<51>(),
            TokenType::Mul => parser.reduce::<51>(),
            TokenType::Div => parser.reduce::<51>(),
            TokenType::Idiv => parser.reduce::<51>(),
            TokenType::Mod => parser.reduce::<51>(),
            TokenType::Pow => parser.reduce::<51>(),
            TokenType::BitAnd => parser.reduce::<51>(),
            TokenType::BitXor => parser.reduce::<51>(),
            TokenType::BitOr => parser.reduce::<51>(),
            TokenType::ShiftL => parser.reduce::<51>(),
            TokenType::ShiftR => parser.reduce::<51>(),
            TokenType::Eq => parser.reduce::<51>(),
            TokenType::Neq => parser.reduce::<51>(),
            TokenType::Leq => parser.reduce::<51>(),
            TokenType::Geq => parser.reduce::<51>(),
            TokenType::Less => parser.reduce::<51>(),
            TokenType::Greater => parser.reduce::<51>(),
            TokenType::LParen => parser.reduce::<51>(),
            TokenType::LSquare => parser.reduce::<51>(),
            TokenType::LCurly => parser.reduce::<51>(),
            TokenType::DoubleColon => parser.reduce::<51>(),
            TokenType::SemiColon => parser.reduce::<51>(),
            TokenType::Colon => parser.reduce::<51>(),
            TokenType::Dot => parser.reduce::<51>(),
            TokenType::Concat => parser.reduce::<51>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2771> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<110>(),
            TokenType::And => parser.reduce::<110>(),
            TokenType::Break => parser.reduce::<110>(),
            TokenType::Do => parser.reduce::<110>(),
            TokenType::Else => parser.reduce::<110>(),
            TokenType::Elseif => parser.reduce::<110>(),
            TokenType::End => parser.reduce::<110>(),
            TokenType::For => parser.reduce::<110>(),
            TokenType::Function => parser.reduce::<110>(),
            TokenType::Goto => parser.reduce::<110>(),
            TokenType::If => parser.reduce::<110>(),
            TokenType::Local => parser.reduce::<110>(),
            TokenType::Or => parser.reduce::<110>(),
            TokenType::Repeat => parser.reduce::<110>(),
            TokenType::Return => parser.reduce::<110>(),
            TokenType::While => parser.reduce::<110>(),
            TokenType::Add => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Mul => parser.reduce::<110>(),
            TokenType::Div => parser.reduce::<110>(),
            TokenType::Idiv => parser.reduce::<110>(),
            TokenType::Mod => parser.reduce::<110>(),
            TokenType::Pow => parser.reduce::<110>(),
            TokenType::BitAnd => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::BitOr => parser.reduce::<110>(),
            TokenType::ShiftL => parser.reduce::<110>(),
            TokenType::ShiftR => parser.reduce::<110>(),
            TokenType::Eq => parser.reduce::<110>(),
            TokenType::Neq => parser.reduce::<110>(),
            TokenType::Leq => parser.reduce::<110>(),
            TokenType::Geq => parser.reduce::<110>(),
            TokenType::Less => parser.reduce::<110>(),
            TokenType::Greater => parser.reduce::<110>(),
            TokenType::LParen => parser.reduce::<110>(),
            TokenType::DoubleColon => parser.reduce::<110>(),
            TokenType::SemiColon => parser.reduce::<110>(),
            TokenType::Concat => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2772> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(2773),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2773> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<20>(),
            TokenType::Break => parser.reduce::<20>(),
            TokenType::Do => parser.reduce::<20>(),
            TokenType::Else => parser.reduce::<20>(),
            TokenType::Elseif => parser.reduce::<20>(),
            TokenType::End => parser.reduce::<20>(),
            TokenType::For => parser.reduce::<20>(),
            TokenType::Function => parser.reduce::<20>(),
            TokenType::Goto => parser.reduce::<20>(),
            TokenType::If => parser.reduce::<20>(),
            TokenType::Local => parser.reduce::<20>(),
            TokenType::Repeat => parser.reduce::<20>(),
            TokenType::Return => parser.reduce::<20>(),
            TokenType::While => parser.reduce::<20>(),
            TokenType::LParen => parser.reduce::<20>(),
            TokenType::DoubleColon => parser.reduce::<20>(),
            TokenType::SemiColon => parser.reduce::<20>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}
