use crate::parser::Token;

use super::{Error, Parser, TokenType};

pub struct State<const N: usize>;

impl<const N: usize> State<N> {
    fn get_previous_binop<'a>(parser: &Parser<'a>) -> TokenType<'a> {
        let ord = &parser.stack[parser.stack.len() - 2];

        let Token {
            tokens: _,
            token_type: token,
        } = ord.tokens[0];

        token
    }

    fn unimplemented_lookahead() -> Result<(), Error> {
        unimplemented!("State {N} has unimplemented lookahead.");
    }
}
pub trait StateProcessor {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error>;
}

impl StateProcessor for State<0> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(4),
            TokenType::Do => parser.shift(5),
            TokenType::For => parser.shift(6),
            TokenType::Function => parser.shift(7),
            TokenType::Goto => parser.shift(8),
            TokenType::If => parser.shift(9),
            TokenType::Local => parser.shift(10),
            TokenType::Repeat => parser.shift(11),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(12),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(17),
            TokenType::SemiColon => parser.shift(13),
            TokenType::Eof => parser.reduce::<2>(),
            TokenType::Block => parser.goto(1),
            TokenType::BlockStat => parser.goto(2),
            TokenType::Stat => parser.goto(3),
            TokenType::Label => parser.goto(14),
            TokenType::Varlist => parser.goto(15),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(20),
            TokenType::Functioncall => parser.goto(16),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<0>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<2> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Return => parser.shift(49),
            TokenType::Eof => parser.reduce::<4>(),
            TokenType::BlockRetstat => parser.goto(22),
            TokenType::Retstat => parser.goto(23),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<3> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(4),
            TokenType::Do => parser.shift(5),
            TokenType::For => parser.shift(6),
            TokenType::Function => parser.shift(7),
            TokenType::Goto => parser.shift(8),
            TokenType::If => parser.shift(9),
            TokenType::Local => parser.shift(10),
            TokenType::Repeat => parser.shift(11),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(12),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(17),
            TokenType::SemiColon => parser.shift(13),
            TokenType::Eof => parser.reduce::<2>(),
            TokenType::BlockStat => parser.goto(44),
            TokenType::Stat => parser.goto(3),
            TokenType::Label => parser.goto(14),
            TokenType::Varlist => parser.goto(15),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(20),
            TokenType::Functioncall => parser.goto(16),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<4> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<10>(),
            TokenType::Break => parser.reduce::<10>(),
            TokenType::Do => parser.reduce::<10>(),
            TokenType::For => parser.reduce::<10>(),
            TokenType::Function => parser.reduce::<10>(),
            TokenType::Goto => parser.reduce::<10>(),
            TokenType::If => parser.reduce::<10>(),
            TokenType::Local => parser.reduce::<10>(),
            TokenType::Repeat => parser.reduce::<10>(),
            TokenType::Return => parser.reduce::<10>(),
            TokenType::While => parser.reduce::<10>(),
            TokenType::LParen => parser.reduce::<10>(),
            TokenType::DoubleColon => parser.reduce::<10>(),
            TokenType::SemiColon => parser.reduce::<10>(),
            TokenType::Eof => parser.reduce::<10>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<5> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(63),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<6> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(30),
            TokenType::Namelist => parser.goto(33),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<7> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(36),
            TokenType::Funcname => parser.goto(28),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<8> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(29),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<9> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(59),
            TokenType::String(_) => parser.shift(76),
            TokenType::Integer(_) => parser.shift(77),
            TokenType::Float(_) => parser.shift(78),
            TokenType::False => parser.shift(79),
            TokenType::Function => parser.shift(132),
            TokenType::Nil => parser.shift(80),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(81),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(122),
            TokenType::LCurly => parser.shift(134),
            TokenType::Dots => parser.shift(82),
            TokenType::Var => parser.goto(126),
            TokenType::Exp => parser.goto(39),
            TokenType::Prefixexp => parser.goto(60),
            TokenType::Functioncall => parser.goto(127),
            TokenType::Functiondef => parser.goto(94),
            TokenType::Tableconstructor => parser.goto(95),
            TokenType::Unop => parser.goto(98),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<10> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(34),
            TokenType::Function => parser.shift(24),
            TokenType::Attnamelist => parser.goto(25),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<11> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::For => parser.shift(66),
            TokenType::Function => parser.shift(68),
            TokenType::Goto => parser.shift(69),
            TokenType::If => parser.shift(71),
            TokenType::Local => parser.shift(101),
            TokenType::Repeat => parser.shift(103),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(104),
            TokenType::BlockStat => parser.goto(26),
            TokenType::Stat => parser.goto(42),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<12> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(61),
            TokenType::String(_) => parser.shift(83),
            TokenType::Integer(_) => parser.shift(84),
            TokenType::Float(_) => parser.shift(85),
            TokenType::False => parser.shift(86),
            TokenType::Function => parser.shift(133),
            TokenType::Nil => parser.shift(88),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(89),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(123),
            TokenType::LCurly => parser.shift(135),
            TokenType::Dots => parser.shift(90),
            TokenType::Var => parser.goto(128),
            TokenType::Exp => parser.goto(41),
            TokenType::Prefixexp => parser.goto(62),
            TokenType::Functioncall => parser.goto(129),
            TokenType::Functiondef => parser.goto(96),
            TokenType::Tableconstructor => parser.goto(97),
            TokenType::Unop => parser.goto(99),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<13> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<6>(),
            TokenType::Break => parser.reduce::<6>(),
            TokenType::Do => parser.reduce::<6>(),
            TokenType::For => parser.reduce::<6>(),
            TokenType::Function => parser.reduce::<6>(),
            TokenType::Goto => parser.reduce::<6>(),
            TokenType::If => parser.reduce::<6>(),
            TokenType::Local => parser.reduce::<6>(),
            TokenType::Repeat => parser.reduce::<6>(),
            TokenType::Return => parser.reduce::<6>(),
            TokenType::While => parser.reduce::<6>(),
            TokenType::LParen => parser.reduce::<6>(),
            TokenType::DoubleColon => parser.reduce::<6>(),
            TokenType::SemiColon => parser.reduce::<6>(),
            TokenType::Eof => parser.reduce::<6>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<14> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<9>(),
            TokenType::Break => parser.reduce::<9>(),
            TokenType::Do => parser.reduce::<9>(),
            TokenType::For => parser.reduce::<9>(),
            TokenType::Function => parser.reduce::<9>(),
            TokenType::Goto => parser.reduce::<9>(),
            TokenType::If => parser.reduce::<9>(),
            TokenType::Local => parser.reduce::<9>(),
            TokenType::Repeat => parser.reduce::<9>(),
            TokenType::Return => parser.reduce::<9>(),
            TokenType::While => parser.reduce::<9>(),
            TokenType::LParen => parser.reduce::<9>(),
            TokenType::DoubleColon => parser.reduce::<9>(),
            TokenType::SemiColon => parser.reduce::<9>(),
            TokenType::Eof => parser.reduce::<9>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<15> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(50),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<16> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<8>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<8>(),
            TokenType::Do => parser.reduce::<8>(),
            TokenType::For => parser.reduce::<8>(),
            TokenType::Function => parser.reduce::<8>(),
            TokenType::Goto => parser.reduce::<8>(),
            TokenType::If => parser.reduce::<8>(),
            TokenType::Local => parser.reduce::<8>(),
            TokenType::Repeat => parser.reduce::<8>(),
            TokenType::Return => parser.reduce::<8>(),
            TokenType::While => parser.reduce::<8>(),
            // Reduce(8)-Reduce(69)
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<8>(),
            TokenType::SemiColon => parser.reduce::<8>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Eof => parser.reduce::<8>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<17> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(31),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<18> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::Assign => parser.reduce::<45>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Comma => parser.shift(35),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::VarlistCont => parser.goto(32),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<19> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::Assign => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Comma => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<20> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(75),
            TokenType::LParen => parser.shift(87),
            TokenType::LSquare => parser.shift(47),
            TokenType::LCurly => parser.shift(108),
            TokenType::Colon => parser.shift(73),
            TokenType::Dot => parser.shift(72),
            TokenType::Args => parser.goto(74),
            TokenType::Tableconstructor => parser.goto(107),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<21> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(58),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<22> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<1>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<23> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<5>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<24> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(144),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<25> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<26>(),
            TokenType::Break => parser.reduce::<26>(),
            TokenType::Do => parser.reduce::<26>(),
            TokenType::For => parser.reduce::<26>(),
            TokenType::Function => parser.reduce::<26>(),
            TokenType::Goto => parser.reduce::<26>(),
            TokenType::If => parser.reduce::<26>(),
            TokenType::Local => parser.reduce::<26>(),
            TokenType::Repeat => parser.reduce::<26>(),
            TokenType::Return => parser.reduce::<26>(),
            TokenType::While => parser.reduce::<26>(),
            TokenType::Assign => parser.shift(184),
            TokenType::LParen => parser.reduce::<26>(),
            TokenType::DoubleColon => parser.reduce::<26>(),
            TokenType::SemiColon => parser.reduce::<26>(),
            TokenType::Eof => parser.reduce::<26>(),
            TokenType::StatAttexplist => parser.goto(143),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<26> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Return => parser.shift(186),
            TokenType::Until => parser.reduce::<4>(),
            TokenType::BlockRetstat => parser.goto(149),
            TokenType::Retstat => parser.goto(150),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<27> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<4>(),
            TokenType::Return => parser.shift(185),
            TokenType::BlockRetstat => parser.goto(146),
            TokenType::Retstat => parser.goto(147),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<28> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(148),
            TokenType::Funcbody => parser.goto(145),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<29> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<11>(),
            TokenType::Break => parser.reduce::<11>(),
            TokenType::Do => parser.reduce::<11>(),
            TokenType::For => parser.reduce::<11>(),
            TokenType::Function => parser.reduce::<11>(),
            TokenType::Goto => parser.reduce::<11>(),
            TokenType::If => parser.reduce::<11>(),
            TokenType::Local => parser.reduce::<11>(),
            TokenType::Repeat => parser.reduce::<11>(),
            TokenType::Return => parser.reduce::<11>(),
            TokenType::While => parser.reduce::<11>(),
            TokenType::LParen => parser.reduce::<11>(),
            TokenType::DoubleColon => parser.reduce::<11>(),
            TokenType::SemiColon => parser.reduce::<11>(),
            TokenType::Eof => parser.reduce::<11>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<30> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<51>(),
            TokenType::Assign => parser.shift(177),
            TokenType::Comma => parser.shift(250),
            TokenType::NamelistCont => parser.goto(249),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<31> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::DoubleColon => parser.shift(140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<32> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.reduce::<44>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<33> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.shift(179),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<34> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Less => parser.shift(165),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            TokenType::Comma => parser.reduce::<31>(),
            TokenType::Eof => parser.reduce::<31>(),
            TokenType::Attrib => parser.goto(153),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<35> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::LParen => parser.shift(21),
            TokenType::Var => parser.goto(152),
            TokenType::Prefixexp => parser.goto(154),
            TokenType::Functioncall => parser.goto(221),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<36> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<40>(),
            TokenType::Colon => parser.reduce::<40>(),
            TokenType::Dot => parser.shift(142),
            TokenType::FuncnameCont => parser.goto(141),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<37> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::RParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<38> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::BlockStat => parser.goto(183),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<39> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Then => parser.shift(173),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<40> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(317),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.shift(319),
            TokenType::RParen => parser.reduce::<64>(),
            TokenType::LSquare => parser.shift(180),
            TokenType::LCurly => parser.shift(353),
            TokenType::Colon => parser.shift(315),
            TokenType::Dot => parser.shift(314),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(316),
            TokenType::Tableconstructor => parser.goto(352),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<41> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Do => parser.shift(151),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(220),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<42> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::For => parser.shift(66),
            TokenType::Function => parser.shift(68),
            TokenType::Goto => parser.shift(69),
            TokenType::If => parser.shift(71),
            TokenType::Local => parser.shift(101),
            TokenType::Repeat => parser.shift(103),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::BlockStat => parser.goto(181),
            TokenType::Stat => parser.goto(42),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<43> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<10>(),
            TokenType::Break => parser.reduce::<10>(),
            TokenType::Do => parser.reduce::<10>(),
            TokenType::End => parser.reduce::<10>(),
            TokenType::For => parser.reduce::<10>(),
            TokenType::Function => parser.reduce::<10>(),
            TokenType::Goto => parser.reduce::<10>(),
            TokenType::If => parser.reduce::<10>(),
            TokenType::Local => parser.reduce::<10>(),
            TokenType::Repeat => parser.reduce::<10>(),
            TokenType::Return => parser.reduce::<10>(),
            TokenType::While => parser.reduce::<10>(),
            TokenType::LParen => parser.reduce::<10>(),
            TokenType::DoubleColon => parser.reduce::<10>(),
            TokenType::SemiColon => parser.reduce::<10>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<44> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Return => parser.reduce::<3>(),
            TokenType::Eof => parser.reduce::<3>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<45> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(222),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<46> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<10>(),
            TokenType::Break => parser.reduce::<10>(),
            TokenType::Do => parser.reduce::<10>(),
            TokenType::For => parser.reduce::<10>(),
            TokenType::Function => parser.reduce::<10>(),
            TokenType::Goto => parser.reduce::<10>(),
            TokenType::If => parser.reduce::<10>(),
            TokenType::Local => parser.reduce::<10>(),
            TokenType::Repeat => parser.reduce::<10>(),
            TokenType::Return => parser.reduce::<10>(),
            TokenType::Until => parser.reduce::<10>(),
            TokenType::While => parser.reduce::<10>(),
            TokenType::LParen => parser.reduce::<10>(),
            TokenType::DoubleColon => parser.reduce::<10>(),
            TokenType::SemiColon => parser.reduce::<10>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<47> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(192),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<48> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(211),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<49> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(158),
            TokenType::String(_) => parser.shift(198),
            TokenType::Integer(_) => parser.shift(200),
            TokenType::Float(_) => parser.shift(202),
            TokenType::False => parser.shift(203),
            TokenType::Function => parser.shift(347),
            TokenType::Nil => parser.shift(204),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(205),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(329),
            TokenType::LCurly => parser.shift(351),
            TokenType::SemiColon => parser.reduce::<34>(),
            TokenType::Dots => parser.shift(206),
            TokenType::Eof => parser.reduce::<34>(),
            TokenType::RetstatExplist => parser.goto(156),
            TokenType::Var => parser.goto(339),
            TokenType::Explist => parser.goto(157),
            TokenType::Exp => parser.goto(197),
            TokenType::Prefixexp => parser.goto(169),
            TokenType::Functioncall => parser.goto(341),
            TokenType::Functiondef => parser.goto(256),
            TokenType::Tableconstructor => parser.goto(257),
            TokenType::Unop => parser.goto(260),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<50> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(279),
            TokenType::Integer(_) => parser.shift(280),
            TokenType::Float(_) => parser.shift(281),
            TokenType::False => parser.shift(291),
            TokenType::Function => parser.shift(370),
            TokenType::Nil => parser.shift(292),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(293),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(364),
            TokenType::LCurly => parser.shift(371),
            TokenType::Dots => parser.shift(296),
            TokenType::Var => parser.goto(368),
            TokenType::Explist => parser.goto(159),
            TokenType::Exp => parser.goto(248),
            TokenType::Prefixexp => parser.goto(175),
            TokenType::Functioncall => parser.goto(369),
            TokenType::Functiondef => parser.goto(330),
            TokenType::Tableconstructor => parser.goto(331),
            TokenType::Unop => parser.goto(333),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<51> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::RParen => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<52> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::RParen => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<53> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::RParen => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<54> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::RParen => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<55> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::RParen => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<56> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::RParen => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<57> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::RParen => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<58> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(282),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<59> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Then => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<60> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(307),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Then => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.shift(312),
            TokenType::LSquare => parser.shift(188),
            TokenType::LCurly => parser.shift(337),
            TokenType::Colon => parser.shift(305),
            TokenType::Dot => parser.shift(304),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(306),
            TokenType::Tableconstructor => parser.goto(336),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<61> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Do => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<62> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(323),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.shift(324),
            TokenType::LSquare => parser.shift(190),
            TokenType::LCurly => parser.shift(343),
            TokenType::Colon => parser.shift(321),
            TokenType::Dot => parser.shift(320),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(322),
            TokenType::Tableconstructor => parser.goto(338),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<63> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(161),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<64> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(162),
            TokenType::Namelist => parser.goto(171),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<65> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(36),
            TokenType::Funcname => parser.goto(163),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<66> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(166),
            TokenType::Namelist => parser.goto(172),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<67> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(167),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<68> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(36),
            TokenType::Funcname => parser.goto(168),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<69> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(170),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<70> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(59),
            TokenType::String(_) => parser.shift(76),
            TokenType::Integer(_) => parser.shift(77),
            TokenType::Float(_) => parser.shift(78),
            TokenType::False => parser.shift(79),
            TokenType::Function => parser.shift(132),
            TokenType::Nil => parser.shift(80),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(81),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(122),
            TokenType::LCurly => parser.shift(134),
            TokenType::Dots => parser.shift(82),
            TokenType::Var => parser.goto(126),
            TokenType::Exp => parser.goto(182),
            TokenType::Prefixexp => parser.goto(60),
            TokenType::Functioncall => parser.goto(127),
            TokenType::Functiondef => parser.goto(94),
            TokenType::Tableconstructor => parser.goto(95),
            TokenType::Unop => parser.goto(98),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<71> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(59),
            TokenType::String(_) => parser.shift(76),
            TokenType::Integer(_) => parser.shift(77),
            TokenType::Float(_) => parser.shift(78),
            TokenType::False => parser.shift(79),
            TokenType::Function => parser.shift(132),
            TokenType::Nil => parser.shift(80),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(81),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(122),
            TokenType::LCurly => parser.shift(134),
            TokenType::Dots => parser.shift(82),
            TokenType::Var => parser.goto(126),
            TokenType::Exp => parser.goto(178),
            TokenType::Prefixexp => parser.goto(60),
            TokenType::Functioncall => parser.goto(127),
            TokenType::Functiondef => parser.goto(94),
            TokenType::Tableconstructor => parser.goto(95),
            TokenType::Unop => parser.goto(98),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<72> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(174),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<73> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(176),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<74> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Eof => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<75> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Eof => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<76> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Then => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<77> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Then => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<78> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Then => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<79> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Then => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<80> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Then => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<81> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Then => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<82> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Then => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<83> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<84> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<85> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<86> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<87> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(344),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<88> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<56>(),
            TokenType::Do => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<89> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<90> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<91> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::RParen => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<92> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::RParen => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<93> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(218),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<94> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Then => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<95> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Then => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<96> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<97> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<98> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(59),
            TokenType::String(_) => parser.shift(76),
            TokenType::Integer(_) => parser.shift(77),
            TokenType::Float(_) => parser.shift(78),
            TokenType::False => parser.shift(79),
            TokenType::Function => parser.shift(132),
            TokenType::Nil => parser.shift(80),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(81),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(122),
            TokenType::LCurly => parser.shift(134),
            TokenType::Dots => parser.shift(82),
            TokenType::Var => parser.goto(126),
            TokenType::Exp => parser.goto(217),
            TokenType::Prefixexp => parser.goto(60),
            TokenType::Functioncall => parser.goto(127),
            TokenType::Functiondef => parser.goto(94),
            TokenType::Tableconstructor => parser.goto(95),
            TokenType::Unop => parser.goto(98),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<99> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(61),
            TokenType::String(_) => parser.shift(83),
            TokenType::Integer(_) => parser.shift(84),
            TokenType::Float(_) => parser.shift(85),
            TokenType::False => parser.shift(86),
            TokenType::Function => parser.shift(133),
            TokenType::Nil => parser.shift(88),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(89),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(123),
            TokenType::LCurly => parser.shift(135),
            TokenType::Dots => parser.shift(90),
            TokenType::Var => parser.goto(128),
            TokenType::Exp => parser.goto(226),
            TokenType::Prefixexp => parser.goto(62),
            TokenType::Functioncall => parser.goto(129),
            TokenType::Functiondef => parser.goto(96),
            TokenType::Tableconstructor => parser.goto(97),
            TokenType::Unop => parser.goto(99),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<100> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(234),
            TokenType::Function => parser.shift(232),
            TokenType::Attnamelist => parser.goto(233),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<101> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(195),
            TokenType::Function => parser.shift(193),
            TokenType::Attnamelist => parser.goto(194),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<102> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::For => parser.shift(66),
            TokenType::Function => parser.shift(68),
            TokenType::Goto => parser.shift(69),
            TokenType::If => parser.shift(71),
            TokenType::Local => parser.shift(101),
            TokenType::Repeat => parser.shift(103),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(318),
            TokenType::BlockStat => parser.goto(26),
            TokenType::Stat => parser.goto(42),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<103> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::For => parser.shift(66),
            TokenType::Function => parser.shift(68),
            TokenType::Goto => parser.shift(69),
            TokenType::If => parser.shift(71),
            TokenType::Local => parser.shift(101),
            TokenType::Repeat => parser.shift(103),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(313),
            TokenType::BlockStat => parser.goto(26),
            TokenType::Stat => parser.goto(42),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<104> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.shift(199),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<105> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(61),
            TokenType::String(_) => parser.shift(83),
            TokenType::Integer(_) => parser.shift(84),
            TokenType::Float(_) => parser.shift(85),
            TokenType::False => parser.shift(86),
            TokenType::Function => parser.shift(133),
            TokenType::Nil => parser.shift(88),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(89),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(123),
            TokenType::LCurly => parser.shift(135),
            TokenType::Dots => parser.shift(90),
            TokenType::Var => parser.goto(128),
            TokenType::Exp => parser.goto(196),
            TokenType::Prefixexp => parser.goto(62),
            TokenType::Functioncall => parser.goto(129),
            TokenType::Functiondef => parser.goto(96),
            TokenType::Tableconstructor => parser.goto(97),
            TokenType::Unop => parser.goto(99),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<106> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(61),
            TokenType::String(_) => parser.shift(83),
            TokenType::Integer(_) => parser.shift(84),
            TokenType::Float(_) => parser.shift(85),
            TokenType::False => parser.shift(86),
            TokenType::Function => parser.shift(133),
            TokenType::Nil => parser.shift(88),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(89),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(123),
            TokenType::LCurly => parser.shift(135),
            TokenType::Dots => parser.shift(90),
            TokenType::Var => parser.goto(128),
            TokenType::Exp => parser.goto(201),
            TokenType::Prefixexp => parser.goto(62),
            TokenType::Functioncall => parser.goto(129),
            TokenType::Functiondef => parser.goto(96),
            TokenType::Tableconstructor => parser.goto(97),
            TokenType::Unop => parser.goto(99),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<107> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Eof => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<108> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(360),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<109> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<6>(),
            TokenType::Break => parser.reduce::<6>(),
            TokenType::Do => parser.reduce::<6>(),
            TokenType::End => parser.reduce::<6>(),
            TokenType::For => parser.reduce::<6>(),
            TokenType::Function => parser.reduce::<6>(),
            TokenType::Goto => parser.reduce::<6>(),
            TokenType::If => parser.reduce::<6>(),
            TokenType::Local => parser.reduce::<6>(),
            TokenType::Repeat => parser.reduce::<6>(),
            TokenType::Return => parser.reduce::<6>(),
            TokenType::While => parser.reduce::<6>(),
            TokenType::LParen => parser.reduce::<6>(),
            TokenType::DoubleColon => parser.reduce::<6>(),
            TokenType::SemiColon => parser.reduce::<6>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<110> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<9>(),
            TokenType::Break => parser.reduce::<9>(),
            TokenType::Do => parser.reduce::<9>(),
            TokenType::End => parser.reduce::<9>(),
            TokenType::For => parser.reduce::<9>(),
            TokenType::Function => parser.reduce::<9>(),
            TokenType::Goto => parser.reduce::<9>(),
            TokenType::If => parser.reduce::<9>(),
            TokenType::Local => parser.reduce::<9>(),
            TokenType::Repeat => parser.reduce::<9>(),
            TokenType::Return => parser.reduce::<9>(),
            TokenType::While => parser.reduce::<9>(),
            TokenType::LParen => parser.reduce::<9>(),
            TokenType::DoubleColon => parser.reduce::<9>(),
            TokenType::SemiColon => parser.reduce::<9>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<111> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(252),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<112> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<8>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<8>(),
            TokenType::Do => parser.reduce::<8>(),
            TokenType::End => parser.reduce::<8>(),
            TokenType::For => parser.reduce::<8>(),
            TokenType::Function => parser.reduce::<8>(),
            TokenType::Goto => parser.reduce::<8>(),
            TokenType::If => parser.reduce::<8>(),
            TokenType::Local => parser.reduce::<8>(),
            TokenType::Repeat => parser.reduce::<8>(),
            TokenType::Return => parser.reduce::<8>(),
            TokenType::While => parser.reduce::<8>(),
            // Reduce(8)-Reduce(69)
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<8>(),
            TokenType::SemiColon => parser.reduce::<8>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<113> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(235),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<114> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(277),
            TokenType::LParen => parser.shift(278),
            TokenType::LSquare => parser.shift(47),
            TokenType::LCurly => parser.shift(335),
            TokenType::Colon => parser.shift(275),
            TokenType::Dot => parser.shift(72),
            TokenType::Args => parser.goto(276),
            TokenType::Tableconstructor => parser.goto(334),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<115> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<6>(),
            TokenType::Break => parser.reduce::<6>(),
            TokenType::Do => parser.reduce::<6>(),
            TokenType::For => parser.reduce::<6>(),
            TokenType::Function => parser.reduce::<6>(),
            TokenType::Goto => parser.reduce::<6>(),
            TokenType::If => parser.reduce::<6>(),
            TokenType::Local => parser.reduce::<6>(),
            TokenType::Repeat => parser.reduce::<6>(),
            TokenType::Return => parser.reduce::<6>(),
            TokenType::Until => parser.reduce::<6>(),
            TokenType::While => parser.reduce::<6>(),
            TokenType::LParen => parser.reduce::<6>(),
            TokenType::DoubleColon => parser.reduce::<6>(),
            TokenType::SemiColon => parser.reduce::<6>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<116> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<9>(),
            TokenType::Break => parser.reduce::<9>(),
            TokenType::Do => parser.reduce::<9>(),
            TokenType::For => parser.reduce::<9>(),
            TokenType::Function => parser.reduce::<9>(),
            TokenType::Goto => parser.reduce::<9>(),
            TokenType::If => parser.reduce::<9>(),
            TokenType::Local => parser.reduce::<9>(),
            TokenType::Repeat => parser.reduce::<9>(),
            TokenType::Return => parser.reduce::<9>(),
            TokenType::Until => parser.reduce::<9>(),
            TokenType::While => parser.reduce::<9>(),
            TokenType::LParen => parser.reduce::<9>(),
            TokenType::DoubleColon => parser.reduce::<9>(),
            TokenType::SemiColon => parser.reduce::<9>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<117> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(253),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<118> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<8>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<8>(),
            TokenType::Do => parser.reduce::<8>(),
            TokenType::For => parser.reduce::<8>(),
            TokenType::Function => parser.reduce::<8>(),
            TokenType::Goto => parser.reduce::<8>(),
            TokenType::If => parser.reduce::<8>(),
            TokenType::Local => parser.reduce::<8>(),
            TokenType::Repeat => parser.reduce::<8>(),
            TokenType::Return => parser.reduce::<8>(),
            TokenType::Until => parser.reduce::<8>(),
            TokenType::While => parser.reduce::<8>(),
            // Reduce(8)-Reduce(69)
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<8>(),
            TokenType::SemiColon => parser.reduce::<8>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<119> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(251),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<120> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(269),
            TokenType::LParen => parser.shift(270),
            TokenType::LSquare => parser.shift(47),
            TokenType::LCurly => parser.shift(326),
            TokenType::Colon => parser.shift(267),
            TokenType::Dot => parser.shift(72),
            TokenType::Args => parser.goto(268),
            TokenType::Tableconstructor => parser.goto(325),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<121> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(273),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<122> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(255),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<123> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(254),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<124> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::RParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<125> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::RParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<126> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Then => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<127> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Then => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<128> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<129> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<130> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(238),
            TokenType::Funcbody => parser.goto(236),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<131> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(366),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<132> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(239),
            TokenType::Funcbody => parser.goto(237),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<133> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(263),
            TokenType::Funcbody => parser.goto(261),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<134> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(367),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<135> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(365),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<136> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<120>(),
            TokenType::String(_) => parser.reduce::<120>(),
            TokenType::Integer(_) => parser.reduce::<120>(),
            TokenType::Float(_) => parser.reduce::<120>(),
            TokenType::False => parser.reduce::<120>(),
            TokenType::Function => parser.reduce::<120>(),
            TokenType::Nil => parser.reduce::<120>(),
            TokenType::Not => parser.reduce::<120>(),
            TokenType::True => parser.reduce::<120>(),
            TokenType::Sub => parser.reduce::<120>(),
            TokenType::Len => parser.reduce::<120>(),
            TokenType::BitXor => parser.reduce::<120>(),
            TokenType::LParen => parser.reduce::<120>(),
            TokenType::LCurly => parser.reduce::<120>(),
            TokenType::Dots => parser.reduce::<120>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<137> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<122>(),
            TokenType::String(_) => parser.reduce::<122>(),
            TokenType::Integer(_) => parser.reduce::<122>(),
            TokenType::Float(_) => parser.reduce::<122>(),
            TokenType::False => parser.reduce::<122>(),
            TokenType::Function => parser.reduce::<122>(),
            TokenType::Nil => parser.reduce::<122>(),
            TokenType::Not => parser.reduce::<122>(),
            TokenType::True => parser.reduce::<122>(),
            TokenType::Sub => parser.reduce::<122>(),
            TokenType::Len => parser.reduce::<122>(),
            TokenType::BitXor => parser.reduce::<122>(),
            TokenType::LParen => parser.reduce::<122>(),
            TokenType::LCurly => parser.reduce::<122>(),
            TokenType::Dots => parser.reduce::<122>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<138> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<121>(),
            TokenType::String(_) => parser.reduce::<121>(),
            TokenType::Integer(_) => parser.reduce::<121>(),
            TokenType::Float(_) => parser.reduce::<121>(),
            TokenType::False => parser.reduce::<121>(),
            TokenType::Function => parser.reduce::<121>(),
            TokenType::Nil => parser.reduce::<121>(),
            TokenType::Not => parser.reduce::<121>(),
            TokenType::True => parser.reduce::<121>(),
            TokenType::Sub => parser.reduce::<121>(),
            TokenType::Len => parser.reduce::<121>(),
            TokenType::BitXor => parser.reduce::<121>(),
            TokenType::LParen => parser.reduce::<121>(),
            TokenType::LCurly => parser.reduce::<121>(),
            TokenType::Dots => parser.reduce::<121>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<139> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<123>(),
            TokenType::String(_) => parser.reduce::<123>(),
            TokenType::Integer(_) => parser.reduce::<123>(),
            TokenType::Float(_) => parser.reduce::<123>(),
            TokenType::False => parser.reduce::<123>(),
            TokenType::Function => parser.reduce::<123>(),
            TokenType::Nil => parser.reduce::<123>(),
            TokenType::Not => parser.reduce::<123>(),
            TokenType::True => parser.reduce::<123>(),
            TokenType::Sub => parser.reduce::<123>(),
            TokenType::Len => parser.reduce::<123>(),
            TokenType::BitXor => parser.reduce::<123>(),
            TokenType::LParen => parser.reduce::<123>(),
            TokenType::LCurly => parser.reduce::<123>(),
            TokenType::Dots => parser.reduce::<123>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<140> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<38>(),
            TokenType::Break => parser.reduce::<38>(),
            TokenType::Do => parser.reduce::<38>(),
            TokenType::For => parser.reduce::<38>(),
            TokenType::Function => parser.reduce::<38>(),
            TokenType::Goto => parser.reduce::<38>(),
            TokenType::If => parser.reduce::<38>(),
            TokenType::Local => parser.reduce::<38>(),
            TokenType::Repeat => parser.reduce::<38>(),
            TokenType::Return => parser.reduce::<38>(),
            TokenType::While => parser.reduce::<38>(),
            TokenType::LParen => parser.reduce::<38>(),
            TokenType::DoubleColon => parser.reduce::<38>(),
            TokenType::SemiColon => parser.reduce::<38>(),
            TokenType::Eof => parser.reduce::<38>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<141> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<42>(),
            TokenType::Colon => parser.shift(373),
            TokenType::FuncnameEnd => parser.goto(372),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<142> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(374),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<143> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<25>(),
            TokenType::Break => parser.reduce::<25>(),
            TokenType::Do => parser.reduce::<25>(),
            TokenType::For => parser.reduce::<25>(),
            TokenType::Function => parser.reduce::<25>(),
            TokenType::Goto => parser.reduce::<25>(),
            TokenType::If => parser.reduce::<25>(),
            TokenType::Local => parser.reduce::<25>(),
            TokenType::Repeat => parser.reduce::<25>(),
            TokenType::Return => parser.reduce::<25>(),
            TokenType::While => parser.reduce::<25>(),
            TokenType::LParen => parser.reduce::<25>(),
            TokenType::DoubleColon => parser.reduce::<25>(),
            TokenType::SemiColon => parser.reduce::<25>(),
            TokenType::Eof => parser.reduce::<25>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<144> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(148),
            TokenType::Funcbody => parser.goto(382),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<145> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<23>(),
            TokenType::Break => parser.reduce::<23>(),
            TokenType::Do => parser.reduce::<23>(),
            TokenType::For => parser.reduce::<23>(),
            TokenType::Function => parser.reduce::<23>(),
            TokenType::Goto => parser.reduce::<23>(),
            TokenType::If => parser.reduce::<23>(),
            TokenType::Local => parser.reduce::<23>(),
            TokenType::Repeat => parser.reduce::<23>(),
            TokenType::Return => parser.reduce::<23>(),
            TokenType::While => parser.reduce::<23>(),
            TokenType::LParen => parser.reduce::<23>(),
            TokenType::DoubleColon => parser.reduce::<23>(),
            TokenType::SemiColon => parser.reduce::<23>(),
            TokenType::Eof => parser.reduce::<23>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<146> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<1>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<147> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<5>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<148> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(375),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<149> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<1>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<150> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<5>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<151> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(611),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<152> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::Assign => parser.reduce::<45>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Comma => parser.shift(35),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::VarlistCont => parser.goto(381),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<153> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            TokenType::Comma => parser.shift(380),
            TokenType::Eof => parser.reduce::<29>(),
            TokenType::AttnamelistCont => parser.goto(379),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<154> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(493),
            TokenType::LParen => parser.shift(497),
            TokenType::LSquare => parser.shift(47),
            TokenType::LCurly => parser.shift(526),
            TokenType::Colon => parser.shift(489),
            TokenType::Dot => parser.shift(72),
            TokenType::Args => parser.goto(492),
            TokenType::Tableconstructor => parser.goto(520),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<155> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::RSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<156> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::SemiColon => parser.shift(386),
            TokenType::Eof => parser.reduce::<36>(),
            TokenType::RetstatEnd => parser.goto(385),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<157> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::SemiColon => parser.reduce::<35>(),
            TokenType::Eof => parser.reduce::<35>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<158> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::SemiColon => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Comma => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            TokenType::Eof => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<159> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<7>(),
            TokenType::Break => parser.reduce::<7>(),
            TokenType::Do => parser.reduce::<7>(),
            TokenType::For => parser.reduce::<7>(),
            TokenType::Function => parser.reduce::<7>(),
            TokenType::Goto => parser.reduce::<7>(),
            TokenType::If => parser.reduce::<7>(),
            TokenType::Local => parser.reduce::<7>(),
            TokenType::Repeat => parser.reduce::<7>(),
            TokenType::Return => parser.reduce::<7>(),
            TokenType::While => parser.reduce::<7>(),
            TokenType::LParen => parser.reduce::<7>(),
            TokenType::DoubleColon => parser.reduce::<7>(),
            TokenType::SemiColon => parser.reduce::<7>(),
            TokenType::Eof => parser.reduce::<7>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<160> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<47>(),
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Break => parser.reduce::<47>(),
            TokenType::Do => parser.reduce::<47>(),
            TokenType::For => parser.reduce::<47>(),
            TokenType::Function => parser.reduce::<47>(),
            TokenType::Goto => parser.reduce::<47>(),
            TokenType::If => parser.reduce::<47>(),
            TokenType::Local => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Repeat => parser.reduce::<47>(),
            TokenType::Return => parser.reduce::<47>(),
            TokenType::While => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::DoubleColon => parser.reduce::<47>(),
            TokenType::SemiColon => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Comma => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            TokenType::Eof => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<161> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<12>(),
            TokenType::Break => parser.reduce::<12>(),
            TokenType::Do => parser.reduce::<12>(),
            TokenType::For => parser.reduce::<12>(),
            TokenType::Function => parser.reduce::<12>(),
            TokenType::Goto => parser.reduce::<12>(),
            TokenType::If => parser.reduce::<12>(),
            TokenType::Local => parser.reduce::<12>(),
            TokenType::Repeat => parser.reduce::<12>(),
            TokenType::Return => parser.reduce::<12>(),
            TokenType::While => parser.reduce::<12>(),
            TokenType::LParen => parser.reduce::<12>(),
            TokenType::DoubleColon => parser.reduce::<12>(),
            TokenType::SemiColon => parser.reduce::<12>(),
            TokenType::Eof => parser.reduce::<12>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<162> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<51>(),
            TokenType::Assign => parser.shift(417),
            TokenType::Comma => parser.shift(250),
            TokenType::NamelistCont => parser.goto(249),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<163> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(387),
            TokenType::Funcbody => parser.goto(383),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<164> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(563),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.shift(565),
            TokenType::LSquare => parser.shift(419),
            TokenType::RSquare => parser.reduce::<64>(),
            TokenType::LCurly => parser.shift(629),
            TokenType::Colon => parser.shift(561),
            TokenType::Dot => parser.shift(553),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(562),
            TokenType::Tableconstructor => parser.goto(621),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<165> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(384),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<166> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<51>(),
            TokenType::Assign => parser.shift(418),
            TokenType::Comma => parser.shift(250),
            TokenType::NamelistCont => parser.goto(249),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<167> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<11>(),
            TokenType::Break => parser.reduce::<11>(),
            TokenType::Do => parser.reduce::<11>(),
            TokenType::End => parser.reduce::<11>(),
            TokenType::For => parser.reduce::<11>(),
            TokenType::Function => parser.reduce::<11>(),
            TokenType::Goto => parser.reduce::<11>(),
            TokenType::If => parser.reduce::<11>(),
            TokenType::Local => parser.reduce::<11>(),
            TokenType::Repeat => parser.reduce::<11>(),
            TokenType::Return => parser.reduce::<11>(),
            TokenType::While => parser.reduce::<11>(),
            TokenType::LParen => parser.reduce::<11>(),
            TokenType::DoubleColon => parser.reduce::<11>(),
            TokenType::SemiColon => parser.reduce::<11>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<168> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(389),
            TokenType::Funcbody => parser.goto(388),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<169> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(554),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.shift(564),
            TokenType::LSquare => parser.shift(416),
            TokenType::LCurly => parser.shift(620),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Colon => parser.shift(551),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Dot => parser.shift(548),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Eof => parser.reduce::<64>(),
            TokenType::Args => parser.goto(552),
            TokenType::Tableconstructor => parser.goto(619),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<170> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<11>(),
            TokenType::Break => parser.reduce::<11>(),
            TokenType::Do => parser.reduce::<11>(),
            TokenType::For => parser.reduce::<11>(),
            TokenType::Function => parser.reduce::<11>(),
            TokenType::Goto => parser.reduce::<11>(),
            TokenType::If => parser.reduce::<11>(),
            TokenType::Local => parser.reduce::<11>(),
            TokenType::Repeat => parser.reduce::<11>(),
            TokenType::Return => parser.reduce::<11>(),
            TokenType::Until => parser.reduce::<11>(),
            TokenType::While => parser.reduce::<11>(),
            TokenType::LParen => parser.reduce::<11>(),
            TokenType::DoubleColon => parser.reduce::<11>(),
            TokenType::SemiColon => parser.reduce::<11>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<171> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.shift(421),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<172> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.shift(420),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<173> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(433),
            TokenType::Do => parser.shift(436),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(485),
            TokenType::Function => parser.shift(487),
            TokenType::Goto => parser.shift(488),
            TokenType::If => parser.shift(502),
            TokenType::Local => parser.shift(550),
            TokenType::Repeat => parser.shift(555),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(603),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(638),
            TokenType::SemiColon => parser.shift(634),
            TokenType::Block => parser.goto(549),
            TokenType::BlockStat => parser.goto(390),
            TokenType::Stat => parser.goto(411),
            TokenType::Label => parser.goto(635),
            TokenType::Varlist => parser.goto(636),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(639),
            TokenType::Functioncall => parser.goto(637),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<174> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::Assign => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<175> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::String(_) => parser.shift(614),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            // Shift(615)-Reduce(64)
            TokenType::LParen => parser.shift(615),
            TokenType::LSquare => parser.shift(423),
            TokenType::LCurly => parser.shift(658),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Colon => parser.shift(610),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Dot => parser.shift(608),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Eof => parser.reduce::<64>(),
            TokenType::Args => parser.goto(612),
            TokenType::Tableconstructor => parser.goto(656),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<176> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(75),
            TokenType::LParen => parser.shift(87),
            TokenType::LCurly => parser.shift(108),
            TokenType::Args => parser.goto(391),
            TokenType::Tableconstructor => parser.goto(107),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<177> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(453),
            TokenType::String(_) => parser.shift(469),
            TokenType::Integer(_) => parser.shift(471),
            TokenType::Float(_) => parser.shift(472),
            TokenType::False => parser.shift(473),
            TokenType::Function => parser.shift(630),
            TokenType::Nil => parser.shift(474),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(475),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(577),
            TokenType::LCurly => parser.shift(631),
            TokenType::Dots => parser.shift(476),
            TokenType::Var => parser.goto(617),
            TokenType::Exp => parser.goto(410),
            TokenType::Prefixexp => parser.goto(457),
            TokenType::Functioncall => parser.goto(618),
            TokenType::Functiondef => parser.goto(511),
            TokenType::Tableconstructor => parser.goto(512),
            TokenType::Unop => parser.goto(515),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<178> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Then => parser.shift(413),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<179> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(396),
            TokenType::String(_) => parser.shift(447),
            TokenType::Integer(_) => parser.shift(448),
            TokenType::Float(_) => parser.shift(449),
            TokenType::False => parser.shift(450),
            TokenType::Function => parser.shift(649),
            TokenType::Nil => parser.shift(451),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(452),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(609),
            TokenType::LCurly => parser.shift(650),
            TokenType::Dots => parser.shift(455),
            TokenType::Var => parser.goto(647),
            TokenType::Explist => parser.goto(392),
            TokenType::Exp => parser.goto(446),
            TokenType::Prefixexp => parser.goto(405),
            TokenType::Functioncall => parser.goto(648),
            TokenType::Functiondef => parser.goto(500),
            TokenType::Tableconstructor => parser.goto(501),
            TokenType::Unop => parser.goto(509),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<180> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(437),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<181> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Return => parser.reduce::<3>(),
            TokenType::Until => parser.reduce::<3>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<182> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Then => parser.shift(415),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<183> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<3>(),
            TokenType::Return => parser.reduce::<3>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<184> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(279),
            TokenType::Integer(_) => parser.shift(280),
            TokenType::Float(_) => parser.shift(281),
            TokenType::False => parser.shift(291),
            TokenType::Function => parser.shift(370),
            TokenType::Nil => parser.shift(292),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(293),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(364),
            TokenType::LCurly => parser.shift(371),
            TokenType::Dots => parser.shift(296),
            TokenType::Var => parser.goto(368),
            TokenType::Explist => parser.goto(393),
            TokenType::Exp => parser.goto(248),
            TokenType::Prefixexp => parser.goto(175),
            TokenType::Functioncall => parser.goto(369),
            TokenType::Functiondef => parser.goto(330),
            TokenType::Tableconstructor => parser.goto(331),
            TokenType::Unop => parser.goto(333),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<185> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(397),
            TokenType::String(_) => parser.shift(458),
            TokenType::Integer(_) => parser.shift(459),
            TokenType::Float(_) => parser.shift(460),
            TokenType::End => parser.reduce::<34>(),
            TokenType::False => parser.shift(461),
            TokenType::Function => parser.shift(659),
            TokenType::Nil => parser.shift(462),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(463),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(613),
            TokenType::LCurly => parser.shift(660),
            TokenType::SemiColon => parser.reduce::<34>(),
            TokenType::Dots => parser.shift(465),
            TokenType::RetstatExplist => parser.goto(394),
            TokenType::Var => parser.goto(652),
            TokenType::Explist => parser.goto(395),
            TokenType::Exp => parser.goto(454),
            TokenType::Prefixexp => parser.goto(406),
            TokenType::Functioncall => parser.goto(653),
            TokenType::Functiondef => parser.goto(506),
            TokenType::Tableconstructor => parser.goto(507),
            TokenType::Unop => parser.goto(510),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<186> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(401),
            TokenType::String(_) => parser.shift(480),
            TokenType::Integer(_) => parser.shift(481),
            TokenType::Float(_) => parser.shift(483),
            TokenType::False => parser.shift(484),
            TokenType::Function => parser.shift(669),
            TokenType::Nil => parser.shift(495),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(496),
            TokenType::Until => parser.reduce::<34>(),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(646),
            TokenType::LCurly => parser.shift(670),
            TokenType::SemiColon => parser.reduce::<34>(),
            TokenType::Dots => parser.shift(498),
            TokenType::RetstatExplist => parser.goto(398),
            TokenType::Var => parser.goto(665),
            TokenType::Explist => parser.goto(399),
            TokenType::Exp => parser.goto(477),
            TokenType::Prefixexp => parser.goto(408),
            TokenType::Functioncall => parser.goto(666),
            TokenType::Functiondef => parser.goto(541),
            TokenType::Tableconstructor => parser.goto(545),
            TokenType::Unop => parser.goto(566),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<187> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::RParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Comma => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<188> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(440),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<189> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(585),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.shift(587),
            TokenType::RParen => parser.reduce::<64>(),
            TokenType::LSquare => parser.shift(422),
            TokenType::LCurly => parser.shift(645),
            TokenType::Colon => parser.shift(583),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Dot => parser.shift(582),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(584),
            TokenType::Tableconstructor => parser.goto(644),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<190> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(456),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<191> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(444),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<192> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(400),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<193> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(402),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<194> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<26>(),
            TokenType::Break => parser.reduce::<26>(),
            TokenType::Do => parser.reduce::<26>(),
            TokenType::For => parser.reduce::<26>(),
            TokenType::Function => parser.reduce::<26>(),
            TokenType::Goto => parser.reduce::<26>(),
            TokenType::If => parser.reduce::<26>(),
            TokenType::Local => parser.reduce::<26>(),
            TokenType::Repeat => parser.reduce::<26>(),
            TokenType::Return => parser.reduce::<26>(),
            TokenType::Until => parser.reduce::<26>(),
            TokenType::While => parser.reduce::<26>(),
            TokenType::Assign => parser.shift(439),
            TokenType::LParen => parser.reduce::<26>(),
            TokenType::DoubleColon => parser.reduce::<26>(),
            TokenType::SemiColon => parser.reduce::<26>(),
            TokenType::StatAttexplist => parser.goto(403),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<195> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::Until => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Less => parser.shift(409),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            TokenType::Comma => parser.reduce::<31>(),
            TokenType::Attrib => parser.goto(404),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<196> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Do => parser.shift(412),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(220),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<197> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(426),
            TokenType::Concat => parser.shift(311),
            TokenType::Eof => parser.reduce::<54>(),
            TokenType::ExplistCont => parser.goto(407),
            TokenType::Binop => parser.goto(466),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<198> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            TokenType::Eof => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<199> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(505),
            TokenType::String(_) => parser.shift(588),
            TokenType::Integer(_) => parser.shift(589),
            TokenType::Float(_) => parser.shift(590),
            TokenType::False => parser.shift(591),
            TokenType::Function => parser.shift(688),
            TokenType::Nil => parser.shift(592),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(593),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(676),
            TokenType::LCurly => parser.shift(689),
            TokenType::Dots => parser.shift(594),
            TokenType::Var => parser.goto(686),
            TokenType::Exp => parser.goto(434),
            TokenType::Prefixexp => parser.goto(508),
            TokenType::Functioncall => parser.goto(687),
            TokenType::Functiondef => parser.goto(641),
            TokenType::Tableconstructor => parser.goto(642),
            TokenType::Unop => parser.goto(643),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<200> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            TokenType::Eof => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<201> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Do => parser.shift(494),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(220),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<202> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            TokenType::Eof => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<203> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            TokenType::Eof => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<204> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Comma => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            TokenType::Eof => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<205> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            TokenType::Eof => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<206> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            TokenType::Eof => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<207> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(435),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(425),
            TokenType::Binop => parser.goto(445),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<208> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::RParen => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<209> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::RParen => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<210> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::RParen => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<211> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(429),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<212> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::RParen => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<213> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::RParen => parser.reduce::<56>(),
            TokenType::Comma => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<214> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::RParen => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<215> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::RParen => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<216> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::Assign => parser.shift(441),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::RCurly => parser.reduce::<47>(),
            TokenType::SemiColon => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Comma => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<217> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Then => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<218> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::RParen => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<219> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(570),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.shift(572),
            TokenType::LSquare => parser.shift(438),
            TokenType::LCurly => parser.shift(605),
            TokenType::RCurly => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Colon => parser.shift(568),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Dot => parser.shift(567),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(569),
            TokenType::Tableconstructor => parser.goto(604),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<220> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(61),
            TokenType::String(_) => parser.shift(83),
            TokenType::Integer(_) => parser.shift(84),
            TokenType::Float(_) => parser.shift(85),
            TokenType::False => parser.shift(86),
            TokenType::Function => parser.shift(133),
            TokenType::Nil => parser.shift(88),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(89),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(123),
            TokenType::LCurly => parser.shift(135),
            TokenType::Dots => parser.shift(90),
            TokenType::Var => parser.goto(128),
            TokenType::Exp => parser.goto(516),
            TokenType::Prefixexp => parser.goto(62),
            TokenType::Functioncall => parser.goto(129),
            TokenType::Functiondef => parser.goto(96),
            TokenType::Tableconstructor => parser.goto(97),
            TokenType::Unop => parser.goto(99),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<221> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<222> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(428),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<223> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::RSquare => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<224> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::RSquare => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<225> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::RSquare => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<226> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(220),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<227> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::RSquare => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<228> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::RSquare => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<229> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::RSquare => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<230> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::RSquare => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<231> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(59),
            TokenType::String(_) => parser.shift(76),
            TokenType::Integer(_) => parser.shift(77),
            TokenType::Float(_) => parser.shift(78),
            TokenType::False => parser.shift(79),
            TokenType::Function => parser.shift(132),
            TokenType::Nil => parser.shift(80),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(81),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(122),
            TokenType::LCurly => parser.shift(134),
            TokenType::Dots => parser.shift(82),
            TokenType::Var => parser.goto(126),
            TokenType::Exp => parser.goto(464),
            TokenType::Prefixexp => parser.goto(60),
            TokenType::Functioncall => parser.goto(127),
            TokenType::Functiondef => parser.goto(94),
            TokenType::Tableconstructor => parser.goto(95),
            TokenType::Unop => parser.goto(98),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<232> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(414),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<233> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<26>(),
            TokenType::Break => parser.reduce::<26>(),
            TokenType::Do => parser.reduce::<26>(),
            TokenType::End => parser.reduce::<26>(),
            TokenType::For => parser.reduce::<26>(),
            TokenType::Function => parser.reduce::<26>(),
            TokenType::Goto => parser.reduce::<26>(),
            TokenType::If => parser.reduce::<26>(),
            TokenType::Local => parser.reduce::<26>(),
            TokenType::Repeat => parser.reduce::<26>(),
            TokenType::Return => parser.reduce::<26>(),
            TokenType::While => parser.reduce::<26>(),
            TokenType::Assign => parser.shift(504),
            TokenType::LParen => parser.reduce::<26>(),
            TokenType::DoubleColon => parser.reduce::<26>(),
            TokenType::SemiColon => parser.reduce::<26>(),
            TokenType::StatAttexplist => parser.goto(490),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<234> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::End => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Less => parser.shift(432),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            TokenType::Comma => parser.reduce::<31>(),
            TokenType::Attrib => parser.goto(431),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<235> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::DoubleColon => parser.shift(430),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<236> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::RParen => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<237> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Then => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<238> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(424),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<239> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(491),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<240> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::RCurly => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<241> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::RCurly => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<242> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::RCurly => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<243> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::RCurly => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<244> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::RCurly => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Comma => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<245> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::RCurly => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<246> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::RCurly => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<247> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RCurly => parser.reduce::<96>(),
            TokenType::SemiColon => parser.reduce::<96>(),
            TokenType::Comma => parser.reduce::<96>(),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(527),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<248> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::And => parser.shift(283),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.shift(284),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(538),
            TokenType::Concat => parser.shift(311),
            TokenType::Eof => parser.reduce::<54>(),
            TokenType::ExplistCont => parser.goto(518),
            TokenType::Binop => parser.goto(616),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<249> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<50>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<250> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(442),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<251> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::DoubleColon => parser.shift(470),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<252> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(622),
            TokenType::Integer(_) => parser.shift(623),
            TokenType::Float(_) => parser.shift(624),
            TokenType::False => parser.shift(625),
            TokenType::Function => parser.shift(692),
            TokenType::Nil => parser.shift(626),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(627),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(684),
            TokenType::LCurly => parser.shift(693),
            TokenType::Dots => parser.shift(628),
            TokenType::Var => parser.goto(690),
            TokenType::Explist => parser.goto(517),
            TokenType::Exp => parser.goto(607),
            TokenType::Prefixexp => parser.goto(521),
            TokenType::Functioncall => parser.goto(691),
            TokenType::Functiondef => parser.goto(654),
            TokenType::Tableconstructor => parser.goto(655),
            TokenType::Unop => parser.goto(657),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<253> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(479),
            TokenType::String(_) => parser.shift(595),
            TokenType::Integer(_) => parser.shift(597),
            TokenType::Float(_) => parser.shift(598),
            TokenType::False => parser.shift(599),
            TokenType::Function => parser.shift(680),
            TokenType::Nil => parser.shift(600),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(601),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(667),
            TokenType::LCurly => parser.shift(681),
            TokenType::Dots => parser.shift(602),
            TokenType::Var => parser.goto(678),
            TokenType::Explist => parser.goto(478),
            TokenType::Exp => parser.goto(571),
            TokenType::Prefixexp => parser.goto(482),
            TokenType::Functioncall => parser.goto(679),
            TokenType::Functiondef => parser.goto(632),
            TokenType::Tableconstructor => parser.goto(633),
            TokenType::Unop => parser.goto(640),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<254> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(578),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<255> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(606),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<256> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            TokenType::Eof => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<257> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Eof => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<258> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::RParen => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<259> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::RParen => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<260> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(158),
            TokenType::String(_) => parser.shift(198),
            TokenType::Integer(_) => parser.shift(200),
            TokenType::Float(_) => parser.shift(202),
            TokenType::False => parser.shift(203),
            TokenType::Function => parser.shift(347),
            TokenType::Nil => parser.shift(204),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(205),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(329),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(206),
            TokenType::Var => parser.goto(339),
            TokenType::Exp => parser.goto(575),
            TokenType::Prefixexp => parser.goto(169),
            TokenType::Functioncall => parser.goto(341),
            TokenType::Functiondef => parser.goto(256),
            TokenType::Tableconstructor => parser.goto(257),
            TokenType::Unop => parser.goto(260),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<261> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<262> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::RSquare => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<263> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(503),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<264> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::RSquare => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<265> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Exp => parser.goto(596),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<266> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(486),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<267> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(514),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<268> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::Until => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<269> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::Until => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<270> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(663),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<271> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::RCurly => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<272> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::RCurly => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<273> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(573),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<274> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(467),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LCurly => parser.shift(359),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(513),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<275> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(468),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<276> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<277> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<278> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(671),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<279> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            TokenType::Eof => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<280> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            TokenType::Eof => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<281> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            TokenType::Eof => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<282> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<283> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<100>(),
            TokenType::String(_) => parser.reduce::<100>(),
            TokenType::Integer(_) => parser.reduce::<100>(),
            TokenType::Float(_) => parser.reduce::<100>(),
            TokenType::False => parser.reduce::<100>(),
            TokenType::Function => parser.reduce::<100>(),
            TokenType::Nil => parser.reduce::<100>(),
            TokenType::Not => parser.reduce::<100>(),
            TokenType::True => parser.reduce::<100>(),
            TokenType::Sub => parser.reduce::<100>(),
            TokenType::Len => parser.reduce::<100>(),
            TokenType::BitXor => parser.reduce::<100>(),
            TokenType::LParen => parser.reduce::<100>(),
            TokenType::LCurly => parser.reduce::<100>(),
            TokenType::Dots => parser.reduce::<100>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<284> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<99>(),
            TokenType::String(_) => parser.reduce::<99>(),
            TokenType::Integer(_) => parser.reduce::<99>(),
            TokenType::Float(_) => parser.reduce::<99>(),
            TokenType::False => parser.reduce::<99>(),
            TokenType::Function => parser.reduce::<99>(),
            TokenType::Nil => parser.reduce::<99>(),
            TokenType::Not => parser.reduce::<99>(),
            TokenType::True => parser.reduce::<99>(),
            TokenType::Sub => parser.reduce::<99>(),
            TokenType::Len => parser.reduce::<99>(),
            TokenType::BitXor => parser.reduce::<99>(),
            TokenType::LParen => parser.reduce::<99>(),
            TokenType::LCurly => parser.reduce::<99>(),
            TokenType::Dots => parser.reduce::<99>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<285> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<113>(),
            TokenType::String(_) => parser.reduce::<113>(),
            TokenType::Integer(_) => parser.reduce::<113>(),
            TokenType::Float(_) => parser.reduce::<113>(),
            TokenType::False => parser.reduce::<113>(),
            TokenType::Function => parser.reduce::<113>(),
            TokenType::Nil => parser.reduce::<113>(),
            TokenType::Not => parser.reduce::<113>(),
            TokenType::True => parser.reduce::<113>(),
            TokenType::Sub => parser.reduce::<113>(),
            TokenType::Len => parser.reduce::<113>(),
            TokenType::BitXor => parser.reduce::<113>(),
            TokenType::LParen => parser.reduce::<113>(),
            TokenType::LCurly => parser.reduce::<113>(),
            TokenType::Dots => parser.reduce::<113>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<286> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<114>(),
            TokenType::String(_) => parser.reduce::<114>(),
            TokenType::Integer(_) => parser.reduce::<114>(),
            TokenType::Float(_) => parser.reduce::<114>(),
            TokenType::False => parser.reduce::<114>(),
            TokenType::Function => parser.reduce::<114>(),
            TokenType::Nil => parser.reduce::<114>(),
            TokenType::Not => parser.reduce::<114>(),
            TokenType::True => parser.reduce::<114>(),
            TokenType::Sub => parser.reduce::<114>(),
            TokenType::Len => parser.reduce::<114>(),
            TokenType::BitXor => parser.reduce::<114>(),
            TokenType::LParen => parser.reduce::<114>(),
            TokenType::LCurly => parser.reduce::<114>(),
            TokenType::Dots => parser.reduce::<114>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<287> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<115>(),
            TokenType::String(_) => parser.reduce::<115>(),
            TokenType::Integer(_) => parser.reduce::<115>(),
            TokenType::Float(_) => parser.reduce::<115>(),
            TokenType::False => parser.reduce::<115>(),
            TokenType::Function => parser.reduce::<115>(),
            TokenType::Nil => parser.reduce::<115>(),
            TokenType::Not => parser.reduce::<115>(),
            TokenType::True => parser.reduce::<115>(),
            TokenType::Sub => parser.reduce::<115>(),
            TokenType::Len => parser.reduce::<115>(),
            TokenType::BitXor => parser.reduce::<115>(),
            TokenType::LParen => parser.reduce::<115>(),
            TokenType::LCurly => parser.reduce::<115>(),
            TokenType::Dots => parser.reduce::<115>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<288> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<116>(),
            TokenType::String(_) => parser.reduce::<116>(),
            TokenType::Integer(_) => parser.reduce::<116>(),
            TokenType::Float(_) => parser.reduce::<116>(),
            TokenType::False => parser.reduce::<116>(),
            TokenType::Function => parser.reduce::<116>(),
            TokenType::Nil => parser.reduce::<116>(),
            TokenType::Not => parser.reduce::<116>(),
            TokenType::True => parser.reduce::<116>(),
            TokenType::Sub => parser.reduce::<116>(),
            TokenType::Len => parser.reduce::<116>(),
            TokenType::BitXor => parser.reduce::<116>(),
            TokenType::LParen => parser.reduce::<116>(),
            TokenType::LCurly => parser.reduce::<116>(),
            TokenType::Dots => parser.reduce::<116>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<289> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<117>(),
            TokenType::String(_) => parser.reduce::<117>(),
            TokenType::Integer(_) => parser.reduce::<117>(),
            TokenType::Float(_) => parser.reduce::<117>(),
            TokenType::False => parser.reduce::<117>(),
            TokenType::Function => parser.reduce::<117>(),
            TokenType::Nil => parser.reduce::<117>(),
            TokenType::Not => parser.reduce::<117>(),
            TokenType::True => parser.reduce::<117>(),
            TokenType::Sub => parser.reduce::<117>(),
            TokenType::Len => parser.reduce::<117>(),
            TokenType::BitXor => parser.reduce::<117>(),
            TokenType::LParen => parser.reduce::<117>(),
            TokenType::LCurly => parser.reduce::<117>(),
            TokenType::Dots => parser.reduce::<117>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<290> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<118>(),
            TokenType::String(_) => parser.reduce::<118>(),
            TokenType::Integer(_) => parser.reduce::<118>(),
            TokenType::Float(_) => parser.reduce::<118>(),
            TokenType::False => parser.reduce::<118>(),
            TokenType::Function => parser.reduce::<118>(),
            TokenType::Nil => parser.reduce::<118>(),
            TokenType::Not => parser.reduce::<118>(),
            TokenType::True => parser.reduce::<118>(),
            TokenType::Sub => parser.reduce::<118>(),
            TokenType::Len => parser.reduce::<118>(),
            TokenType::BitXor => parser.reduce::<118>(),
            TokenType::LParen => parser.reduce::<118>(),
            TokenType::LCurly => parser.reduce::<118>(),
            TokenType::Dots => parser.reduce::<118>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<291> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            TokenType::Eof => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<292> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<56>(),
            TokenType::And => parser.reduce::<56>(),
            TokenType::Break => parser.reduce::<56>(),
            TokenType::Do => parser.reduce::<56>(),
            TokenType::For => parser.reduce::<56>(),
            TokenType::Function => parser.reduce::<56>(),
            TokenType::Goto => parser.reduce::<56>(),
            TokenType::If => parser.reduce::<56>(),
            TokenType::Local => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Repeat => parser.reduce::<56>(),
            TokenType::Return => parser.reduce::<56>(),
            TokenType::While => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::LParen => parser.reduce::<56>(),
            TokenType::DoubleColon => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Comma => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            TokenType::Eof => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<293> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            TokenType::Eof => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<294> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<119>(),
            TokenType::String(_) => parser.reduce::<119>(),
            TokenType::Integer(_) => parser.reduce::<119>(),
            TokenType::Float(_) => parser.reduce::<119>(),
            TokenType::False => parser.reduce::<119>(),
            TokenType::Function => parser.reduce::<119>(),
            TokenType::Nil => parser.reduce::<119>(),
            TokenType::Not => parser.reduce::<119>(),
            TokenType::True => parser.reduce::<119>(),
            TokenType::Sub => parser.reduce::<119>(),
            TokenType::Len => parser.reduce::<119>(),
            TokenType::BitXor => parser.reduce::<119>(),
            TokenType::LParen => parser.reduce::<119>(),
            TokenType::LCurly => parser.reduce::<119>(),
            TokenType::Dots => parser.reduce::<119>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<295> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<109>(),
            TokenType::String(_) => parser.reduce::<109>(),
            TokenType::Integer(_) => parser.reduce::<109>(),
            TokenType::Float(_) => parser.reduce::<109>(),
            TokenType::False => parser.reduce::<109>(),
            TokenType::Function => parser.reduce::<109>(),
            TokenType::Nil => parser.reduce::<109>(),
            TokenType::Not => parser.reduce::<109>(),
            TokenType::True => parser.reduce::<109>(),
            TokenType::Sub => parser.reduce::<109>(),
            TokenType::Len => parser.reduce::<109>(),
            TokenType::BitXor => parser.reduce::<109>(),
            TokenType::LParen => parser.reduce::<109>(),
            TokenType::LCurly => parser.reduce::<109>(),
            TokenType::Dots => parser.reduce::<109>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<296> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            TokenType::Eof => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<297> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<108>(),
            TokenType::String(_) => parser.reduce::<108>(),
            TokenType::Integer(_) => parser.reduce::<108>(),
            TokenType::Float(_) => parser.reduce::<108>(),
            TokenType::False => parser.reduce::<108>(),
            TokenType::Function => parser.reduce::<108>(),
            TokenType::Nil => parser.reduce::<108>(),
            TokenType::Not => parser.reduce::<108>(),
            TokenType::True => parser.reduce::<108>(),
            TokenType::Sub => parser.reduce::<108>(),
            TokenType::Len => parser.reduce::<108>(),
            TokenType::BitXor => parser.reduce::<108>(),
            TokenType::LParen => parser.reduce::<108>(),
            TokenType::LCurly => parser.reduce::<108>(),
            TokenType::Dots => parser.reduce::<108>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<298> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<107>(),
            TokenType::String(_) => parser.reduce::<107>(),
            TokenType::Integer(_) => parser.reduce::<107>(),
            TokenType::Float(_) => parser.reduce::<107>(),
            TokenType::False => parser.reduce::<107>(),
            TokenType::Function => parser.reduce::<107>(),
            TokenType::Nil => parser.reduce::<107>(),
            TokenType::Not => parser.reduce::<107>(),
            TokenType::True => parser.reduce::<107>(),
            TokenType::Sub => parser.reduce::<107>(),
            TokenType::Len => parser.reduce::<107>(),
            TokenType::BitXor => parser.reduce::<107>(),
            TokenType::LParen => parser.reduce::<107>(),
            TokenType::LCurly => parser.reduce::<107>(),
            TokenType::Dots => parser.reduce::<107>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<299> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<110>(),
            TokenType::String(_) => parser.reduce::<110>(),
            TokenType::Integer(_) => parser.reduce::<110>(),
            TokenType::Float(_) => parser.reduce::<110>(),
            TokenType::False => parser.reduce::<110>(),
            TokenType::Function => parser.reduce::<110>(),
            TokenType::Nil => parser.reduce::<110>(),
            TokenType::Not => parser.reduce::<110>(),
            TokenType::True => parser.reduce::<110>(),
            TokenType::Sub => parser.reduce::<110>(),
            TokenType::Len => parser.reduce::<110>(),
            TokenType::BitXor => parser.reduce::<110>(),
            TokenType::LParen => parser.reduce::<110>(),
            TokenType::LCurly => parser.reduce::<110>(),
            TokenType::Dots => parser.reduce::<110>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<300> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<111>(),
            TokenType::String(_) => parser.reduce::<111>(),
            TokenType::Integer(_) => parser.reduce::<111>(),
            TokenType::Float(_) => parser.reduce::<111>(),
            TokenType::False => parser.reduce::<111>(),
            TokenType::Function => parser.reduce::<111>(),
            TokenType::Nil => parser.reduce::<111>(),
            TokenType::Not => parser.reduce::<111>(),
            TokenType::True => parser.reduce::<111>(),
            TokenType::Sub => parser.reduce::<111>(),
            TokenType::Len => parser.reduce::<111>(),
            TokenType::BitXor => parser.reduce::<111>(),
            TokenType::LParen => parser.reduce::<111>(),
            TokenType::LCurly => parser.reduce::<111>(),
            TokenType::Dots => parser.reduce::<111>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<301> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<105>(),
            TokenType::String(_) => parser.reduce::<105>(),
            TokenType::Integer(_) => parser.reduce::<105>(),
            TokenType::Float(_) => parser.reduce::<105>(),
            TokenType::False => parser.reduce::<105>(),
            TokenType::Function => parser.reduce::<105>(),
            TokenType::Nil => parser.reduce::<105>(),
            TokenType::Not => parser.reduce::<105>(),
            TokenType::True => parser.reduce::<105>(),
            TokenType::Sub => parser.reduce::<105>(),
            TokenType::Len => parser.reduce::<105>(),
            TokenType::BitXor => parser.reduce::<105>(),
            TokenType::LParen => parser.reduce::<105>(),
            TokenType::LCurly => parser.reduce::<105>(),
            TokenType::Dots => parser.reduce::<105>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<302> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<106>(),
            TokenType::String(_) => parser.reduce::<106>(),
            TokenType::Integer(_) => parser.reduce::<106>(),
            TokenType::Float(_) => parser.reduce::<106>(),
            TokenType::False => parser.reduce::<106>(),
            TokenType::Function => parser.reduce::<106>(),
            TokenType::Nil => parser.reduce::<106>(),
            TokenType::Not => parser.reduce::<106>(),
            TokenType::True => parser.reduce::<106>(),
            TokenType::Sub => parser.reduce::<106>(),
            TokenType::Len => parser.reduce::<106>(),
            TokenType::BitXor => parser.reduce::<106>(),
            TokenType::LParen => parser.reduce::<106>(),
            TokenType::LCurly => parser.reduce::<106>(),
            TokenType::Dots => parser.reduce::<106>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<303> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<103>(),
            TokenType::String(_) => parser.reduce::<103>(),
            TokenType::Integer(_) => parser.reduce::<103>(),
            TokenType::Float(_) => parser.reduce::<103>(),
            TokenType::False => parser.reduce::<103>(),
            TokenType::Function => parser.reduce::<103>(),
            TokenType::Nil => parser.reduce::<103>(),
            TokenType::Not => parser.reduce::<103>(),
            TokenType::True => parser.reduce::<103>(),
            TokenType::Sub => parser.reduce::<103>(),
            TokenType::Len => parser.reduce::<103>(),
            TokenType::BitXor => parser.reduce::<103>(),
            TokenType::LParen => parser.reduce::<103>(),
            TokenType::LCurly => parser.reduce::<103>(),
            TokenType::Dots => parser.reduce::<103>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<304> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(499),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<305> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(443),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<306> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Then => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<307> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Then => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<308> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<104>(),
            TokenType::String(_) => parser.reduce::<104>(),
            TokenType::Integer(_) => parser.reduce::<104>(),
            TokenType::Float(_) => parser.reduce::<104>(),
            TokenType::False => parser.reduce::<104>(),
            TokenType::Function => parser.reduce::<104>(),
            TokenType::Nil => parser.reduce::<104>(),
            TokenType::Not => parser.reduce::<104>(),
            TokenType::True => parser.reduce::<104>(),
            TokenType::Sub => parser.reduce::<104>(),
            TokenType::Len => parser.reduce::<104>(),
            TokenType::BitXor => parser.reduce::<104>(),
            TokenType::LParen => parser.reduce::<104>(),
            TokenType::LCurly => parser.reduce::<104>(),
            TokenType::Dots => parser.reduce::<104>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<309> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<101>(),
            TokenType::String(_) => parser.reduce::<101>(),
            TokenType::Integer(_) => parser.reduce::<101>(),
            TokenType::Float(_) => parser.reduce::<101>(),
            TokenType::False => parser.reduce::<101>(),
            TokenType::Function => parser.reduce::<101>(),
            TokenType::Nil => parser.reduce::<101>(),
            TokenType::Not => parser.reduce::<101>(),
            TokenType::True => parser.reduce::<101>(),
            TokenType::Sub => parser.reduce::<101>(),
            TokenType::Len => parser.reduce::<101>(),
            TokenType::BitXor => parser.reduce::<101>(),
            TokenType::LParen => parser.reduce::<101>(),
            TokenType::LCurly => parser.reduce::<101>(),
            TokenType::Dots => parser.reduce::<101>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<310> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<102>(),
            TokenType::String(_) => parser.reduce::<102>(),
            TokenType::Integer(_) => parser.reduce::<102>(),
            TokenType::Float(_) => parser.reduce::<102>(),
            TokenType::False => parser.reduce::<102>(),
            TokenType::Function => parser.reduce::<102>(),
            TokenType::Nil => parser.reduce::<102>(),
            TokenType::Not => parser.reduce::<102>(),
            TokenType::True => parser.reduce::<102>(),
            TokenType::Sub => parser.reduce::<102>(),
            TokenType::Len => parser.reduce::<102>(),
            TokenType::BitXor => parser.reduce::<102>(),
            TokenType::LParen => parser.reduce::<102>(),
            TokenType::LCurly => parser.reduce::<102>(),
            TokenType::Dots => parser.reduce::<102>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<311> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<112>(),
            TokenType::String(_) => parser.reduce::<112>(),
            TokenType::Integer(_) => parser.reduce::<112>(),
            TokenType::Float(_) => parser.reduce::<112>(),
            TokenType::False => parser.reduce::<112>(),
            TokenType::Function => parser.reduce::<112>(),
            TokenType::Nil => parser.reduce::<112>(),
            TokenType::Not => parser.reduce::<112>(),
            TokenType::True => parser.reduce::<112>(),
            TokenType::Sub => parser.reduce::<112>(),
            TokenType::Len => parser.reduce::<112>(),
            TokenType::BitXor => parser.reduce::<112>(),
            TokenType::LParen => parser.reduce::<112>(),
            TokenType::LCurly => parser.reduce::<112>(),
            TokenType::Dots => parser.reduce::<112>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<312> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(672),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<313> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.shift(544),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<314> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(528),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<315> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(531),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<316> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::RParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<317> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::RParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<318> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.shift(535),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<319> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(651),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<320> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(522),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<321> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(523),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<322> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<323> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<324> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(661),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<325> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::Until => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<326> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(673),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<327> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(581),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<328> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(586),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<329> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(576),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<330> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            TokenType::Eof => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<331> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Eof => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<332> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(547),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<333> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(279),
            TokenType::Integer(_) => parser.shift(280),
            TokenType::Float(_) => parser.shift(281),
            TokenType::False => parser.shift(291),
            TokenType::Function => parser.shift(370),
            TokenType::Nil => parser.shift(292),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(293),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(364),
            TokenType::LCurly => parser.shift(371),
            TokenType::Dots => parser.shift(296),
            TokenType::Var => parser.goto(368),
            TokenType::Exp => parser.goto(574),
            TokenType::Prefixexp => parser.goto(175),
            TokenType::Functioncall => parser.goto(369),
            TokenType::Functiondef => parser.goto(330),
            TokenType::Tableconstructor => parser.goto(331),
            TokenType::Unop => parser.goto(333),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<334> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::End => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<335> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(682),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<336> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Then => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<337> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(677),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<338> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<339> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Eof => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<340> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::RParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<341> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Eof => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<342> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::RParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<343> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(674),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<344> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(540),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<345> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<75>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<346> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(558),
            TokenType::Funcbody => parser.goto(532),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<347> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(560),
            TokenType::Funcbody => parser.goto(529),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<348> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::RSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<349> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::RSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<350> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(675),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<351> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(685),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<352> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::RParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<353> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(683),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<354> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(559),
            TokenType::Funcbody => parser.goto(533),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<355> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::RCurly => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<356> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::RCurly => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<357> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(664),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<358> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(557),
            TokenType::Funcbody => parser.goto(556),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<359> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(662),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<360> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(536),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<361> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<89>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<362> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<91>(),
            TokenType::SemiColon => parser.shift(542),
            TokenType::Comma => parser.shift(543),
            TokenType::FieldlistCont => parser.goto(537),
            TokenType::Fieldsep => parser.goto(539),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<363> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(580),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<364> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(579),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<365> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(530),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<366> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(546),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<367> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(534),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<368> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Eof => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<369> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Eof => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<370> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(525),
            TokenType::Funcbody => parser.goto(524),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<371> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(668),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<372> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<39>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<373> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(694),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<374> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<40>(),
            TokenType::Colon => parser.reduce::<40>(),
            TokenType::Dot => parser.shift(142),
            TokenType::FuncnameCont => parser.goto(695),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<375> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(715),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<376> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<81>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<377> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<83>(),
            TokenType::Comma => parser.shift(697),
            TokenType::ParlistCont => parser.goto(696),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<378> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<86>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<379> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<28>(),
            TokenType::Break => parser.reduce::<28>(),
            TokenType::Do => parser.reduce::<28>(),
            TokenType::For => parser.reduce::<28>(),
            TokenType::Function => parser.reduce::<28>(),
            TokenType::Goto => parser.reduce::<28>(),
            TokenType::If => parser.reduce::<28>(),
            TokenType::Local => parser.reduce::<28>(),
            TokenType::Repeat => parser.reduce::<28>(),
            TokenType::Return => parser.reduce::<28>(),
            TokenType::While => parser.reduce::<28>(),
            TokenType::Assign => parser.reduce::<28>(),
            TokenType::LParen => parser.reduce::<28>(),
            TokenType::DoubleColon => parser.reduce::<28>(),
            TokenType::SemiColon => parser.reduce::<28>(),
            TokenType::Eof => parser.reduce::<28>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<380> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(698),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<381> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.reduce::<46>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<382> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<24>(),
            TokenType::Break => parser.reduce::<24>(),
            TokenType::Do => parser.reduce::<24>(),
            TokenType::For => parser.reduce::<24>(),
            TokenType::Function => parser.reduce::<24>(),
            TokenType::Goto => parser.reduce::<24>(),
            TokenType::If => parser.reduce::<24>(),
            TokenType::Local => parser.reduce::<24>(),
            TokenType::Repeat => parser.reduce::<24>(),
            TokenType::Return => parser.reduce::<24>(),
            TokenType::While => parser.reduce::<24>(),
            TokenType::LParen => parser.reduce::<24>(),
            TokenType::DoubleColon => parser.reduce::<24>(),
            TokenType::SemiColon => parser.reduce::<24>(),
            TokenType::Eof => parser.reduce::<24>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<383> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<23>(),
            TokenType::Break => parser.reduce::<23>(),
            TokenType::Do => parser.reduce::<23>(),
            TokenType::End => parser.reduce::<23>(),
            TokenType::For => parser.reduce::<23>(),
            TokenType::Function => parser.reduce::<23>(),
            TokenType::Goto => parser.reduce::<23>(),
            TokenType::If => parser.reduce::<23>(),
            TokenType::Local => parser.reduce::<23>(),
            TokenType::Repeat => parser.reduce::<23>(),
            TokenType::Return => parser.reduce::<23>(),
            TokenType::While => parser.reduce::<23>(),
            TokenType::LParen => parser.reduce::<23>(),
            TokenType::DoubleColon => parser.reduce::<23>(),
            TokenType::SemiColon => parser.reduce::<23>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<384> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Greater => parser.shift(701),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<385> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<33>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<386> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Eof => parser.reduce::<37>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<387> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(699),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<388> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<23>(),
            TokenType::Break => parser.reduce::<23>(),
            TokenType::Do => parser.reduce::<23>(),
            TokenType::For => parser.reduce::<23>(),
            TokenType::Function => parser.reduce::<23>(),
            TokenType::Goto => parser.reduce::<23>(),
            TokenType::If => parser.reduce::<23>(),
            TokenType::Local => parser.reduce::<23>(),
            TokenType::Repeat => parser.reduce::<23>(),
            TokenType::Return => parser.reduce::<23>(),
            TokenType::Until => parser.reduce::<23>(),
            TokenType::While => parser.reduce::<23>(),
            TokenType::LParen => parser.reduce::<23>(),
            TokenType::DoubleColon => parser.reduce::<23>(),
            TokenType::SemiColon => parser.reduce::<23>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<389> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(703),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<390> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<4>(),
            TokenType::Elseif => parser.reduce::<4>(),
            TokenType::End => parser.reduce::<4>(),
            TokenType::Return => parser.shift(726),
            TokenType::BlockRetstat => parser.goto(704),
            TokenType::Retstat => parser.goto(705),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<391> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Eof => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<392> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(716),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<393> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<27>(),
            TokenType::Break => parser.reduce::<27>(),
            TokenType::Do => parser.reduce::<27>(),
            TokenType::For => parser.reduce::<27>(),
            TokenType::Function => parser.reduce::<27>(),
            TokenType::Goto => parser.reduce::<27>(),
            TokenType::If => parser.reduce::<27>(),
            TokenType::Local => parser.reduce::<27>(),
            TokenType::Repeat => parser.reduce::<27>(),
            TokenType::Return => parser.reduce::<27>(),
            TokenType::While => parser.reduce::<27>(),
            TokenType::LParen => parser.reduce::<27>(),
            TokenType::DoubleColon => parser.reduce::<27>(),
            TokenType::SemiColon => parser.reduce::<27>(),
            TokenType::Eof => parser.reduce::<27>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<394> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<36>(),
            TokenType::SemiColon => parser.shift(702),
            TokenType::RetstatEnd => parser.goto(700),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<395> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<35>(),
            TokenType::SemiColon => parser.reduce::<35>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<396> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Do => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Comma => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<397> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::End => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::SemiColon => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Comma => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<398> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<36>(),
            TokenType::SemiColon => parser.shift(707),
            TokenType::RetstatEnd => parser.goto(706),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<399> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<35>(),
            TokenType::SemiColon => parser.reduce::<35>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<400> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::Assign => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<401> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Until => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::SemiColon => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Comma => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<402> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(389),
            TokenType::Funcbody => parser.goto(708),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<403> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<25>(),
            TokenType::Break => parser.reduce::<25>(),
            TokenType::Do => parser.reduce::<25>(),
            TokenType::For => parser.reduce::<25>(),
            TokenType::Function => parser.reduce::<25>(),
            TokenType::Goto => parser.reduce::<25>(),
            TokenType::If => parser.reduce::<25>(),
            TokenType::Local => parser.reduce::<25>(),
            TokenType::Repeat => parser.reduce::<25>(),
            TokenType::Return => parser.reduce::<25>(),
            TokenType::Until => parser.reduce::<25>(),
            TokenType::While => parser.reduce::<25>(),
            TokenType::LParen => parser.reduce::<25>(),
            TokenType::DoubleColon => parser.reduce::<25>(),
            TokenType::SemiColon => parser.reduce::<25>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<404> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::Until => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            TokenType::Comma => parser.shift(711),
            TokenType::AttnamelistCont => parser.goto(710),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<405> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(899),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.shift(903),
            TokenType::LSquare => parser.shift(729),
            TokenType::LCurly => parser.shift(933),
            TokenType::Colon => parser.shift(897),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Dot => parser.shift(881),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(898),
            TokenType::Tableconstructor => parser.goto(932),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<406> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(907),
            TokenType::And => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.shift(915),
            TokenType::LSquare => parser.shift(728),
            TokenType::LCurly => parser.shift(939),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Colon => parser.shift(905),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Dot => parser.shift(904),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(906),
            TokenType::Tableconstructor => parser.goto(938),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<407> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Eof => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<408> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(893),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Until => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.shift(895),
            TokenType::LSquare => parser.shift(725),
            TokenType::LCurly => parser.shift(930),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Colon => parser.shift(891),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Dot => parser.shift(882),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(892),
            TokenType::Tableconstructor => parser.goto(929),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<409> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(709),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<410> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Comma => parser.shift(727),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(835),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<411> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(433),
            TokenType::Do => parser.shift(436),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(485),
            TokenType::Function => parser.shift(487),
            TokenType::Goto => parser.shift(488),
            TokenType::If => parser.shift(502),
            TokenType::Local => parser.shift(550),
            TokenType::Repeat => parser.shift(555),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(603),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(638),
            TokenType::SemiColon => parser.shift(634),
            TokenType::BlockStat => parser.goto(732),
            TokenType::Stat => parser.goto(411),
            TokenType::Label => parser.goto(635),
            TokenType::Varlist => parser.goto(636),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(639),
            TokenType::Functioncall => parser.goto(637),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<412> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(913),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<413> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(433),
            TokenType::Do => parser.shift(436),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(485),
            TokenType::Function => parser.shift(487),
            TokenType::Goto => parser.shift(488),
            TokenType::If => parser.shift(502),
            TokenType::Local => parser.shift(550),
            TokenType::Repeat => parser.shift(555),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(603),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(638),
            TokenType::SemiColon => parser.shift(634),
            TokenType::Block => parser.goto(871),
            TokenType::BlockStat => parser.goto(390),
            TokenType::Stat => parser.goto(411),
            TokenType::Label => parser.goto(635),
            TokenType::Varlist => parser.goto(636),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(639),
            TokenType::Functioncall => parser.goto(637),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<414> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(387),
            TokenType::Funcbody => parser.goto(713),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<415> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(433),
            TokenType::Do => parser.shift(436),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(485),
            TokenType::Function => parser.shift(487),
            TokenType::Goto => parser.shift(488),
            TokenType::If => parser.shift(502),
            TokenType::Local => parser.shift(550),
            TokenType::Repeat => parser.shift(555),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(603),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(638),
            TokenType::SemiColon => parser.shift(634),
            TokenType::Block => parser.goto(859),
            TokenType::BlockStat => parser.goto(390),
            TokenType::Stat => parser.goto(411),
            TokenType::Label => parser.goto(635),
            TokenType::Varlist => parser.goto(636),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(639),
            TokenType::Functioncall => parser.goto(637),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<416> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(763),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<417> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(453),
            TokenType::String(_) => parser.shift(469),
            TokenType::Integer(_) => parser.shift(471),
            TokenType::Float(_) => parser.shift(472),
            TokenType::False => parser.shift(473),
            TokenType::Function => parser.shift(630),
            TokenType::Nil => parser.shift(474),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(475),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(577),
            TokenType::LCurly => parser.shift(631),
            TokenType::Dots => parser.shift(476),
            TokenType::Var => parser.goto(617),
            TokenType::Exp => parser.goto(722),
            TokenType::Prefixexp => parser.goto(457),
            TokenType::Functioncall => parser.goto(618),
            TokenType::Functiondef => parser.goto(511),
            TokenType::Tableconstructor => parser.goto(512),
            TokenType::Unop => parser.goto(515),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<418> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(453),
            TokenType::String(_) => parser.shift(469),
            TokenType::Integer(_) => parser.shift(471),
            TokenType::Float(_) => parser.shift(472),
            TokenType::False => parser.shift(473),
            TokenType::Function => parser.shift(630),
            TokenType::Nil => parser.shift(474),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(475),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(577),
            TokenType::LCurly => parser.shift(631),
            TokenType::Dots => parser.shift(476),
            TokenType::Var => parser.goto(617),
            TokenType::Exp => parser.goto(721),
            TokenType::Prefixexp => parser.goto(457),
            TokenType::Functioncall => parser.goto(618),
            TokenType::Functiondef => parser.goto(511),
            TokenType::Tableconstructor => parser.goto(512),
            TokenType::Unop => parser.goto(515),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<419> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(734),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<420> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(396),
            TokenType::String(_) => parser.shift(447),
            TokenType::Integer(_) => parser.shift(448),
            TokenType::Float(_) => parser.shift(449),
            TokenType::False => parser.shift(450),
            TokenType::Function => parser.shift(649),
            TokenType::Nil => parser.shift(451),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(452),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(609),
            TokenType::LCurly => parser.shift(650),
            TokenType::Dots => parser.shift(455),
            TokenType::Var => parser.goto(647),
            TokenType::Explist => parser.goto(712),
            TokenType::Exp => parser.goto(446),
            TokenType::Prefixexp => parser.goto(405),
            TokenType::Functioncall => parser.goto(648),
            TokenType::Functiondef => parser.goto(500),
            TokenType::Tableconstructor => parser.goto(501),
            TokenType::Unop => parser.goto(509),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<421> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(396),
            TokenType::String(_) => parser.shift(447),
            TokenType::Integer(_) => parser.shift(448),
            TokenType::Float(_) => parser.shift(449),
            TokenType::False => parser.shift(450),
            TokenType::Function => parser.shift(649),
            TokenType::Nil => parser.shift(451),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(452),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(609),
            TokenType::LCurly => parser.shift(650),
            TokenType::Dots => parser.shift(455),
            TokenType::Var => parser.goto(647),
            TokenType::Explist => parser.goto(714),
            TokenType::Exp => parser.goto(446),
            TokenType::Prefixexp => parser.goto(405),
            TokenType::Functioncall => parser.goto(648),
            TokenType::Functiondef => parser.goto(500),
            TokenType::Tableconstructor => parser.goto(501),
            TokenType::Unop => parser.goto(509),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<422> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(735),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<423> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(736),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<424> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(723),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<425> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<426> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(158),
            TokenType::String(_) => parser.shift(198),
            TokenType::Integer(_) => parser.shift(200),
            TokenType::Float(_) => parser.shift(202),
            TokenType::False => parser.shift(203),
            TokenType::Function => parser.shift(347),
            TokenType::Nil => parser.shift(204),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(205),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(329),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(206),
            TokenType::Var => parser.goto(339),
            TokenType::Exp => parser.goto(767),
            TokenType::Prefixexp => parser.goto(169),
            TokenType::Functioncall => parser.goto(341),
            TokenType::Functiondef => parser.goto(256),
            TokenType::Tableconstructor => parser.goto(257),
            TokenType::Unop => parser.goto(260),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<427> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(760),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<428> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<12>(),
            TokenType::Break => parser.reduce::<12>(),
            TokenType::Do => parser.reduce::<12>(),
            TokenType::End => parser.reduce::<12>(),
            TokenType::For => parser.reduce::<12>(),
            TokenType::Function => parser.reduce::<12>(),
            TokenType::Goto => parser.reduce::<12>(),
            TokenType::If => parser.reduce::<12>(),
            TokenType::Local => parser.reduce::<12>(),
            TokenType::Repeat => parser.reduce::<12>(),
            TokenType::Return => parser.reduce::<12>(),
            TokenType::While => parser.reduce::<12>(),
            TokenType::LParen => parser.reduce::<12>(),
            TokenType::DoubleColon => parser.reduce::<12>(),
            TokenType::SemiColon => parser.reduce::<12>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<429> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<12>(),
            TokenType::Break => parser.reduce::<12>(),
            TokenType::Do => parser.reduce::<12>(),
            TokenType::For => parser.reduce::<12>(),
            TokenType::Function => parser.reduce::<12>(),
            TokenType::Goto => parser.reduce::<12>(),
            TokenType::If => parser.reduce::<12>(),
            TokenType::Local => parser.reduce::<12>(),
            TokenType::Repeat => parser.reduce::<12>(),
            TokenType::Return => parser.reduce::<12>(),
            TokenType::Until => parser.reduce::<12>(),
            TokenType::While => parser.reduce::<12>(),
            TokenType::LParen => parser.reduce::<12>(),
            TokenType::DoubleColon => parser.reduce::<12>(),
            TokenType::SemiColon => parser.reduce::<12>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<430> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<38>(),
            TokenType::Break => parser.reduce::<38>(),
            TokenType::Do => parser.reduce::<38>(),
            TokenType::End => parser.reduce::<38>(),
            TokenType::For => parser.reduce::<38>(),
            TokenType::Function => parser.reduce::<38>(),
            TokenType::Goto => parser.reduce::<38>(),
            TokenType::If => parser.reduce::<38>(),
            TokenType::Local => parser.reduce::<38>(),
            TokenType::Repeat => parser.reduce::<38>(),
            TokenType::Return => parser.reduce::<38>(),
            TokenType::While => parser.reduce::<38>(),
            TokenType::LParen => parser.reduce::<38>(),
            TokenType::DoubleColon => parser.reduce::<38>(),
            TokenType::SemiColon => parser.reduce::<38>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<431> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::End => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            TokenType::Comma => parser.shift(719),
            TokenType::AttnamelistCont => parser.goto(717),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<432> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(718),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<433> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<10>(),
            TokenType::Break => parser.reduce::<10>(),
            TokenType::Do => parser.reduce::<10>(),
            TokenType::Else => parser.reduce::<10>(),
            TokenType::Elseif => parser.reduce::<10>(),
            TokenType::End => parser.reduce::<10>(),
            TokenType::For => parser.reduce::<10>(),
            TokenType::Function => parser.reduce::<10>(),
            TokenType::Goto => parser.reduce::<10>(),
            TokenType::If => parser.reduce::<10>(),
            TokenType::Local => parser.reduce::<10>(),
            TokenType::Repeat => parser.reduce::<10>(),
            TokenType::Return => parser.reduce::<10>(),
            TokenType::While => parser.reduce::<10>(),
            TokenType::LParen => parser.reduce::<10>(),
            TokenType::DoubleColon => parser.reduce::<10>(),
            TokenType::SemiColon => parser.reduce::<10>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<434> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<14>(),
            TokenType::And => parser.shift(283),
            TokenType::Break => parser.reduce::<14>(),
            TokenType::Do => parser.reduce::<14>(),
            TokenType::For => parser.reduce::<14>(),
            TokenType::Function => parser.reduce::<14>(),
            TokenType::Goto => parser.reduce::<14>(),
            TokenType::If => parser.reduce::<14>(),
            TokenType::Local => parser.reduce::<14>(),
            TokenType::Or => parser.shift(284),
            TokenType::Repeat => parser.reduce::<14>(),
            TokenType::Return => parser.reduce::<14>(),
            TokenType::While => parser.reduce::<14>(),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::LParen => parser.reduce::<14>(),
            TokenType::DoubleColon => parser.reduce::<14>(),
            TokenType::SemiColon => parser.reduce::<14>(),
            TokenType::Concat => parser.shift(311),
            TokenType::Eof => parser.reduce::<14>(),
            TokenType::Binop => parser.goto(737),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<435> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Exp => parser.goto(807),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<436> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(769),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<437> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(724),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<438> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(768),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<439> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(479),
            TokenType::String(_) => parser.shift(595),
            TokenType::Integer(_) => parser.shift(597),
            TokenType::Float(_) => parser.shift(598),
            TokenType::False => parser.shift(599),
            TokenType::Function => parser.shift(680),
            TokenType::Nil => parser.shift(600),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(601),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(667),
            TokenType::LCurly => parser.shift(681),
            TokenType::Dots => parser.shift(602),
            TokenType::Var => parser.goto(678),
            TokenType::Explist => parser.goto(731),
            TokenType::Exp => parser.goto(571),
            TokenType::Prefixexp => parser.goto(482),
            TokenType::Functioncall => parser.goto(679),
            TokenType::Functiondef => parser.goto(632),
            TokenType::Tableconstructor => parser.goto(633),
            TokenType::Unop => parser.goto(640),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<440> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(749),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<441> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(467),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LCurly => parser.shift(359),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(841),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<442> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<51>(),
            TokenType::Comma => parser.shift(250),
            TokenType::NamelistCont => parser.goto(748),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<443> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(307),
            TokenType::LParen => parser.shift(312),
            TokenType::LCurly => parser.shift(337),
            TokenType::Args => parser.goto(764),
            TokenType::Tableconstructor => parser.goto(336),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<444> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::RParen => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<445> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Exp => parser.goto(793),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<446> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Comma => parser.shift(730),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(720),
            TokenType::Binop => parser.goto(733),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<447> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<448> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<449> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<450> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<451> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<56>(),
            TokenType::Do => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::Comma => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<452> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<453> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Comma => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<454> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::End => parser.reduce::<54>(),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(757),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(739),
            TokenType::Binop => parser.goto(783),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<455> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<456> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(753),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<457> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(886),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.shift(900),
            TokenType::LSquare => parser.shift(754),
            TokenType::LCurly => parser.shift(936),
            TokenType::Colon => parser.shift(884),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Dot => parser.shift(883),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(885),
            TokenType::Tableconstructor => parser.goto(934),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<458> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<459> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<460> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<461> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::End => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<462> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<56>(),
            TokenType::End => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Comma => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<463> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<464> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Then => parser.reduce::<66>(),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<465> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<466> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(158),
            TokenType::String(_) => parser.shift(198),
            TokenType::Integer(_) => parser.shift(200),
            TokenType::Float(_) => parser.shift(202),
            TokenType::False => parser.shift(203),
            TokenType::Function => parser.shift(347),
            TokenType::Nil => parser.shift(204),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(205),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(329),
            TokenType::LCurly => parser.shift(351),
            TokenType::Dots => parser.shift(206),
            TokenType::Var => parser.goto(339),
            TokenType::Exp => parser.goto(825),
            TokenType::Prefixexp => parser.goto(169),
            TokenType::Functioncall => parser.goto(341),
            TokenType::Functiondef => parser.goto(256),
            TokenType::Tableconstructor => parser.goto(257),
            TokenType::Unop => parser.goto(260),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<467> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::RCurly => parser.reduce::<47>(),
            TokenType::SemiColon => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Comma => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<468> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(277),
            TokenType::LParen => parser.shift(278),
            TokenType::LCurly => parser.shift(335),
            TokenType::Args => parser.goto(781),
            TokenType::Tableconstructor => parser.goto(334),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<469> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<470> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<38>(),
            TokenType::Break => parser.reduce::<38>(),
            TokenType::Do => parser.reduce::<38>(),
            TokenType::For => parser.reduce::<38>(),
            TokenType::Function => parser.reduce::<38>(),
            TokenType::Goto => parser.reduce::<38>(),
            TokenType::If => parser.reduce::<38>(),
            TokenType::Local => parser.reduce::<38>(),
            TokenType::Repeat => parser.reduce::<38>(),
            TokenType::Return => parser.reduce::<38>(),
            TokenType::Until => parser.reduce::<38>(),
            TokenType::While => parser.reduce::<38>(),
            TokenType::LParen => parser.reduce::<38>(),
            TokenType::DoubleColon => parser.reduce::<38>(),
            TokenType::SemiColon => parser.reduce::<38>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<471> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<472> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<473> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<474> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::Comma => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<475> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<476> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<477> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Until => parser.reduce::<54>(),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(758),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(741),
            TokenType::Binop => parser.goto(771),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<478> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<7>(),
            TokenType::Break => parser.reduce::<7>(),
            TokenType::Do => parser.reduce::<7>(),
            TokenType::For => parser.reduce::<7>(),
            TokenType::Function => parser.reduce::<7>(),
            TokenType::Goto => parser.reduce::<7>(),
            TokenType::If => parser.reduce::<7>(),
            TokenType::Local => parser.reduce::<7>(),
            TokenType::Repeat => parser.reduce::<7>(),
            TokenType::Return => parser.reduce::<7>(),
            TokenType::Until => parser.reduce::<7>(),
            TokenType::While => parser.reduce::<7>(),
            TokenType::LParen => parser.reduce::<7>(),
            TokenType::DoubleColon => parser.reduce::<7>(),
            TokenType::SemiColon => parser.reduce::<7>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<479> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<47>(),
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Break => parser.reduce::<47>(),
            TokenType::Do => parser.reduce::<47>(),
            TokenType::For => parser.reduce::<47>(),
            TokenType::Function => parser.reduce::<47>(),
            TokenType::Goto => parser.reduce::<47>(),
            TokenType::If => parser.reduce::<47>(),
            TokenType::Local => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Repeat => parser.reduce::<47>(),
            TokenType::Return => parser.reduce::<47>(),
            TokenType::Until => parser.reduce::<47>(),
            TokenType::While => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::DoubleColon => parser.reduce::<47>(),
            TokenType::SemiColon => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Comma => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<480> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Until => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<481> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Until => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<482> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::String(_) => parser.shift(920),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::Until => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            // Shift(922)-Reduce(64)
            TokenType::LParen => parser.shift(922),
            TokenType::LSquare => parser.shift(770),
            TokenType::LCurly => parser.shift(941),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Colon => parser.shift(916),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Dot => parser.shift(914),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(919),
            TokenType::Tableconstructor => parser.goto(940),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<483> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Until => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<484> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Until => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<485> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(751),
            TokenType::Namelist => parser.goto(752),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<486> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::RSquare => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<487> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(36),
            TokenType::Funcname => parser.goto(786),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<488> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(756),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<489> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(759),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<490> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<25>(),
            TokenType::Break => parser.reduce::<25>(),
            TokenType::Do => parser.reduce::<25>(),
            TokenType::End => parser.reduce::<25>(),
            TokenType::For => parser.reduce::<25>(),
            TokenType::Function => parser.reduce::<25>(),
            TokenType::Goto => parser.reduce::<25>(),
            TokenType::If => parser.reduce::<25>(),
            TokenType::Local => parser.reduce::<25>(),
            TokenType::Repeat => parser.reduce::<25>(),
            TokenType::Return => parser.reduce::<25>(),
            TokenType::While => parser.reduce::<25>(),
            TokenType::LParen => parser.reduce::<25>(),
            TokenType::DoubleColon => parser.reduce::<25>(),
            TokenType::SemiColon => parser.reduce::<25>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<491> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(755),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<492> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<493> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<494> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(923),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<495> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Until => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Comma => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<496> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Until => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<497> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(949),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<498> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Until => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<499> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Then => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<500> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<501> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<502> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(59),
            TokenType::String(_) => parser.shift(76),
            TokenType::Integer(_) => parser.shift(77),
            TokenType::Float(_) => parser.shift(78),
            TokenType::False => parser.shift(79),
            TokenType::Function => parser.shift(132),
            TokenType::Nil => parser.shift(80),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(81),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(122),
            TokenType::LCurly => parser.shift(134),
            TokenType::Dots => parser.shift(82),
            TokenType::Var => parser.goto(126),
            TokenType::Exp => parser.goto(746),
            TokenType::Prefixexp => parser.goto(60),
            TokenType::Functioncall => parser.goto(127),
            TokenType::Functiondef => parser.goto(94),
            TokenType::Tableconstructor => parser.goto(95),
            TokenType::Unop => parser.goto(98),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<503> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(766),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<504> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(622),
            TokenType::Integer(_) => parser.shift(623),
            TokenType::Float(_) => parser.shift(624),
            TokenType::False => parser.shift(625),
            TokenType::Function => parser.shift(692),
            TokenType::Nil => parser.shift(626),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(627),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(684),
            TokenType::LCurly => parser.shift(693),
            TokenType::Dots => parser.shift(628),
            TokenType::Var => parser.goto(690),
            TokenType::Explist => parser.goto(784),
            TokenType::Exp => parser.goto(607),
            TokenType::Prefixexp => parser.goto(521),
            TokenType::Functioncall => parser.goto(691),
            TokenType::Functiondef => parser.goto(654),
            TokenType::Tableconstructor => parser.goto(655),
            TokenType::Unop => parser.goto(657),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<505> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<47>(),
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Break => parser.reduce::<47>(),
            TokenType::Do => parser.reduce::<47>(),
            TokenType::For => parser.reduce::<47>(),
            TokenType::Function => parser.reduce::<47>(),
            TokenType::Goto => parser.reduce::<47>(),
            TokenType::If => parser.reduce::<47>(),
            TokenType::Local => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Repeat => parser.reduce::<47>(),
            TokenType::Return => parser.reduce::<47>(),
            TokenType::While => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::DoubleColon => parser.reduce::<47>(),
            TokenType::SemiColon => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            TokenType::Eof => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<506> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<507> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<508> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::String(_) => parser.shift(890),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            // Shift(894)-Reduce(64)
            TokenType::LParen => parser.shift(894),
            TokenType::LSquare => parser.shift(773),
            TokenType::LCurly => parser.shift(945),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Colon => parser.shift(888),
            TokenType::Dot => parser.shift(887),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Eof => parser.reduce::<64>(),
            TokenType::Args => parser.goto(889),
            TokenType::Tableconstructor => parser.goto(944),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<509> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(396),
            TokenType::String(_) => parser.shift(447),
            TokenType::Integer(_) => parser.shift(448),
            TokenType::Float(_) => parser.shift(449),
            TokenType::False => parser.shift(450),
            TokenType::Function => parser.shift(649),
            TokenType::Nil => parser.shift(451),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(452),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(609),
            TokenType::LCurly => parser.shift(650),
            TokenType::Dots => parser.shift(455),
            TokenType::Var => parser.goto(647),
            TokenType::Exp => parser.goto(826),
            TokenType::Prefixexp => parser.goto(405),
            TokenType::Functioncall => parser.goto(648),
            TokenType::Functiondef => parser.goto(500),
            TokenType::Tableconstructor => parser.goto(501),
            TokenType::Unop => parser.goto(509),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<510> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(397),
            TokenType::String(_) => parser.shift(458),
            TokenType::Integer(_) => parser.shift(459),
            TokenType::Float(_) => parser.shift(460),
            TokenType::False => parser.shift(461),
            TokenType::Function => parser.shift(659),
            TokenType::Nil => parser.shift(462),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(463),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(613),
            TokenType::LCurly => parser.shift(660),
            TokenType::Dots => parser.shift(465),
            TokenType::Var => parser.goto(652),
            TokenType::Exp => parser.goto(824),
            TokenType::Prefixexp => parser.goto(406),
            TokenType::Functioncall => parser.goto(653),
            TokenType::Functiondef => parser.goto(506),
            TokenType::Tableconstructor => parser.goto(507),
            TokenType::Unop => parser.goto(510),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<511> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<512> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<513> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::RCurly => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(527),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<514> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(269),
            TokenType::LParen => parser.shift(270),
            TokenType::LCurly => parser.shift(326),
            TokenType::Args => parser.goto(744),
            TokenType::Tableconstructor => parser.goto(325),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<515> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(453),
            TokenType::String(_) => parser.shift(469),
            TokenType::Integer(_) => parser.shift(471),
            TokenType::Float(_) => parser.shift(472),
            TokenType::False => parser.shift(473),
            TokenType::Function => parser.shift(630),
            TokenType::Nil => parser.shift(474),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(475),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(577),
            TokenType::LCurly => parser.shift(631),
            TokenType::Dots => parser.shift(476),
            TokenType::Var => parser.goto(617),
            TokenType::Exp => parser.goto(842),
            TokenType::Prefixexp => parser.goto(457),
            TokenType::Functioncall => parser.goto(618),
            TokenType::Functiondef => parser.goto(511),
            TokenType::Tableconstructor => parser.goto(512),
            TokenType::Unop => parser.goto(515),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<516> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(220),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<517> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<7>(),
            TokenType::Break => parser.reduce::<7>(),
            TokenType::Do => parser.reduce::<7>(),
            TokenType::End => parser.reduce::<7>(),
            TokenType::For => parser.reduce::<7>(),
            TokenType::Function => parser.reduce::<7>(),
            TokenType::Goto => parser.reduce::<7>(),
            TokenType::If => parser.reduce::<7>(),
            TokenType::Local => parser.reduce::<7>(),
            TokenType::Repeat => parser.reduce::<7>(),
            TokenType::Return => parser.reduce::<7>(),
            TokenType::While => parser.reduce::<7>(),
            TokenType::LParen => parser.reduce::<7>(),
            TokenType::DoubleColon => parser.reduce::<7>(),
            TokenType::SemiColon => parser.reduce::<7>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<518> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<53>(),
            TokenType::Break => parser.reduce::<53>(),
            TokenType::Do => parser.reduce::<53>(),
            TokenType::For => parser.reduce::<53>(),
            TokenType::Function => parser.reduce::<53>(),
            TokenType::Goto => parser.reduce::<53>(),
            TokenType::If => parser.reduce::<53>(),
            TokenType::Local => parser.reduce::<53>(),
            TokenType::Repeat => parser.reduce::<53>(),
            TokenType::Return => parser.reduce::<53>(),
            TokenType::While => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::DoubleColon => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            TokenType::Eof => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<519> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<47>(),
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Break => parser.reduce::<47>(),
            TokenType::Do => parser.reduce::<47>(),
            TokenType::End => parser.reduce::<47>(),
            TokenType::For => parser.reduce::<47>(),
            TokenType::Function => parser.reduce::<47>(),
            TokenType::Goto => parser.reduce::<47>(),
            TokenType::If => parser.reduce::<47>(),
            TokenType::Local => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Repeat => parser.reduce::<47>(),
            TokenType::Return => parser.reduce::<47>(),
            TokenType::While => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::DoubleColon => parser.reduce::<47>(),
            TokenType::SemiColon => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Comma => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<520> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<521> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::String(_) => parser.shift(912),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            // Shift(918)-Reduce(64)
            TokenType::LParen => parser.shift(918),
            TokenType::LSquare => parser.shift(801),
            TokenType::LCurly => parser.shift(943),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Colon => parser.shift(910),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Dot => parser.shift(909),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(911),
            TokenType::Tableconstructor => parser.goto(942),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<522> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<523> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(323),
            TokenType::LParen => parser.shift(324),
            TokenType::LCurly => parser.shift(343),
            TokenType::Args => parser.goto(765),
            TokenType::Tableconstructor => parser.goto(338),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<524> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            TokenType::Eof => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<525> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(750),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<526> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(958),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<527> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(467),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LCurly => parser.shift(359),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(827),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<528> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::RParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<529> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            TokenType::Eof => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<530> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<531> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(317),
            TokenType::LParen => parser.shift(319),
            TokenType::LCurly => parser.shift(353),
            TokenType::Args => parser.goto(742),
            TokenType::Tableconstructor => parser.goto(352),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<532> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::RParen => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<533> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::RSquare => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<534> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Then => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<535> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(837),
            TokenType::String(_) => parser.shift(872),
            TokenType::Integer(_) => parser.shift(875),
            TokenType::Float(_) => parser.shift(876),
            TokenType::False => parser.shift(877),
            TokenType::Function => parser.shift(969),
            TokenType::Nil => parser.shift(878),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(879),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(953),
            TokenType::LCurly => parser.shift(971),
            TokenType::Dots => parser.shift(880),
            TokenType::Var => parser.goto(965),
            TokenType::Exp => parser.goto(787),
            TokenType::Prefixexp => parser.goto(838),
            TokenType::Functioncall => parser.goto(966),
            TokenType::Functiondef => parser.goto(927),
            TokenType::Tableconstructor => parser.goto(928),
            TokenType::Unop => parser.goto(931),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<536> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Eof => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<537> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<90>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<538> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(279),
            TokenType::Integer(_) => parser.shift(280),
            TokenType::Float(_) => parser.shift(281),
            TokenType::False => parser.shift(291),
            TokenType::Function => parser.shift(370),
            TokenType::Nil => parser.shift(292),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(293),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(364),
            TokenType::LCurly => parser.shift(371),
            TokenType::Dots => parser.shift(296),
            TokenType::Var => parser.goto(368),
            TokenType::Exp => parser.goto(861),
            TokenType::Prefixexp => parser.goto(175),
            TokenType::Functioncall => parser.goto(369),
            TokenType::Functiondef => parser.goto(330),
            TokenType::Tableconstructor => parser.goto(331),
            TokenType::Unop => parser.goto(333),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<539> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<93>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::Field => parser.goto(973),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<540> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Eof => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<541> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Until => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<542> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<98>(),
            TokenType::String(_) => parser.reduce::<98>(),
            TokenType::Integer(_) => parser.reduce::<98>(),
            TokenType::Float(_) => parser.reduce::<98>(),
            TokenType::False => parser.reduce::<98>(),
            TokenType::Function => parser.reduce::<98>(),
            TokenType::Nil => parser.reduce::<98>(),
            TokenType::Not => parser.reduce::<98>(),
            TokenType::True => parser.reduce::<98>(),
            TokenType::Sub => parser.reduce::<98>(),
            TokenType::Len => parser.reduce::<98>(),
            TokenType::BitXor => parser.reduce::<98>(),
            TokenType::LParen => parser.reduce::<98>(),
            TokenType::LSquare => parser.reduce::<98>(),
            TokenType::LCurly => parser.reduce::<98>(),
            TokenType::RCurly => parser.reduce::<98>(),
            TokenType::Dots => parser.reduce::<98>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<543> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<97>(),
            TokenType::String(_) => parser.reduce::<97>(),
            TokenType::Integer(_) => parser.reduce::<97>(),
            TokenType::Float(_) => parser.reduce::<97>(),
            TokenType::False => parser.reduce::<97>(),
            TokenType::Function => parser.reduce::<97>(),
            TokenType::Nil => parser.reduce::<97>(),
            TokenType::Not => parser.reduce::<97>(),
            TokenType::True => parser.reduce::<97>(),
            TokenType::Sub => parser.reduce::<97>(),
            TokenType::Len => parser.reduce::<97>(),
            TokenType::BitXor => parser.reduce::<97>(),
            TokenType::LParen => parser.reduce::<97>(),
            TokenType::LSquare => parser.reduce::<97>(),
            TokenType::LCurly => parser.reduce::<97>(),
            TokenType::RCurly => parser.reduce::<97>(),
            TokenType::Dots => parser.reduce::<97>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<544> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(845),
            TokenType::String(_) => parser.shift(864),
            TokenType::Integer(_) => parser.shift(865),
            TokenType::Float(_) => parser.shift(866),
            TokenType::False => parser.shift(867),
            TokenType::Function => parser.shift(970),
            TokenType::Nil => parser.shift(868),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(869),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(952),
            TokenType::LCurly => parser.shift(972),
            TokenType::Dots => parser.shift(870),
            TokenType::Var => parser.goto(967),
            TokenType::Exp => parser.goto(811),
            TokenType::Prefixexp => parser.goto(846),
            TokenType::Functioncall => parser.goto(968),
            TokenType::Functiondef => parser.goto(924),
            TokenType::Tableconstructor => parser.goto(925),
            TokenType::Unop => parser.goto(926),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<545> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Until => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<546> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::RParen => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<547> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(856),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<548> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(800),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<549> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.shift(740),
            TokenType::Elseif => parser.shift(798),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatIf => parser.goto(738),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<550> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(777),
            TokenType::Function => parser.shift(775),
            TokenType::Attnamelist => parser.goto(776),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<551> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(745),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<552> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Eof => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<553> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(743),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<554> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            TokenType::Eof => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<555> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(46),
            TokenType::Do => parser.shift(48),
            TokenType::For => parser.shift(66),
            TokenType::Function => parser.shift(68),
            TokenType::Goto => parser.shift(69),
            TokenType::If => parser.shift(71),
            TokenType::Local => parser.shift(101),
            TokenType::Repeat => parser.shift(103),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::Until => parser.reduce::<2>(),
            TokenType::While => parser.shift(106),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(119),
            TokenType::SemiColon => parser.shift(115),
            TokenType::Block => parser.goto(908),
            TokenType::BlockStat => parser.goto(26),
            TokenType::Stat => parser.goto(42),
            TokenType::Label => parser.goto(116),
            TokenType::Varlist => parser.goto(117),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(120),
            TokenType::Functioncall => parser.goto(118),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<556> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::RCurly => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<557> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(816),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<558> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(761),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<559> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(762),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<560> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(785),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<561> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(747),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<562> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::RSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<563> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::RSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<564> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(946),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<565> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(937),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<566> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(401),
            TokenType::String(_) => parser.shift(480),
            TokenType::Integer(_) => parser.shift(481),
            TokenType::Float(_) => parser.shift(483),
            TokenType::False => parser.shift(484),
            TokenType::Function => parser.shift(669),
            TokenType::Nil => parser.shift(495),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(496),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(646),
            TokenType::LCurly => parser.shift(670),
            TokenType::Dots => parser.shift(498),
            TokenType::Var => parser.goto(665),
            TokenType::Exp => parser.goto(848),
            TokenType::Prefixexp => parser.goto(408),
            TokenType::Functioncall => parser.goto(666),
            TokenType::Functiondef => parser.goto(541),
            TokenType::Tableconstructor => parser.goto(545),
            TokenType::Unop => parser.goto(566),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<567> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(790),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<568> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(774),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<569> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::RCurly => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<570> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::RCurly => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<571> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::And => parser.shift(283),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.shift(284),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::Until => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(810),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(792),
            TokenType::Binop => parser.goto(860),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<572> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(947),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<573> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::RParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<574> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Eof => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(616),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<575> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Eof => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(466),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<576> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(857),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<577> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(805),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<578> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<579> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(844),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<580> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(873),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<581> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(858),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<582> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(782),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<583> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(772),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<584> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::RParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<585> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::RParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<586> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(852),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<587> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(935),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<588> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            TokenType::Eof => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<589> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            TokenType::Eof => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<590> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            TokenType::Eof => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<591> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            TokenType::Eof => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<592> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<56>(),
            TokenType::And => parser.reduce::<56>(),
            TokenType::Break => parser.reduce::<56>(),
            TokenType::Do => parser.reduce::<56>(),
            TokenType::For => parser.reduce::<56>(),
            TokenType::Function => parser.reduce::<56>(),
            TokenType::Goto => parser.reduce::<56>(),
            TokenType::If => parser.reduce::<56>(),
            TokenType::Local => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Repeat => parser.reduce::<56>(),
            TokenType::Return => parser.reduce::<56>(),
            TokenType::While => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::LParen => parser.reduce::<56>(),
            TokenType::DoubleColon => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            TokenType::Eof => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<593> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            TokenType::Eof => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<594> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            TokenType::Eof => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<595> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::Until => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<596> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::RParen => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(445),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<597> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::Until => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<598> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::Until => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<599> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::Until => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<600> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<56>(),
            TokenType::And => parser.reduce::<56>(),
            TokenType::Break => parser.reduce::<56>(),
            TokenType::Do => parser.reduce::<56>(),
            TokenType::For => parser.reduce::<56>(),
            TokenType::Function => parser.reduce::<56>(),
            TokenType::Goto => parser.reduce::<56>(),
            TokenType::If => parser.reduce::<56>(),
            TokenType::Local => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Repeat => parser.reduce::<56>(),
            TokenType::Return => parser.reduce::<56>(),
            TokenType::Until => parser.reduce::<56>(),
            TokenType::While => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::LParen => parser.reduce::<56>(),
            TokenType::DoubleColon => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Comma => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<601> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::Until => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<602> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::Until => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<603> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(61),
            TokenType::String(_) => parser.shift(83),
            TokenType::Integer(_) => parser.shift(84),
            TokenType::Float(_) => parser.shift(85),
            TokenType::False => parser.shift(86),
            TokenType::Function => parser.shift(133),
            TokenType::Nil => parser.shift(88),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(89),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(123),
            TokenType::LCurly => parser.shift(135),
            TokenType::Dots => parser.shift(90),
            TokenType::Var => parser.goto(128),
            TokenType::Exp => parser.goto(778),
            TokenType::Prefixexp => parser.goto(62),
            TokenType::Functioncall => parser.goto(129),
            TokenType::Functiondef => parser.goto(96),
            TokenType::Tableconstructor => parser.goto(97),
            TokenType::Unop => parser.goto(99),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<604> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::RCurly => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<605> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(956),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<606> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Then => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<607> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::And => parser.shift(283),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.shift(284),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(853),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(834),
            TokenType::Binop => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<608> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(779),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<609> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(843),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<610> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(791),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<611> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(799),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<612> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Eof => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<613> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(836),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<614> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            TokenType::Eof => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<615> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(950),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<616> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(160),
            TokenType::String(_) => parser.shift(279),
            TokenType::Integer(_) => parser.shift(280),
            TokenType::Float(_) => parser.shift(281),
            TokenType::False => parser.shift(291),
            TokenType::Function => parser.shift(370),
            TokenType::Nil => parser.shift(292),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(293),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(364),
            TokenType::LCurly => parser.shift(371),
            TokenType::Dots => parser.shift(296),
            TokenType::Var => parser.goto(368),
            TokenType::Exp => parser.goto(863),
            TokenType::Prefixexp => parser.goto(175),
            TokenType::Functioncall => parser.goto(369),
            TokenType::Functiondef => parser.goto(330),
            TokenType::Tableconstructor => parser.goto(331),
            TokenType::Unop => parser.goto(333),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<617> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<618> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<619> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            TokenType::Eof => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<620> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(951),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<621> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::RSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<622> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<623> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<624> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<625> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::End => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<626> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<56>(),
            TokenType::And => parser.reduce::<56>(),
            TokenType::Break => parser.reduce::<56>(),
            TokenType::Do => parser.reduce::<56>(),
            TokenType::End => parser.reduce::<56>(),
            TokenType::For => parser.reduce::<56>(),
            TokenType::Function => parser.reduce::<56>(),
            TokenType::Goto => parser.reduce::<56>(),
            TokenType::If => parser.reduce::<56>(),
            TokenType::Local => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Repeat => parser.reduce::<56>(),
            TokenType::Return => parser.reduce::<56>(),
            TokenType::While => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::LParen => parser.reduce::<56>(),
            TokenType::DoubleColon => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Comma => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<627> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<628> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<629> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(955),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<630> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(789),
            TokenType::Funcbody => parser.goto(788),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<631> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(964),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<632> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::Until => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<633> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::Until => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<634> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<6>(),
            TokenType::Break => parser.reduce::<6>(),
            TokenType::Do => parser.reduce::<6>(),
            TokenType::Else => parser.reduce::<6>(),
            TokenType::Elseif => parser.reduce::<6>(),
            TokenType::End => parser.reduce::<6>(),
            TokenType::For => parser.reduce::<6>(),
            TokenType::Function => parser.reduce::<6>(),
            TokenType::Goto => parser.reduce::<6>(),
            TokenType::If => parser.reduce::<6>(),
            TokenType::Local => parser.reduce::<6>(),
            TokenType::Repeat => parser.reduce::<6>(),
            TokenType::Return => parser.reduce::<6>(),
            TokenType::While => parser.reduce::<6>(),
            TokenType::LParen => parser.reduce::<6>(),
            TokenType::DoubleColon => parser.reduce::<6>(),
            TokenType::SemiColon => parser.reduce::<6>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<635> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<9>(),
            TokenType::Break => parser.reduce::<9>(),
            TokenType::Do => parser.reduce::<9>(),
            TokenType::Else => parser.reduce::<9>(),
            TokenType::Elseif => parser.reduce::<9>(),
            TokenType::End => parser.reduce::<9>(),
            TokenType::For => parser.reduce::<9>(),
            TokenType::Function => parser.reduce::<9>(),
            TokenType::Goto => parser.reduce::<9>(),
            TokenType::If => parser.reduce::<9>(),
            TokenType::Local => parser.reduce::<9>(),
            TokenType::Repeat => parser.reduce::<9>(),
            TokenType::Return => parser.reduce::<9>(),
            TokenType::While => parser.reduce::<9>(),
            TokenType::LParen => parser.reduce::<9>(),
            TokenType::DoubleColon => parser.reduce::<9>(),
            TokenType::SemiColon => parser.reduce::<9>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<636> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(804),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<637> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<8>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<8>(),
            TokenType::Do => parser.reduce::<8>(),
            TokenType::Else => parser.reduce::<8>(),
            TokenType::Elseif => parser.reduce::<8>(),
            TokenType::End => parser.reduce::<8>(),
            TokenType::For => parser.reduce::<8>(),
            TokenType::Function => parser.reduce::<8>(),
            TokenType::Goto => parser.reduce::<8>(),
            TokenType::If => parser.reduce::<8>(),
            TokenType::Local => parser.reduce::<8>(),
            TokenType::Repeat => parser.reduce::<8>(),
            TokenType::Return => parser.reduce::<8>(),
            TokenType::While => parser.reduce::<8>(),
            // Reduce(8)-Reduce(69)
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<8>(),
            TokenType::SemiColon => parser.reduce::<8>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<638> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(809),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<639> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(854),
            TokenType::LParen => parser.shift(855),
            TokenType::LSquare => parser.shift(47),
            TokenType::LCurly => parser.shift(921),
            TokenType::Colon => parser.shift(850),
            TokenType::Dot => parser.shift(72),
            TokenType::Args => parser.goto(851),
            TokenType::Tableconstructor => parser.goto(917),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<640> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(479),
            TokenType::String(_) => parser.shift(595),
            TokenType::Integer(_) => parser.shift(597),
            TokenType::Float(_) => parser.shift(598),
            TokenType::False => parser.shift(599),
            TokenType::Function => parser.shift(680),
            TokenType::Nil => parser.shift(600),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(601),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(667),
            TokenType::LCurly => parser.shift(681),
            TokenType::Dots => parser.shift(602),
            TokenType::Var => parser.goto(678),
            TokenType::Exp => parser.goto(901),
            TokenType::Prefixexp => parser.goto(482),
            TokenType::Functioncall => parser.goto(679),
            TokenType::Functiondef => parser.goto(632),
            TokenType::Tableconstructor => parser.goto(633),
            TokenType::Unop => parser.goto(640),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<641> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            TokenType::Eof => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<642> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            TokenType::Eof => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<643> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(505),
            TokenType::String(_) => parser.shift(588),
            TokenType::Integer(_) => parser.shift(589),
            TokenType::Float(_) => parser.shift(590),
            TokenType::False => parser.shift(591),
            TokenType::Function => parser.shift(688),
            TokenType::Nil => parser.shift(592),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(593),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(676),
            TokenType::LCurly => parser.shift(689),
            TokenType::Dots => parser.shift(594),
            TokenType::Var => parser.goto(686),
            TokenType::Exp => parser.goto(874),
            TokenType::Prefixexp => parser.goto(508),
            TokenType::Functioncall => parser.goto(687),
            TokenType::Functiondef => parser.goto(641),
            TokenType::Tableconstructor => parser.goto(642),
            TokenType::Unop => parser.goto(643),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<644> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::RParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<645> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(959),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<646> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(839),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<647> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<648> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<649> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(820),
            TokenType::Funcbody => parser.goto(818),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<650> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(957),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<651> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(832),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<652> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<653> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<654> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<655> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<656> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            TokenType::Eof => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<657> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(622),
            TokenType::Integer(_) => parser.shift(623),
            TokenType::Float(_) => parser.shift(624),
            TokenType::False => parser.shift(625),
            TokenType::Function => parser.shift(692),
            TokenType::Nil => parser.shift(626),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(627),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(684),
            TokenType::LCurly => parser.shift(693),
            TokenType::Dots => parser.shift(628),
            TokenType::Var => parser.goto(690),
            TokenType::Exp => parser.goto(896),
            TokenType::Prefixexp => parser.goto(521),
            TokenType::Functioncall => parser.goto(691),
            TokenType::Functiondef => parser.goto(654),
            TokenType::Tableconstructor => parser.goto(655),
            TokenType::Unop => parser.goto(657),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<658> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(948),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<659> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(797),
            TokenType::Funcbody => parser.goto(796),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<660> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(961),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<661> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(794),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<662> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(795),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<663> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(808),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<664> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(815),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<665> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Until => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<666> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Until => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<667> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(840),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<668> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(847),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<669> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(822),
            TokenType::Funcbody => parser.goto(813),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<670> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(954),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<671> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(812),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<672> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(780),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<673> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(814),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<674> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(803),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<675> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(802),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<676> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(849),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<677> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(806),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<678> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::Until => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<679> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::Until => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<680> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(821),
            TokenType::Funcbody => parser.goto(819),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<681> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(960),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<682> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(833),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<683> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(823),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<684> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(862),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<685> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(817),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<686> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            TokenType::Eof => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<687> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            TokenType::Eof => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<688> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(829),
            TokenType::Funcbody => parser.goto(828),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<689> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(963),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<690> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<691> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<692> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(831),
            TokenType::Funcbody => parser.goto(830),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<693> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(962),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<694> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<43>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<695> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.reduce::<41>(),
            TokenType::Colon => parser.reduce::<41>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<696> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<82>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<697> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(975),
            TokenType::Dots => parser.shift(976),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<698> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Less => parser.shift(165),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            TokenType::Comma => parser.reduce::<31>(),
            TokenType::Eof => parser.reduce::<31>(),
            TokenType::Attrib => parser.goto(974),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<699> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(990),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<700> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<33>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<701> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            TokenType::Eof => parser.reduce::<32>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<702> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<37>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<703> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(981),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<704> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<1>(),
            TokenType::Elseif => parser.reduce::<1>(),
            TokenType::End => parser.reduce::<1>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<705> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<5>(),
            TokenType::Elseif => parser.reduce::<5>(),
            TokenType::End => parser.reduce::<5>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<706> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<33>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<707> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<37>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<708> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<24>(),
            TokenType::Break => parser.reduce::<24>(),
            TokenType::Do => parser.reduce::<24>(),
            TokenType::For => parser.reduce::<24>(),
            TokenType::Function => parser.reduce::<24>(),
            TokenType::Goto => parser.reduce::<24>(),
            TokenType::If => parser.reduce::<24>(),
            TokenType::Local => parser.reduce::<24>(),
            TokenType::Repeat => parser.reduce::<24>(),
            TokenType::Return => parser.reduce::<24>(),
            TokenType::Until => parser.reduce::<24>(),
            TokenType::While => parser.reduce::<24>(),
            TokenType::LParen => parser.reduce::<24>(),
            TokenType::DoubleColon => parser.reduce::<24>(),
            TokenType::SemiColon => parser.reduce::<24>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<709> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Greater => parser.shift(980),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<710> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<28>(),
            TokenType::Break => parser.reduce::<28>(),
            TokenType::Do => parser.reduce::<28>(),
            TokenType::For => parser.reduce::<28>(),
            TokenType::Function => parser.reduce::<28>(),
            TokenType::Goto => parser.reduce::<28>(),
            TokenType::If => parser.reduce::<28>(),
            TokenType::Local => parser.reduce::<28>(),
            TokenType::Repeat => parser.reduce::<28>(),
            TokenType::Return => parser.reduce::<28>(),
            TokenType::Until => parser.reduce::<28>(),
            TokenType::While => parser.reduce::<28>(),
            TokenType::Assign => parser.reduce::<28>(),
            TokenType::LParen => parser.reduce::<28>(),
            TokenType::DoubleColon => parser.reduce::<28>(),
            TokenType::SemiColon => parser.reduce::<28>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<711> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(977),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<712> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(987),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<713> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<24>(),
            TokenType::Break => parser.reduce::<24>(),
            TokenType::Do => parser.reduce::<24>(),
            TokenType::End => parser.reduce::<24>(),
            TokenType::For => parser.reduce::<24>(),
            TokenType::Function => parser.reduce::<24>(),
            TokenType::Goto => parser.reduce::<24>(),
            TokenType::If => parser.reduce::<24>(),
            TokenType::Local => parser.reduce::<24>(),
            TokenType::Repeat => parser.reduce::<24>(),
            TokenType::Return => parser.reduce::<24>(),
            TokenType::While => parser.reduce::<24>(),
            TokenType::LParen => parser.reduce::<24>(),
            TokenType::DoubleColon => parser.reduce::<24>(),
            TokenType::SemiColon => parser.reduce::<24>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<714> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(993),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<715> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1104),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<716> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1017),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<717> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<28>(),
            TokenType::Break => parser.reduce::<28>(),
            TokenType::Do => parser.reduce::<28>(),
            TokenType::End => parser.reduce::<28>(),
            TokenType::For => parser.reduce::<28>(),
            TokenType::Function => parser.reduce::<28>(),
            TokenType::Goto => parser.reduce::<28>(),
            TokenType::If => parser.reduce::<28>(),
            TokenType::Local => parser.reduce::<28>(),
            TokenType::Repeat => parser.reduce::<28>(),
            TokenType::Return => parser.reduce::<28>(),
            TokenType::While => parser.reduce::<28>(),
            TokenType::Assign => parser.reduce::<28>(),
            TokenType::LParen => parser.reduce::<28>(),
            TokenType::DoubleColon => parser.reduce::<28>(),
            TokenType::SemiColon => parser.reduce::<28>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<718> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Greater => parser.shift(978),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<719> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(979),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<720> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<721> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Comma => parser.shift(998),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(835),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<722> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Comma => parser.shift(997),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(835),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<723> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1098),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<724> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::RParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<725> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(1003),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<726> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(985),
            TokenType::String(_) => parser.shift(1023),
            TokenType::Integer(_) => parser.shift(1024),
            TokenType::Float(_) => parser.shift(1025),
            TokenType::Else => parser.reduce::<34>(),
            TokenType::Elseif => parser.reduce::<34>(),
            TokenType::End => parser.reduce::<34>(),
            TokenType::False => parser.shift(1026),
            TokenType::Function => parser.shift(1157),
            TokenType::Nil => parser.shift(1027),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1028),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1121),
            TokenType::LCurly => parser.shift(1158),
            TokenType::SemiColon => parser.reduce::<34>(),
            TokenType::Dots => parser.shift(1029),
            TokenType::RetstatExplist => parser.goto(982),
            TokenType::Var => parser.goto(1155),
            TokenType::Explist => parser.goto(983),
            TokenType::Exp => parser.goto(1020),
            TokenType::Prefixexp => parser.goto(1001),
            TokenType::Functioncall => parser.goto(1156),
            TokenType::Functiondef => parser.goto(1069),
            TokenType::Tableconstructor => parser.goto(1070),
            TokenType::Unop => parser.goto(1073),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<727> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(396),
            TokenType::String(_) => parser.shift(447),
            TokenType::Integer(_) => parser.shift(448),
            TokenType::Float(_) => parser.shift(449),
            TokenType::False => parser.shift(450),
            TokenType::Function => parser.shift(649),
            TokenType::Nil => parser.shift(451),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(452),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(609),
            TokenType::LCurly => parser.shift(650),
            TokenType::Dots => parser.shift(455),
            TokenType::Var => parser.goto(647),
            TokenType::Exp => parser.goto(994),
            TokenType::Prefixexp => parser.goto(405),
            TokenType::Functioncall => parser.goto(648),
            TokenType::Functiondef => parser.goto(500),
            TokenType::Tableconstructor => parser.goto(501),
            TokenType::Unop => parser.goto(509),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<728> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(1004),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<729> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(1002),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<730> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(396),
            TokenType::String(_) => parser.shift(447),
            TokenType::Integer(_) => parser.shift(448),
            TokenType::Float(_) => parser.shift(449),
            TokenType::False => parser.shift(450),
            TokenType::Function => parser.shift(649),
            TokenType::Nil => parser.shift(451),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(452),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(609),
            TokenType::LCurly => parser.shift(650),
            TokenType::Dots => parser.shift(455),
            TokenType::Var => parser.goto(647),
            TokenType::Exp => parser.goto(1008),
            TokenType::Prefixexp => parser.goto(405),
            TokenType::Functioncall => parser.goto(648),
            TokenType::Functiondef => parser.goto(500),
            TokenType::Tableconstructor => parser.goto(501),
            TokenType::Unop => parser.goto(509),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<731> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<27>(),
            TokenType::Break => parser.reduce::<27>(),
            TokenType::Do => parser.reduce::<27>(),
            TokenType::For => parser.reduce::<27>(),
            TokenType::Function => parser.reduce::<27>(),
            TokenType::Goto => parser.reduce::<27>(),
            TokenType::If => parser.reduce::<27>(),
            TokenType::Local => parser.reduce::<27>(),
            TokenType::Repeat => parser.reduce::<27>(),
            TokenType::Return => parser.reduce::<27>(),
            TokenType::Until => parser.reduce::<27>(),
            TokenType::While => parser.reduce::<27>(),
            TokenType::LParen => parser.reduce::<27>(),
            TokenType::DoubleColon => parser.reduce::<27>(),
            TokenType::SemiColon => parser.reduce::<27>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<732> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<3>(),
            TokenType::Elseif => parser.reduce::<3>(),
            TokenType::End => parser.reduce::<3>(),
            TokenType::Return => parser.reduce::<3>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<733> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(396),
            TokenType::String(_) => parser.shift(447),
            TokenType::Integer(_) => parser.shift(448),
            TokenType::Float(_) => parser.shift(449),
            TokenType::False => parser.shift(450),
            TokenType::Function => parser.shift(649),
            TokenType::Nil => parser.shift(451),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(452),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(609),
            TokenType::LCurly => parser.shift(650),
            TokenType::Dots => parser.shift(455),
            TokenType::Var => parser.goto(647),
            TokenType::Exp => parser.goto(1009),
            TokenType::Prefixexp => parser.goto(405),
            TokenType::Functioncall => parser.goto(648),
            TokenType::Functiondef => parser.goto(500),
            TokenType::Tableconstructor => parser.goto(501),
            TokenType::Unop => parser.goto(509),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<734> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(984),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<735> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(986),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<736> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(989),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<737> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(505),
            TokenType::String(_) => parser.shift(588),
            TokenType::Integer(_) => parser.shift(589),
            TokenType::Float(_) => parser.shift(590),
            TokenType::False => parser.shift(591),
            TokenType::Function => parser.shift(688),
            TokenType::Nil => parser.shift(592),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(593),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(676),
            TokenType::LCurly => parser.shift(689),
            TokenType::Dots => parser.shift(594),
            TokenType::Var => parser.goto(686),
            TokenType::Exp => parser.goto(1022),
            TokenType::Prefixexp => parser.goto(508),
            TokenType::Functioncall => parser.goto(687),
            TokenType::Functiondef => parser.goto(641),
            TokenType::Tableconstructor => parser.goto(642),
            TokenType::Unop => parser.goto(643),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<738> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(988),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<739> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<740> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1088),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<741> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<742> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::RParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<743> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::RSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<744> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::Until => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<745> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(554),
            TokenType::LParen => parser.shift(564),
            TokenType::LCurly => parser.shift(620),
            TokenType::Args => parser.goto(991),
            TokenType::Tableconstructor => parser.goto(619),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<746> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Then => parser.shift(996),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<747> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(563),
            TokenType::LParen => parser.shift(565),
            TokenType::LCurly => parser.shift(629),
            TokenType::Args => parser.goto(992),
            TokenType::Tableconstructor => parser.goto(621),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<748> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<52>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<749> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Then => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<750> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(995),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<751> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.reduce::<51>(),
            TokenType::Assign => parser.shift(999),
            TokenType::Comma => parser.shift(250),
            TokenType::NamelistCont => parser.goto(249),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<752> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::In => parser.shift(1000),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<753> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<754> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(1005),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<755> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1117),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<756> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<11>(),
            TokenType::Break => parser.reduce::<11>(),
            TokenType::Do => parser.reduce::<11>(),
            TokenType::Else => parser.reduce::<11>(),
            TokenType::Elseif => parser.reduce::<11>(),
            TokenType::End => parser.reduce::<11>(),
            TokenType::For => parser.reduce::<11>(),
            TokenType::Function => parser.reduce::<11>(),
            TokenType::Goto => parser.reduce::<11>(),
            TokenType::If => parser.reduce::<11>(),
            TokenType::Local => parser.reduce::<11>(),
            TokenType::Repeat => parser.reduce::<11>(),
            TokenType::Return => parser.reduce::<11>(),
            TokenType::While => parser.reduce::<11>(),
            TokenType::LParen => parser.reduce::<11>(),
            TokenType::DoubleColon => parser.reduce::<11>(),
            TokenType::SemiColon => parser.reduce::<11>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<757> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(397),
            TokenType::String(_) => parser.shift(458),
            TokenType::Integer(_) => parser.shift(459),
            TokenType::Float(_) => parser.shift(460),
            TokenType::False => parser.shift(461),
            TokenType::Function => parser.shift(659),
            TokenType::Nil => parser.shift(462),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(463),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(613),
            TokenType::LCurly => parser.shift(660),
            TokenType::Dots => parser.shift(465),
            TokenType::Var => parser.goto(652),
            TokenType::Exp => parser.goto(1035),
            TokenType::Prefixexp => parser.goto(406),
            TokenType::Functioncall => parser.goto(653),
            TokenType::Functiondef => parser.goto(506),
            TokenType::Tableconstructor => parser.goto(507),
            TokenType::Unop => parser.goto(510),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<758> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(401),
            TokenType::String(_) => parser.shift(480),
            TokenType::Integer(_) => parser.shift(481),
            TokenType::Float(_) => parser.shift(483),
            TokenType::False => parser.shift(484),
            TokenType::Function => parser.shift(669),
            TokenType::Nil => parser.shift(495),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(496),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(646),
            TokenType::LCurly => parser.shift(670),
            TokenType::Dots => parser.shift(498),
            TokenType::Var => parser.goto(665),
            TokenType::Exp => parser.goto(1038),
            TokenType::Prefixexp => parser.goto(408),
            TokenType::Functioncall => parser.goto(666),
            TokenType::Functiondef => parser.goto(541),
            TokenType::Tableconstructor => parser.goto(545),
            TokenType::Unop => parser.goto(566),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<759> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(493),
            TokenType::LParen => parser.shift(497),
            TokenType::LCurly => parser.shift(526),
            TokenType::Args => parser.goto(1014),
            TokenType::Tableconstructor => parser.goto(520),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<760> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::RSquare => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<761> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1074),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<762> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1050),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<763> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(1042),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<764> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Then => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<765> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<766> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1152),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<767> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(426),
            TokenType::Concat => parser.shift(311),
            TokenType::Eof => parser.reduce::<54>(),
            TokenType::ExplistCont => parser.goto(1052),
            TokenType::Binop => parser.goto(466),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<768> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(1018),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<769> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1043),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<770> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(1013),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<771> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(401),
            TokenType::String(_) => parser.shift(480),
            TokenType::Integer(_) => parser.shift(481),
            TokenType::Float(_) => parser.shift(483),
            TokenType::False => parser.shift(484),
            TokenType::Function => parser.shift(669),
            TokenType::Nil => parser.shift(495),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(496),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(646),
            TokenType::LCurly => parser.shift(670),
            TokenType::Dots => parser.shift(498),
            TokenType::Var => parser.goto(665),
            TokenType::Exp => parser.goto(1039),
            TokenType::Prefixexp => parser.goto(408),
            TokenType::Functioncall => parser.goto(666),
            TokenType::Functiondef => parser.goto(541),
            TokenType::Tableconstructor => parser.goto(545),
            TokenType::Unop => parser.goto(566),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<772> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(585),
            TokenType::LParen => parser.shift(587),
            TokenType::LCurly => parser.shift(645),
            TokenType::Args => parser.goto(1067),
            TokenType::Tableconstructor => parser.goto(644),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<773> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(1055),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<774> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(570),
            TokenType::LParen => parser.shift(572),
            TokenType::LCurly => parser.shift(605),
            TokenType::Args => parser.goto(1109),
            TokenType::Tableconstructor => parser.goto(604),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<775> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1047),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<776> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<26>(),
            TokenType::Break => parser.reduce::<26>(),
            TokenType::Do => parser.reduce::<26>(),
            TokenType::Else => parser.reduce::<26>(),
            TokenType::Elseif => parser.reduce::<26>(),
            TokenType::End => parser.reduce::<26>(),
            TokenType::For => parser.reduce::<26>(),
            TokenType::Function => parser.reduce::<26>(),
            TokenType::Goto => parser.reduce::<26>(),
            TokenType::If => parser.reduce::<26>(),
            TokenType::Local => parser.reduce::<26>(),
            TokenType::Repeat => parser.reduce::<26>(),
            TokenType::Return => parser.reduce::<26>(),
            TokenType::While => parser.reduce::<26>(),
            TokenType::Assign => parser.shift(1068),
            TokenType::LParen => parser.reduce::<26>(),
            TokenType::DoubleColon => parser.reduce::<26>(),
            TokenType::SemiColon => parser.reduce::<26>(),
            TokenType::StatAttexplist => parser.goto(1058),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<777> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::Else => parser.reduce::<31>(),
            TokenType::Elseif => parser.reduce::<31>(),
            TokenType::End => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Less => parser.shift(1031),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            TokenType::Comma => parser.reduce::<31>(),
            TokenType::Attrib => parser.goto(1030),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<778> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Do => parser.shift(1049),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(220),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<779> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            TokenType::Eof => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<780> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Then => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<781> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<782> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::RParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<783> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(397),
            TokenType::String(_) => parser.shift(458),
            TokenType::Integer(_) => parser.shift(459),
            TokenType::Float(_) => parser.shift(460),
            TokenType::False => parser.shift(461),
            TokenType::Function => parser.shift(659),
            TokenType::Nil => parser.shift(462),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(463),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(613),
            TokenType::LCurly => parser.shift(660),
            TokenType::Dots => parser.shift(465),
            TokenType::Var => parser.goto(652),
            TokenType::Exp => parser.goto(1079),
            TokenType::Prefixexp => parser.goto(406),
            TokenType::Functioncall => parser.goto(653),
            TokenType::Functiondef => parser.goto(506),
            TokenType::Tableconstructor => parser.goto(507),
            TokenType::Unop => parser.goto(510),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<784> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<27>(),
            TokenType::Break => parser.reduce::<27>(),
            TokenType::Do => parser.reduce::<27>(),
            TokenType::End => parser.reduce::<27>(),
            TokenType::For => parser.reduce::<27>(),
            TokenType::Function => parser.reduce::<27>(),
            TokenType::Goto => parser.reduce::<27>(),
            TokenType::If => parser.reduce::<27>(),
            TokenType::Local => parser.reduce::<27>(),
            TokenType::Repeat => parser.reduce::<27>(),
            TokenType::Return => parser.reduce::<27>(),
            TokenType::While => parser.reduce::<27>(),
            TokenType::LParen => parser.reduce::<27>(),
            TokenType::DoubleColon => parser.reduce::<27>(),
            TokenType::SemiColon => parser.reduce::<27>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<785> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1106),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<786> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1054),
            TokenType::Funcbody => parser.goto(1053),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<787> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<14>(),
            TokenType::And => parser.shift(283),
            TokenType::Break => parser.reduce::<14>(),
            TokenType::Do => parser.reduce::<14>(),
            TokenType::End => parser.reduce::<14>(),
            TokenType::For => parser.reduce::<14>(),
            TokenType::Function => parser.reduce::<14>(),
            TokenType::Goto => parser.reduce::<14>(),
            TokenType::If => parser.reduce::<14>(),
            TokenType::Local => parser.reduce::<14>(),
            TokenType::Or => parser.shift(284),
            TokenType::Repeat => parser.reduce::<14>(),
            TokenType::Return => parser.reduce::<14>(),
            TokenType::While => parser.reduce::<14>(),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::LParen => parser.reduce::<14>(),
            TokenType::DoubleColon => parser.reduce::<14>(),
            TokenType::SemiColon => parser.reduce::<14>(),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(1122),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<788> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<789> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(1062),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<790> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::RCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<791> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(614),
            TokenType::LParen => parser.shift(615),
            TokenType::LCurly => parser.shift(658),
            TokenType::Args => parser.goto(1080),
            TokenType::Tableconstructor => parser.goto(656),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<792> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<53>(),
            TokenType::Break => parser.reduce::<53>(),
            TokenType::Do => parser.reduce::<53>(),
            TokenType::For => parser.reduce::<53>(),
            TokenType::Function => parser.reduce::<53>(),
            TokenType::Goto => parser.reduce::<53>(),
            TokenType::If => parser.reduce::<53>(),
            TokenType::Local => parser.reduce::<53>(),
            TokenType::Repeat => parser.reduce::<53>(),
            TokenType::Return => parser.reduce::<53>(),
            TokenType::Until => parser.reduce::<53>(),
            TokenType::While => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::DoubleColon => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<793> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::RParen => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(445),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<794> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<795> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::RCurly => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<796> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<797> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(1071),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<798> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(59),
            TokenType::String(_) => parser.shift(76),
            TokenType::Integer(_) => parser.shift(77),
            TokenType::Float(_) => parser.shift(78),
            TokenType::False => parser.shift(79),
            TokenType::Function => parser.shift(132),
            TokenType::Nil => parser.shift(80),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(81),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(122),
            TokenType::LCurly => parser.shift(134),
            TokenType::Dots => parser.shift(82),
            TokenType::Var => parser.goto(126),
            TokenType::Exp => parser.goto(1059),
            TokenType::Prefixexp => parser.goto(60),
            TokenType::Functioncall => parser.goto(127),
            TokenType::Functiondef => parser.goto(94),
            TokenType::Tableconstructor => parser.goto(95),
            TokenType::Unop => parser.goto(98),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<799> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<13>(),
            TokenType::Break => parser.reduce::<13>(),
            TokenType::Do => parser.reduce::<13>(),
            TokenType::For => parser.reduce::<13>(),
            TokenType::Function => parser.reduce::<13>(),
            TokenType::Goto => parser.reduce::<13>(),
            TokenType::If => parser.reduce::<13>(),
            TokenType::Local => parser.reduce::<13>(),
            TokenType::Repeat => parser.reduce::<13>(),
            TokenType::Return => parser.reduce::<13>(),
            TokenType::While => parser.reduce::<13>(),
            TokenType::LParen => parser.reduce::<13>(),
            TokenType::DoubleColon => parser.reduce::<13>(),
            TokenType::SemiColon => parser.reduce::<13>(),
            TokenType::Eof => parser.reduce::<13>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<800> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            TokenType::Eof => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<801> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(1012),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<802> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::RParen => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<803> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<804> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1064),
            TokenType::String(_) => parser.shift(1111),
            TokenType::Integer(_) => parser.shift(1112),
            TokenType::Float(_) => parser.shift(1113),
            TokenType::False => parser.shift(1114),
            TokenType::Function => parser.shift(1182),
            TokenType::Nil => parser.shift(1115),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1116),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1172),
            TokenType::LCurly => parser.shift(1183),
            TokenType::Dots => parser.shift(1118),
            TokenType::Var => parser.goto(1178),
            TokenType::Explist => parser.goto(1063),
            TokenType::Exp => parser.goto(1089),
            TokenType::Prefixexp => parser.goto(1065),
            TokenType::Functioncall => parser.goto(1179),
            TokenType::Functiondef => parser.goto(1149),
            TokenType::Tableconstructor => parser.goto(1150),
            TokenType::Unop => parser.goto(1153),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<805> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(1100),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<806> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Then => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<807> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(435),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(1056),
            TokenType::Binop => parser.goto(445),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<808> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::Until => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<809> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::DoubleColon => parser.shift(1006),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<810> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(479),
            TokenType::String(_) => parser.shift(595),
            TokenType::Integer(_) => parser.shift(597),
            TokenType::Float(_) => parser.shift(598),
            TokenType::False => parser.shift(599),
            TokenType::Function => parser.shift(680),
            TokenType::Nil => parser.shift(600),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(601),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(667),
            TokenType::LCurly => parser.shift(681),
            TokenType::Dots => parser.shift(602),
            TokenType::Var => parser.goto(678),
            TokenType::Exp => parser.goto(1086),
            TokenType::Prefixexp => parser.goto(482),
            TokenType::Functioncall => parser.goto(679),
            TokenType::Functiondef => parser.goto(632),
            TokenType::Tableconstructor => parser.goto(633),
            TokenType::Unop => parser.goto(640),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<811> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<14>(),
            TokenType::And => parser.shift(283),
            TokenType::Break => parser.reduce::<14>(),
            TokenType::Do => parser.reduce::<14>(),
            TokenType::For => parser.reduce::<14>(),
            TokenType::Function => parser.reduce::<14>(),
            TokenType::Goto => parser.reduce::<14>(),
            TokenType::If => parser.reduce::<14>(),
            TokenType::Local => parser.reduce::<14>(),
            TokenType::Or => parser.shift(284),
            TokenType::Repeat => parser.reduce::<14>(),
            TokenType::Return => parser.reduce::<14>(),
            TokenType::Until => parser.reduce::<14>(),
            TokenType::While => parser.reduce::<14>(),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::LParen => parser.reduce::<14>(),
            TokenType::DoubleColon => parser.reduce::<14>(),
            TokenType::SemiColon => parser.reduce::<14>(),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(1060),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<812> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<813> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Until => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<814> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::Until => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<815> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::RSquare => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<816> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1119),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<817> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            TokenType::Eof => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<818> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<819> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::Until => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<820> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(1078),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<821> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(1057),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<822> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(1061),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<823> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::RParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<824> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::End => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(783),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<825> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Eof => parser.reduce::<66>(),
            TokenType::Binop => parser.goto(466),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<826> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(733),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<827> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::RCurly => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(527),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<828> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            TokenType::Eof => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<829> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(1077),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<830> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<831> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(1066),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<832> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::RParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<833> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<834> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<53>(),
            TokenType::Break => parser.reduce::<53>(),
            TokenType::Do => parser.reduce::<53>(),
            TokenType::End => parser.reduce::<53>(),
            TokenType::For => parser.reduce::<53>(),
            TokenType::Function => parser.reduce::<53>(),
            TokenType::Goto => parser.reduce::<53>(),
            TokenType::If => parser.reduce::<53>(),
            TokenType::Local => parser.reduce::<53>(),
            TokenType::Repeat => parser.reduce::<53>(),
            TokenType::Return => parser.reduce::<53>(),
            TokenType::While => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::DoubleColon => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<835> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(453),
            TokenType::String(_) => parser.shift(469),
            TokenType::Integer(_) => parser.shift(471),
            TokenType::Float(_) => parser.shift(472),
            TokenType::False => parser.shift(473),
            TokenType::Function => parser.shift(630),
            TokenType::Nil => parser.shift(474),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(475),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(577),
            TokenType::LCurly => parser.shift(631),
            TokenType::Dots => parser.shift(476),
            TokenType::Var => parser.goto(617),
            TokenType::Exp => parser.goto(1082),
            TokenType::Prefixexp => parser.goto(457),
            TokenType::Functioncall => parser.goto(618),
            TokenType::Functiondef => parser.goto(511),
            TokenType::Tableconstructor => parser.goto(512),
            TokenType::Unop => parser.goto(515),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<836> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(1120),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<837> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<47>(),
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Break => parser.reduce::<47>(),
            TokenType::Do => parser.reduce::<47>(),
            TokenType::End => parser.reduce::<47>(),
            TokenType::For => parser.reduce::<47>(),
            TokenType::Function => parser.reduce::<47>(),
            TokenType::Goto => parser.reduce::<47>(),
            TokenType::If => parser.reduce::<47>(),
            TokenType::Local => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Repeat => parser.reduce::<47>(),
            TokenType::Return => parser.reduce::<47>(),
            TokenType::While => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::DoubleColon => parser.reduce::<47>(),
            TokenType::SemiColon => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<838> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::String(_) => parser.shift(1097),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            // Shift(1101)-Reduce(64)
            TokenType::LParen => parser.shift(1101),
            TokenType::LSquare => parser.shift(1046),
            TokenType::LCurly => parser.shift(1144),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Colon => parser.shift(1094),
            TokenType::Dot => parser.shift(1090),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(1095),
            TokenType::Tableconstructor => parser.goto(1143),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<839> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(1145),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<840> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(1110),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<841> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RCurly => parser.reduce::<95>(),
            TokenType::SemiColon => parser.reduce::<95>(),
            TokenType::Comma => parser.reduce::<95>(),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(527),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<842> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(835),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<843> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(1151),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<844> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Eof => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<845> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<47>(),
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Break => parser.reduce::<47>(),
            TokenType::Do => parser.reduce::<47>(),
            TokenType::For => parser.reduce::<47>(),
            TokenType::Function => parser.reduce::<47>(),
            TokenType::Goto => parser.reduce::<47>(),
            TokenType::If => parser.reduce::<47>(),
            TokenType::Local => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Repeat => parser.reduce::<47>(),
            TokenType::Return => parser.reduce::<47>(),
            TokenType::Until => parser.reduce::<47>(),
            TokenType::While => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::DoubleColon => parser.reduce::<47>(),
            TokenType::SemiColon => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<846> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::String(_) => parser.shift(1128),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::Until => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            // Shift(1135)-Reduce(64)
            TokenType::LParen => parser.shift(1135),
            TokenType::LSquare => parser.shift(1051),
            TokenType::LCurly => parser.shift(1160),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Colon => parser.shift(1126),
            TokenType::Dot => parser.shift(1125),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(1127),
            TokenType::Tableconstructor => parser.goto(1159),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<847> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            TokenType::Eof => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<848> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Until => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(771),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<849> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(1087),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<850> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1093),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<851> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::Else => parser.reduce::<71>(),
            TokenType::Elseif => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<852> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::RParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<853> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(622),
            TokenType::Integer(_) => parser.shift(623),
            TokenType::Float(_) => parser.shift(624),
            TokenType::False => parser.shift(625),
            TokenType::Function => parser.shift(692),
            TokenType::Nil => parser.shift(626),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(627),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(684),
            TokenType::LCurly => parser.shift(693),
            TokenType::Dots => parser.shift(628),
            TokenType::Var => parser.goto(690),
            TokenType::Exp => parser.goto(1072),
            TokenType::Prefixexp => parser.goto(521),
            TokenType::Functioncall => parser.goto(691),
            TokenType::Functiondef => parser.goto(654),
            TokenType::Tableconstructor => parser.goto(655),
            TokenType::Unop => parser.goto(657),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<854> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::Else => parser.reduce::<77>(),
            TokenType::Elseif => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<855> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(1162),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<856> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::RCurly => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<857> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Eof => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<858> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::RSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<859> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.shift(740),
            TokenType::Elseif => parser.shift(798),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatIf => parser.goto(1099),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<860> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(479),
            TokenType::String(_) => parser.shift(595),
            TokenType::Integer(_) => parser.shift(597),
            TokenType::Float(_) => parser.shift(598),
            TokenType::False => parser.shift(599),
            TokenType::Function => parser.shift(680),
            TokenType::Nil => parser.shift(600),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(601),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(667),
            TokenType::LCurly => parser.shift(681),
            TokenType::Dots => parser.shift(602),
            TokenType::Var => parser.goto(678),
            TokenType::Exp => parser.goto(1091),
            TokenType::Prefixexp => parser.goto(482),
            TokenType::Functioncall => parser.goto(679),
            TokenType::Functiondef => parser.goto(632),
            TokenType::Tableconstructor => parser.goto(633),
            TokenType::Unop => parser.goto(640),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<861> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::And => parser.shift(283),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.shift(284),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(538),
            TokenType::Concat => parser.shift(311),
            TokenType::Eof => parser.reduce::<54>(),
            TokenType::ExplistCont => parser.goto(1130),
            TokenType::Binop => parser.goto(616),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<862> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(1161),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<863> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Eof => parser.reduce::<66>(),
            TokenType::Binop => parser.goto(616),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<864> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::Until => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<865> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::Until => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<866> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::Until => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<867> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::Until => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<868> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<56>(),
            TokenType::And => parser.reduce::<56>(),
            TokenType::Break => parser.reduce::<56>(),
            TokenType::Do => parser.reduce::<56>(),
            TokenType::For => parser.reduce::<56>(),
            TokenType::Function => parser.reduce::<56>(),
            TokenType::Goto => parser.reduce::<56>(),
            TokenType::If => parser.reduce::<56>(),
            TokenType::Local => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Repeat => parser.reduce::<56>(),
            TokenType::Return => parser.reduce::<56>(),
            TokenType::Until => parser.reduce::<56>(),
            TokenType::While => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::LParen => parser.reduce::<56>(),
            TokenType::DoubleColon => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<869> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::Until => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<870> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::Until => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<871> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.shift(740),
            TokenType::Elseif => parser.shift(798),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatIf => parser.goto(1033),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<872> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<873> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Assign => parser.shift(1007),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<874> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Eof => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(737),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<875> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<876> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<877> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::End => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<878> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<56>(),
            TokenType::And => parser.reduce::<56>(),
            TokenType::Break => parser.reduce::<56>(),
            TokenType::Do => parser.reduce::<56>(),
            TokenType::End => parser.reduce::<56>(),
            TokenType::For => parser.reduce::<56>(),
            TokenType::Function => parser.reduce::<56>(),
            TokenType::Goto => parser.reduce::<56>(),
            TokenType::If => parser.reduce::<56>(),
            TokenType::Local => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Repeat => parser.reduce::<56>(),
            TokenType::Return => parser.reduce::<56>(),
            TokenType::While => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::LParen => parser.reduce::<56>(),
            TokenType::DoubleColon => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<879> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<880> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<881> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1132),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<882> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1019),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<883> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1032),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<884> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1034),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<885> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<886> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<887> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1075),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<888> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1084),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<889> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            TokenType::Eof => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<890> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            TokenType::Eof => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<891> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1083),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<892> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Until => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<893> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Until => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<894> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(1167),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<895> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(1174),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<896> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::End => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<897> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1040),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<898> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<899> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<900> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(1166),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<901> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::Until => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(860),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<902> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(519),
            TokenType::String(_) => parser.shift(622),
            TokenType::Integer(_) => parser.shift(623),
            TokenType::Float(_) => parser.shift(624),
            TokenType::False => parser.shift(625),
            TokenType::Function => parser.shift(692),
            TokenType::Nil => parser.shift(626),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(627),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(684),
            TokenType::LCurly => parser.shift(693),
            TokenType::Dots => parser.shift(628),
            TokenType::Var => parser.goto(690),
            TokenType::Exp => parser.goto(1081),
            TokenType::Prefixexp => parser.goto(521),
            TokenType::Functioncall => parser.goto(691),
            TokenType::Functiondef => parser.goto(654),
            TokenType::Tableconstructor => parser.goto(655),
            TokenType::Unop => parser.goto(657),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<903> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(1165),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<904> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1085),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<905> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1133),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<906> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<907> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<908> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.shift(1136),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<909> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1076),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<910> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1141),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<911> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<912> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<913> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1092),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<914> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1108),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<915> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(1164),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<916> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1011),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<917> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::Else => parser.reduce::<76>(),
            TokenType::Elseif => parser.reduce::<76>(),
            TokenType::End => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<918> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(1168),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<919> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::Until => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<920> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::Until => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<921> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1181),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<922> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(1171),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<923> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1147),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<924> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::Until => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<925> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::Until => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<926> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(845),
            TokenType::String(_) => parser.shift(864),
            TokenType::Integer(_) => parser.shift(865),
            TokenType::Float(_) => parser.shift(866),
            TokenType::False => parser.shift(867),
            TokenType::Function => parser.shift(970),
            TokenType::Nil => parser.shift(868),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(869),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(952),
            TokenType::LCurly => parser.shift(972),
            TokenType::Dots => parser.shift(870),
            TokenType::Var => parser.goto(967),
            TokenType::Exp => parser.goto(1154),
            TokenType::Prefixexp => parser.goto(846),
            TokenType::Functioncall => parser.goto(968),
            TokenType::Functiondef => parser.goto(924),
            TokenType::Tableconstructor => parser.goto(925),
            TokenType::Unop => parser.goto(926),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<927> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<928> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<929> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Until => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<930> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1163),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<931> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(837),
            TokenType::String(_) => parser.shift(872),
            TokenType::Integer(_) => parser.shift(875),
            TokenType::Float(_) => parser.shift(876),
            TokenType::False => parser.shift(877),
            TokenType::Function => parser.shift(969),
            TokenType::Nil => parser.shift(878),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(879),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(953),
            TokenType::LCurly => parser.shift(971),
            TokenType::Dots => parser.shift(880),
            TokenType::Var => parser.goto(965),
            TokenType::Exp => parser.goto(1107),
            TokenType::Prefixexp => parser.goto(838),
            TokenType::Functioncall => parser.goto(966),
            TokenType::Functiondef => parser.goto(927),
            TokenType::Tableconstructor => parser.goto(928),
            TokenType::Unop => parser.goto(931),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<932> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<933> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1173),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<934> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<935> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1103),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<936> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1184),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<937> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1140),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<938> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::End => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<939> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1176),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<940> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::Until => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<941> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1169),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<942> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::End => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<943> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1180),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<944> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            TokenType::Eof => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<945> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1177),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<946> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1146),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<947> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1010),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<948> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1102),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<949> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1137),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<950> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1096),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<951> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1131),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<952> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(1148),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<953> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(1021),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<954> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1015),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<955> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1129),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<956> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1016),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<957> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1134),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<958> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1138),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<959> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1124),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<960> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1105),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<961> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1123),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<962> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1036),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<963> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1037),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<964> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1139),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<965> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<966> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<967> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::Until => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<968> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::Until => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<969> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1048),
            TokenType::Funcbody => parser.goto(1041),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<970> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1045),
            TokenType::Funcbody => parser.goto(1044),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<971> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1170),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<972> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1175),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<973> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<91>(),
            TokenType::SemiColon => parser.shift(542),
            TokenType::Comma => parser.shift(543),
            TokenType::FieldlistCont => parser.goto(1142),
            TokenType::Fieldsep => parser.goto(539),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<974> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            TokenType::Comma => parser.shift(380),
            TokenType::Eof => parser.reduce::<29>(),
            TokenType::AttnamelistCont => parser.goto(1188),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<975> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<83>(),
            TokenType::Comma => parser.shift(697),
            TokenType::ParlistCont => parser.goto(1186),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<976> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<85>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<977> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::Until => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Less => parser.shift(409),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            TokenType::Comma => parser.reduce::<31>(),
            TokenType::Attrib => parser.goto(1189),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<978> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::End => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<979> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::End => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Less => parser.shift(432),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            TokenType::Comma => parser.reduce::<31>(),
            TokenType::Attrib => parser.goto(1185),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<980> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::Until => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<981> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1296),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<982> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<36>(),
            TokenType::Elseif => parser.reduce::<36>(),
            TokenType::End => parser.reduce::<36>(),
            TokenType::SemiColon => parser.shift(1190),
            TokenType::RetstatEnd => parser.goto(1187),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<983> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<35>(),
            TokenType::Elseif => parser.reduce::<35>(),
            TokenType::End => parser.reduce::<35>(),
            TokenType::SemiColon => parser.reduce::<35>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<984> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::RSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<985> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Else => parser.reduce::<47>(),
            TokenType::Elseif => parser.reduce::<47>(),
            TokenType::End => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::SemiColon => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Comma => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<986> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::RParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<987> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1218),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<988> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<15>(),
            TokenType::Break => parser.reduce::<15>(),
            TokenType::Do => parser.reduce::<15>(),
            TokenType::For => parser.reduce::<15>(),
            TokenType::Function => parser.reduce::<15>(),
            TokenType::Goto => parser.reduce::<15>(),
            TokenType::If => parser.reduce::<15>(),
            TokenType::Local => parser.reduce::<15>(),
            TokenType::Repeat => parser.reduce::<15>(),
            TokenType::Return => parser.reduce::<15>(),
            TokenType::While => parser.reduce::<15>(),
            TokenType::LParen => parser.reduce::<15>(),
            TokenType::DoubleColon => parser.reduce::<15>(),
            TokenType::SemiColon => parser.reduce::<15>(),
            TokenType::Eof => parser.reduce::<15>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<989> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            TokenType::Eof => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<990> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1311),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<991> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            TokenType::Eof => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<992> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::RSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<993> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1216),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<994> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Do => parser.reduce::<20>(),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Comma => parser.shift(1208),
            TokenType::Concat => parser.shift(311),
            TokenType::StatForexp => parser.goto(1191),
            TokenType::Binop => parser.goto(733),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<995> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1297),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<996> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(433),
            TokenType::Do => parser.shift(436),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(485),
            TokenType::Function => parser.shift(487),
            TokenType::Goto => parser.shift(488),
            TokenType::If => parser.shift(502),
            TokenType::Local => parser.shift(550),
            TokenType::Repeat => parser.shift(555),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(603),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(638),
            TokenType::SemiColon => parser.shift(634),
            TokenType::Block => parser.goto(1282),
            TokenType::BlockStat => parser.goto(390),
            TokenType::Stat => parser.goto(411),
            TokenType::Label => parser.goto(635),
            TokenType::Varlist => parser.goto(636),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(639),
            TokenType::Functioncall => parser.goto(637),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<997> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(396),
            TokenType::String(_) => parser.shift(447),
            TokenType::Integer(_) => parser.shift(448),
            TokenType::Float(_) => parser.shift(449),
            TokenType::False => parser.shift(450),
            TokenType::Function => parser.shift(649),
            TokenType::Nil => parser.shift(451),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(452),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(609),
            TokenType::LCurly => parser.shift(650),
            TokenType::Dots => parser.shift(455),
            TokenType::Var => parser.goto(647),
            TokenType::Exp => parser.goto(1204),
            TokenType::Prefixexp => parser.goto(405),
            TokenType::Functioncall => parser.goto(648),
            TokenType::Functiondef => parser.goto(500),
            TokenType::Tableconstructor => parser.goto(501),
            TokenType::Unop => parser.goto(509),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<998> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(396),
            TokenType::String(_) => parser.shift(447),
            TokenType::Integer(_) => parser.shift(448),
            TokenType::Float(_) => parser.shift(449),
            TokenType::False => parser.shift(450),
            TokenType::Function => parser.shift(649),
            TokenType::Nil => parser.shift(451),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(452),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(609),
            TokenType::LCurly => parser.shift(650),
            TokenType::Dots => parser.shift(455),
            TokenType::Var => parser.goto(647),
            TokenType::Exp => parser.goto(1205),
            TokenType::Prefixexp => parser.goto(405),
            TokenType::Functioncall => parser.goto(648),
            TokenType::Functiondef => parser.goto(500),
            TokenType::Tableconstructor => parser.goto(501),
            TokenType::Unop => parser.goto(509),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<999> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(453),
            TokenType::String(_) => parser.shift(469),
            TokenType::Integer(_) => parser.shift(471),
            TokenType::Float(_) => parser.shift(472),
            TokenType::False => parser.shift(473),
            TokenType::Function => parser.shift(630),
            TokenType::Nil => parser.shift(474),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(475),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(577),
            TokenType::LCurly => parser.shift(631),
            TokenType::Dots => parser.shift(476),
            TokenType::Var => parser.goto(617),
            TokenType::Exp => parser.goto(1206),
            TokenType::Prefixexp => parser.goto(457),
            TokenType::Functioncall => parser.goto(618),
            TokenType::Functiondef => parser.goto(511),
            TokenType::Tableconstructor => parser.goto(512),
            TokenType::Unop => parser.goto(515),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1000> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(396),
            TokenType::String(_) => parser.shift(447),
            TokenType::Integer(_) => parser.shift(448),
            TokenType::Float(_) => parser.shift(449),
            TokenType::False => parser.shift(450),
            TokenType::Function => parser.shift(649),
            TokenType::Nil => parser.shift(451),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(452),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(609),
            TokenType::LCurly => parser.shift(650),
            TokenType::Dots => parser.shift(455),
            TokenType::Var => parser.goto(647),
            TokenType::Explist => parser.goto(1192),
            TokenType::Exp => parser.goto(446),
            TokenType::Prefixexp => parser.goto(405),
            TokenType::Functioncall => parser.goto(648),
            TokenType::Functiondef => parser.goto(500),
            TokenType::Tableconstructor => parser.goto(501),
            TokenType::Unop => parser.goto(509),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1001> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1289),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Else => parser.reduce::<64>(),
            TokenType::Elseif => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            TokenType::LParen => parser.shift(1290),
            TokenType::LSquare => parser.shift(1209),
            TokenType::LCurly => parser.shift(1315),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Colon => parser.shift(1286),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Dot => parser.shift(1281),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(1287),
            TokenType::Tableconstructor => parser.goto(1314),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1002> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(1194),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1003> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(1195),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1004> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(1193),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1005> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(1196),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1006> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<38>(),
            TokenType::Break => parser.reduce::<38>(),
            TokenType::Do => parser.reduce::<38>(),
            TokenType::Else => parser.reduce::<38>(),
            TokenType::Elseif => parser.reduce::<38>(),
            TokenType::End => parser.reduce::<38>(),
            TokenType::For => parser.reduce::<38>(),
            TokenType::Function => parser.reduce::<38>(),
            TokenType::Goto => parser.reduce::<38>(),
            TokenType::If => parser.reduce::<38>(),
            TokenType::Local => parser.reduce::<38>(),
            TokenType::Repeat => parser.reduce::<38>(),
            TokenType::Return => parser.reduce::<38>(),
            TokenType::While => parser.reduce::<38>(),
            TokenType::LParen => parser.reduce::<38>(),
            TokenType::DoubleColon => parser.reduce::<38>(),
            TokenType::SemiColon => parser.reduce::<38>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1007> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(467),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LCurly => parser.shift(359),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(1217),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1008> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Comma => parser.shift(730),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(1207),
            TokenType::Binop => parser.goto(733),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1009> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(733),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1010> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::RCurly => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1011> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(920),
            TokenType::LParen => parser.shift(922),
            TokenType::LCurly => parser.shift(941),
            TokenType::Args => parser.goto(1197),
            TokenType::Tableconstructor => parser.goto(940),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1012> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(1199),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1013> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(1198),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1014> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1015> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Until => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1016> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::RCurly => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1017> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1200),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1018> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::RCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1019> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Until => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1020> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Else => parser.reduce::<54>(),
            TokenType::Elseif => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(1211),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(1201),
            TokenType::Binop => parser.goto(1219),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1021> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(1251),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1022> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Eof => parser.reduce::<66>(),
            TokenType::Binop => parser.goto(737),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1023> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<59>(),
            TokenType::Else => parser.reduce::<59>(),
            TokenType::Elseif => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1024> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<60>(),
            TokenType::Else => parser.reduce::<60>(),
            TokenType::Elseif => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1025> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<61>(),
            TokenType::Else => parser.reduce::<61>(),
            TokenType::Elseif => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1026> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<57>(),
            TokenType::Else => parser.reduce::<57>(),
            TokenType::Elseif => parser.reduce::<57>(),
            TokenType::End => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1027> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<56>(),
            TokenType::Else => parser.reduce::<56>(),
            TokenType::Elseif => parser.reduce::<56>(),
            TokenType::End => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Comma => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1028> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<58>(),
            TokenType::Else => parser.reduce::<58>(),
            TokenType::Elseif => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1029> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<62>(),
            TokenType::Else => parser.reduce::<62>(),
            TokenType::Elseif => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1030> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::Else => parser.reduce::<29>(),
            TokenType::Elseif => parser.reduce::<29>(),
            TokenType::End => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            TokenType::Comma => parser.shift(1213),
            TokenType::AttnamelistCont => parser.goto(1212),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1031> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1203),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1032> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1033> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1210),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1034> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(886),
            TokenType::LParen => parser.shift(900),
            TokenType::LCurly => parser.shift(936),
            TokenType::Args => parser.goto(1202),
            TokenType::Tableconstructor => parser.goto(934),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1035> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::End => parser.reduce::<54>(),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(757),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(1214),
            TokenType::Binop => parser.goto(783),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1036> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1037> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            TokenType::Eof => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1038> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Until => parser.reduce::<54>(),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(758),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(1220),
            TokenType::Binop => parser.goto(771),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1039> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Until => parser.reduce::<66>(),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(771),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1040> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(899),
            TokenType::LParen => parser.shift(903),
            TokenType::LCurly => parser.shift(933),
            TokenType::Args => parser.goto(1215),
            TokenType::Tableconstructor => parser.goto(932),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1041> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1042> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            TokenType::Eof => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1043> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<12>(),
            TokenType::Break => parser.reduce::<12>(),
            TokenType::Do => parser.reduce::<12>(),
            TokenType::Else => parser.reduce::<12>(),
            TokenType::Elseif => parser.reduce::<12>(),
            TokenType::End => parser.reduce::<12>(),
            TokenType::For => parser.reduce::<12>(),
            TokenType::Function => parser.reduce::<12>(),
            TokenType::Goto => parser.reduce::<12>(),
            TokenType::If => parser.reduce::<12>(),
            TokenType::Local => parser.reduce::<12>(),
            TokenType::Repeat => parser.reduce::<12>(),
            TokenType::Return => parser.reduce::<12>(),
            TokenType::While => parser.reduce::<12>(),
            TokenType::LParen => parser.reduce::<12>(),
            TokenType::DoubleColon => parser.reduce::<12>(),
            TokenType::SemiColon => parser.reduce::<12>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1044> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::Until => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1045> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(1254),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1046> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(1250),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1047> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1054),
            TokenType::Funcbody => parser.goto(1221),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1048> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(1223),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1049> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1312),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1050> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1322),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1051> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(1234),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1052> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Eof => parser.reduce::<55>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1053> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<23>(),
            TokenType::Break => parser.reduce::<23>(),
            TokenType::Do => parser.reduce::<23>(),
            TokenType::Else => parser.reduce::<23>(),
            TokenType::Elseif => parser.reduce::<23>(),
            TokenType::End => parser.reduce::<23>(),
            TokenType::For => parser.reduce::<23>(),
            TokenType::Function => parser.reduce::<23>(),
            TokenType::Goto => parser.reduce::<23>(),
            TokenType::If => parser.reduce::<23>(),
            TokenType::Local => parser.reduce::<23>(),
            TokenType::Repeat => parser.reduce::<23>(),
            TokenType::Return => parser.reduce::<23>(),
            TokenType::While => parser.reduce::<23>(),
            TokenType::LParen => parser.reduce::<23>(),
            TokenType::DoubleColon => parser.reduce::<23>(),
            TokenType::SemiColon => parser.reduce::<23>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1054> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(1244),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1055> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(1242),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1056> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<55>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1057> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1235),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1058> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<25>(),
            TokenType::Break => parser.reduce::<25>(),
            TokenType::Do => parser.reduce::<25>(),
            TokenType::Else => parser.reduce::<25>(),
            TokenType::Elseif => parser.reduce::<25>(),
            TokenType::End => parser.reduce::<25>(),
            TokenType::For => parser.reduce::<25>(),
            TokenType::Function => parser.reduce::<25>(),
            TokenType::Goto => parser.reduce::<25>(),
            TokenType::If => parser.reduce::<25>(),
            TokenType::Local => parser.reduce::<25>(),
            TokenType::Repeat => parser.reduce::<25>(),
            TokenType::Return => parser.reduce::<25>(),
            TokenType::While => parser.reduce::<25>(),
            TokenType::LParen => parser.reduce::<25>(),
            TokenType::DoubleColon => parser.reduce::<25>(),
            TokenType::SemiColon => parser.reduce::<25>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1059> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Then => parser.shift(1237),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1060> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(845),
            TokenType::String(_) => parser.shift(864),
            TokenType::Integer(_) => parser.shift(865),
            TokenType::Float(_) => parser.shift(866),
            TokenType::False => parser.shift(867),
            TokenType::Function => parser.shift(970),
            TokenType::Nil => parser.shift(868),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(869),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(952),
            TokenType::LCurly => parser.shift(972),
            TokenType::Dots => parser.shift(870),
            TokenType::Var => parser.goto(967),
            TokenType::Exp => parser.goto(1275),
            TokenType::Prefixexp => parser.goto(846),
            TokenType::Functioncall => parser.goto(968),
            TokenType::Functiondef => parser.goto(924),
            TokenType::Tableconstructor => parser.goto(925),
            TokenType::Unop => parser.goto(926),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1061> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1238),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1062> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1248),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1063> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<7>(),
            TokenType::Break => parser.reduce::<7>(),
            TokenType::Do => parser.reduce::<7>(),
            TokenType::Else => parser.reduce::<7>(),
            TokenType::Elseif => parser.reduce::<7>(),
            TokenType::End => parser.reduce::<7>(),
            TokenType::For => parser.reduce::<7>(),
            TokenType::Function => parser.reduce::<7>(),
            TokenType::Goto => parser.reduce::<7>(),
            TokenType::If => parser.reduce::<7>(),
            TokenType::Local => parser.reduce::<7>(),
            TokenType::Repeat => parser.reduce::<7>(),
            TokenType::Return => parser.reduce::<7>(),
            TokenType::While => parser.reduce::<7>(),
            TokenType::LParen => parser.reduce::<7>(),
            TokenType::DoubleColon => parser.reduce::<7>(),
            TokenType::SemiColon => parser.reduce::<7>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1064> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<47>(),
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Break => parser.reduce::<47>(),
            TokenType::Do => parser.reduce::<47>(),
            TokenType::Else => parser.reduce::<47>(),
            TokenType::Elseif => parser.reduce::<47>(),
            TokenType::End => parser.reduce::<47>(),
            TokenType::For => parser.reduce::<47>(),
            TokenType::Function => parser.reduce::<47>(),
            TokenType::Goto => parser.reduce::<47>(),
            TokenType::If => parser.reduce::<47>(),
            TokenType::Local => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Repeat => parser.reduce::<47>(),
            TokenType::Return => parser.reduce::<47>(),
            TokenType::While => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::DoubleColon => parser.reduce::<47>(),
            TokenType::SemiColon => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Comma => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1065> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::String(_) => parser.shift(1301),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::Else => parser.reduce::<64>(),
            TokenType::Elseif => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            // Shift(1305)-Reduce(64)
            TokenType::LParen => parser.shift(1305),
            TokenType::LSquare => parser.shift(1241),
            TokenType::LCurly => parser.shift(1321),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Colon => parser.shift(1299),
            TokenType::Comma => parser.reduce::<64>(),
            TokenType::Dot => parser.shift(1298),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(1300),
            TokenType::Tableconstructor => parser.goto(1320),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1066> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1222),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1067> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::RParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1068> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1064),
            TokenType::String(_) => parser.shift(1111),
            TokenType::Integer(_) => parser.shift(1112),
            TokenType::Float(_) => parser.shift(1113),
            TokenType::False => parser.shift(1114),
            TokenType::Function => parser.shift(1182),
            TokenType::Nil => parser.shift(1115),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1116),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1172),
            TokenType::LCurly => parser.shift(1183),
            TokenType::Dots => parser.shift(1118),
            TokenType::Var => parser.goto(1178),
            TokenType::Explist => parser.goto(1249),
            TokenType::Exp => parser.goto(1089),
            TokenType::Prefixexp => parser.goto(1065),
            TokenType::Functioncall => parser.goto(1179),
            TokenType::Functiondef => parser.goto(1149),
            TokenType::Tableconstructor => parser.goto(1150),
            TokenType::Unop => parser.goto(1153),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1069> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<63>(),
            TokenType::Else => parser.reduce::<63>(),
            TokenType::Elseif => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1070> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<65>(),
            TokenType::Else => parser.reduce::<65>(),
            TokenType::Elseif => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1071> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1231),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1072> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::And => parser.shift(283),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.shift(284),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(853),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(1274),
            TokenType::Binop => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1073> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(985),
            TokenType::String(_) => parser.shift(1023),
            TokenType::Integer(_) => parser.shift(1024),
            TokenType::Float(_) => parser.shift(1025),
            TokenType::False => parser.shift(1026),
            TokenType::Function => parser.shift(1157),
            TokenType::Nil => parser.shift(1027),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1028),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1121),
            TokenType::LCurly => parser.shift(1158),
            TokenType::Dots => parser.shift(1029),
            TokenType::Var => parser.goto(1155),
            TokenType::Exp => parser.goto(1276),
            TokenType::Prefixexp => parser.goto(1001),
            TokenType::Functioncall => parser.goto(1156),
            TokenType::Functiondef => parser.goto(1069),
            TokenType::Tableconstructor => parser.goto(1070),
            TokenType::Unop => parser.goto(1073),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1074> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1313),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1075> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            TokenType::Eof => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1076> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1077> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1239),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1078> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1233),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1079> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::End => parser.reduce::<66>(),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(783),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1080> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            TokenType::Eof => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1081> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(902),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1082> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(835),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1083> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(893),
            TokenType::LParen => parser.shift(895),
            TokenType::LCurly => parser.shift(930),
            TokenType::Args => parser.goto(1230),
            TokenType::Tableconstructor => parser.goto(929),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1084> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(890),
            TokenType::LParen => parser.shift(894),
            TokenType::LCurly => parser.shift(945),
            TokenType::Args => parser.goto(1267),
            TokenType::Tableconstructor => parser.goto(944),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1085> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1086> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::And => parser.shift(283),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.shift(284),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::Until => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(810),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(1291),
            TokenType::Binop => parser.goto(860),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1087> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            TokenType::Eof => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1088> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<18>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1089> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::And => parser.shift(283),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::Else => parser.reduce::<54>(),
            TokenType::Elseif => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.shift(284),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(1232),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(1226),
            TokenType::Binop => parser.goto(1294),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1090> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1224),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1091> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::Until => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(860),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1092> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<13>(),
            TokenType::Break => parser.reduce::<13>(),
            TokenType::Do => parser.reduce::<13>(),
            TokenType::End => parser.reduce::<13>(),
            TokenType::For => parser.reduce::<13>(),
            TokenType::Function => parser.reduce::<13>(),
            TokenType::Goto => parser.reduce::<13>(),
            TokenType::If => parser.reduce::<13>(),
            TokenType::Local => parser.reduce::<13>(),
            TokenType::Repeat => parser.reduce::<13>(),
            TokenType::Return => parser.reduce::<13>(),
            TokenType::While => parser.reduce::<13>(),
            TokenType::LParen => parser.reduce::<13>(),
            TokenType::DoubleColon => parser.reduce::<13>(),
            TokenType::SemiColon => parser.reduce::<13>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1093> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(854),
            TokenType::LParen => parser.shift(855),
            TokenType::LCurly => parser.shift(921),
            TokenType::Args => parser.goto(1288),
            TokenType::Tableconstructor => parser.goto(917),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1094> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1227),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1095> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1096> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            TokenType::Eof => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1097> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1098> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1228),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1099> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1229),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1100> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1101> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(1323),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1102> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            TokenType::Eof => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1103> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::RParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1104> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1246),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1105> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::Until => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1106> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1316),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1107> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::End => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(1122),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1108> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::Until => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1109> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::RCurly => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1110> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::Until => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1111> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::Else => parser.reduce::<59>(),
            TokenType::Elseif => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Comma => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1112> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::Else => parser.reduce::<60>(),
            TokenType::Elseif => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Comma => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1113> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::Else => parser.reduce::<61>(),
            TokenType::Elseif => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Comma => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1114> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::Else => parser.reduce::<57>(),
            TokenType::Elseif => parser.reduce::<57>(),
            TokenType::End => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Comma => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1115> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<56>(),
            TokenType::And => parser.reduce::<56>(),
            TokenType::Break => parser.reduce::<56>(),
            TokenType::Do => parser.reduce::<56>(),
            TokenType::Else => parser.reduce::<56>(),
            TokenType::Elseif => parser.reduce::<56>(),
            TokenType::End => parser.reduce::<56>(),
            TokenType::For => parser.reduce::<56>(),
            TokenType::Function => parser.reduce::<56>(),
            TokenType::Goto => parser.reduce::<56>(),
            TokenType::If => parser.reduce::<56>(),
            TokenType::Local => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Repeat => parser.reduce::<56>(),
            TokenType::Return => parser.reduce::<56>(),
            TokenType::While => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::LParen => parser.reduce::<56>(),
            TokenType::DoubleColon => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Comma => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1116> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::Else => parser.reduce::<58>(),
            TokenType::Elseif => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Comma => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1117> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1279),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1118> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::Else => parser.reduce::<62>(),
            TokenType::Elseif => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Comma => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1119> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1308),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1120> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1121> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(1236),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1122> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(837),
            TokenType::String(_) => parser.shift(872),
            TokenType::Integer(_) => parser.shift(875),
            TokenType::Float(_) => parser.shift(876),
            TokenType::False => parser.shift(877),
            TokenType::Function => parser.shift(969),
            TokenType::Nil => parser.shift(878),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(879),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(953),
            TokenType::LCurly => parser.shift(971),
            TokenType::Dots => parser.shift(880),
            TokenType::Var => parser.goto(965),
            TokenType::Exp => parser.goto(1292),
            TokenType::Prefixexp => parser.goto(838),
            TokenType::Functioncall => parser.goto(966),
            TokenType::Functiondef => parser.goto(927),
            TokenType::Tableconstructor => parser.goto(928),
            TokenType::Unop => parser.goto(931),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1123> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1124> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::RParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1125> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1280),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1126> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1247),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1127> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::Until => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1128> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::Until => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1129> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::RSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1130> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<55>(),
            TokenType::Break => parser.reduce::<55>(),
            TokenType::Do => parser.reduce::<55>(),
            TokenType::For => parser.reduce::<55>(),
            TokenType::Function => parser.reduce::<55>(),
            TokenType::Goto => parser.reduce::<55>(),
            TokenType::If => parser.reduce::<55>(),
            TokenType::Local => parser.reduce::<55>(),
            TokenType::Repeat => parser.reduce::<55>(),
            TokenType::Return => parser.reduce::<55>(),
            TokenType::While => parser.reduce::<55>(),
            TokenType::LParen => parser.reduce::<55>(),
            TokenType::DoubleColon => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            TokenType::Eof => parser.reduce::<55>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1131> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            TokenType::Eof => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1132> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1133> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(907),
            TokenType::LParen => parser.shift(915),
            TokenType::LCurly => parser.shift(939),
            TokenType::Args => parser.goto(1225),
            TokenType::Tableconstructor => parser.goto(938),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1134> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1135> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(1324),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1136> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1283),
            TokenType::String(_) => parser.shift(1302),
            TokenType::Integer(_) => parser.shift(1303),
            TokenType::Float(_) => parser.shift(1304),
            TokenType::False => parser.shift(1306),
            TokenType::Function => parser.shift(1332),
            TokenType::Nil => parser.shift(1307),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1309),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1329),
            TokenType::LCurly => parser.shift(1333),
            TokenType::Dots => parser.shift(1310),
            TokenType::Var => parser.goto(1330),
            TokenType::Exp => parser.goto(1245),
            TokenType::Prefixexp => parser.goto(1284),
            TokenType::Functioncall => parser.goto(1331),
            TokenType::Functiondef => parser.goto(1317),
            TokenType::Tableconstructor => parser.goto(1318),
            TokenType::Unop => parser.goto(1319),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1137> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1138> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1139> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1140> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::RSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1141> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(912),
            TokenType::LParen => parser.shift(918),
            TokenType::LCurly => parser.shift(943),
            TokenType::Args => parser.goto(1240),
            TokenType::Tableconstructor => parser.goto(942),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1142> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.reduce::<92>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1143> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::End => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1144> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1326),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1145> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Until => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1146> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            TokenType::Eof => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1147> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<13>(),
            TokenType::Break => parser.reduce::<13>(),
            TokenType::Do => parser.reduce::<13>(),
            TokenType::For => parser.reduce::<13>(),
            TokenType::Function => parser.reduce::<13>(),
            TokenType::Goto => parser.reduce::<13>(),
            TokenType::If => parser.reduce::<13>(),
            TokenType::Local => parser.reduce::<13>(),
            TokenType::Repeat => parser.reduce::<13>(),
            TokenType::Return => parser.reduce::<13>(),
            TokenType::Until => parser.reduce::<13>(),
            TokenType::While => parser.reduce::<13>(),
            TokenType::LParen => parser.reduce::<13>(),
            TokenType::DoubleColon => parser.reduce::<13>(),
            TokenType::SemiColon => parser.reduce::<13>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1148> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(1295),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1149> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::Else => parser.reduce::<63>(),
            TokenType::Elseif => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Comma => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1150> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::Else => parser.reduce::<65>(),
            TokenType::Elseif => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Comma => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1151> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1152> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1243),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1153> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1064),
            TokenType::String(_) => parser.shift(1111),
            TokenType::Integer(_) => parser.shift(1112),
            TokenType::Float(_) => parser.shift(1113),
            TokenType::False => parser.shift(1114),
            TokenType::Function => parser.shift(1182),
            TokenType::Nil => parser.shift(1115),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1116),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1172),
            TokenType::LCurly => parser.shift(1183),
            TokenType::Dots => parser.shift(1118),
            TokenType::Var => parser.goto(1178),
            TokenType::Exp => parser.goto(1285),
            TokenType::Prefixexp => parser.goto(1065),
            TokenType::Functioncall => parser.goto(1179),
            TokenType::Functiondef => parser.goto(1149),
            TokenType::Tableconstructor => parser.goto(1150),
            TokenType::Unop => parser.goto(1153),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1154> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::Until => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(1060),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1155> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Else => parser.reduce::<68>(),
            TokenType::Elseif => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1156> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Else => parser.reduce::<69>(),
            TokenType::Elseif => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1157> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1271),
            TokenType::Funcbody => parser.goto(1270),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1158> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1328),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1159> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::Until => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1160> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1327),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1161> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1162> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1268),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1163> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1272),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1164> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1253),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1165> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1252),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1166> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1273),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1167> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1278),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1168> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1269),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1169> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1260),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1170> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1256),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1171> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1277),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1172> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(1293),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1173> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1174> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1261),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1175> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1262),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1176> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1258),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1177> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1259),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1178> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::Else => parser.reduce::<68>(),
            TokenType::Elseif => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Comma => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1179> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::Else => parser.reduce::<69>(),
            TokenType::Elseif => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Comma => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1180> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1181> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1264),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1182> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1257),
            TokenType::Funcbody => parser.goto(1255),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1183> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1325),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1184> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1263),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1185> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::End => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            TokenType::Comma => parser.shift(719),
            TokenType::AttnamelistCont => parser.goto(1334),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1186> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.reduce::<84>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1187> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<33>(),
            TokenType::Elseif => parser.reduce::<33>(),
            TokenType::End => parser.reduce::<33>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1188> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            TokenType::Eof => parser.reduce::<30>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1189> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::Until => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            TokenType::Comma => parser.shift(711),
            TokenType::AttnamelistCont => parser.goto(1335),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1190> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<37>(),
            TokenType::Elseif => parser.reduce::<37>(),
            TokenType::End => parser.reduce::<37>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1191> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(1345),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1192> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(1346),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1193> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1194> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1195> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Until => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1196> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1197> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::Until => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1198> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::Until => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1199> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1200> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<22>(),
            TokenType::Break => parser.reduce::<22>(),
            TokenType::Do => parser.reduce::<22>(),
            TokenType::For => parser.reduce::<22>(),
            TokenType::Function => parser.reduce::<22>(),
            TokenType::Goto => parser.reduce::<22>(),
            TokenType::If => parser.reduce::<22>(),
            TokenType::Local => parser.reduce::<22>(),
            TokenType::Repeat => parser.reduce::<22>(),
            TokenType::Return => parser.reduce::<22>(),
            TokenType::While => parser.reduce::<22>(),
            TokenType::LParen => parser.reduce::<22>(),
            TokenType::DoubleColon => parser.reduce::<22>(),
            TokenType::SemiColon => parser.reduce::<22>(),
            TokenType::Eof => parser.reduce::<22>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1201> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<53>(),
            TokenType::Elseif => parser.reduce::<53>(),
            TokenType::End => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1202> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1203> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Greater => parser.shift(1336),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1204> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Do => parser.reduce::<20>(),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Comma => parser.shift(1208),
            TokenType::Concat => parser.shift(311),
            TokenType::StatForexp => parser.goto(1337),
            TokenType::Binop => parser.goto(733),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1205> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Do => parser.reduce::<20>(),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Comma => parser.shift(1208),
            TokenType::Concat => parser.shift(311),
            TokenType::StatForexp => parser.goto(1338),
            TokenType::Binop => parser.goto(733),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1206> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Comma => parser.shift(1348),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(835),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1207> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.reduce::<55>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1208> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(61),
            TokenType::String(_) => parser.shift(83),
            TokenType::Integer(_) => parser.shift(84),
            TokenType::Float(_) => parser.shift(85),
            TokenType::False => parser.shift(86),
            TokenType::Function => parser.shift(133),
            TokenType::Nil => parser.shift(88),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(89),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(123),
            TokenType::LCurly => parser.shift(135),
            TokenType::Dots => parser.shift(90),
            TokenType::Var => parser.goto(128),
            TokenType::Exp => parser.goto(1341),
            TokenType::Prefixexp => parser.goto(62),
            TokenType::Functioncall => parser.goto(129),
            TokenType::Functiondef => parser.goto(96),
            TokenType::Tableconstructor => parser.goto(97),
            TokenType::Unop => parser.goto(99),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1209> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(1357),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1210> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<15>(),
            TokenType::Break => parser.reduce::<15>(),
            TokenType::Do => parser.reduce::<15>(),
            TokenType::For => parser.reduce::<15>(),
            TokenType::Function => parser.reduce::<15>(),
            TokenType::Goto => parser.reduce::<15>(),
            TokenType::If => parser.reduce::<15>(),
            TokenType::Local => parser.reduce::<15>(),
            TokenType::Repeat => parser.reduce::<15>(),
            TokenType::Return => parser.reduce::<15>(),
            TokenType::Until => parser.reduce::<15>(),
            TokenType::While => parser.reduce::<15>(),
            TokenType::LParen => parser.reduce::<15>(),
            TokenType::DoubleColon => parser.reduce::<15>(),
            TokenType::SemiColon => parser.reduce::<15>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1211> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(985),
            TokenType::String(_) => parser.shift(1023),
            TokenType::Integer(_) => parser.shift(1024),
            TokenType::Float(_) => parser.shift(1025),
            TokenType::False => parser.shift(1026),
            TokenType::Function => parser.shift(1157),
            TokenType::Nil => parser.shift(1027),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1028),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1121),
            TokenType::LCurly => parser.shift(1158),
            TokenType::Dots => parser.shift(1029),
            TokenType::Var => parser.goto(1155),
            TokenType::Exp => parser.goto(1381),
            TokenType::Prefixexp => parser.goto(1001),
            TokenType::Functioncall => parser.goto(1156),
            TokenType::Functiondef => parser.goto(1069),
            TokenType::Tableconstructor => parser.goto(1070),
            TokenType::Unop => parser.goto(1073),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1212> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<28>(),
            TokenType::Break => parser.reduce::<28>(),
            TokenType::Do => parser.reduce::<28>(),
            TokenType::Else => parser.reduce::<28>(),
            TokenType::Elseif => parser.reduce::<28>(),
            TokenType::End => parser.reduce::<28>(),
            TokenType::For => parser.reduce::<28>(),
            TokenType::Function => parser.reduce::<28>(),
            TokenType::Goto => parser.reduce::<28>(),
            TokenType::If => parser.reduce::<28>(),
            TokenType::Local => parser.reduce::<28>(),
            TokenType::Repeat => parser.reduce::<28>(),
            TokenType::Return => parser.reduce::<28>(),
            TokenType::While => parser.reduce::<28>(),
            TokenType::Assign => parser.reduce::<28>(),
            TokenType::LParen => parser.reduce::<28>(),
            TokenType::DoubleColon => parser.reduce::<28>(),
            TokenType::SemiColon => parser.reduce::<28>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1213> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1342),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1214> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1215> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1216> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1339),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1217> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RCurly => parser.reduce::<94>(),
            TokenType::SemiColon => parser.reduce::<94>(),
            TokenType::Comma => parser.reduce::<94>(),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(527),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1218> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1340),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1219> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(985),
            TokenType::String(_) => parser.shift(1023),
            TokenType::Integer(_) => parser.shift(1024),
            TokenType::Float(_) => parser.shift(1025),
            TokenType::False => parser.shift(1026),
            TokenType::Function => parser.shift(1157),
            TokenType::Nil => parser.shift(1027),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1028),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1121),
            TokenType::LCurly => parser.shift(1158),
            TokenType::Dots => parser.shift(1029),
            TokenType::Var => parser.goto(1155),
            TokenType::Exp => parser.goto(1380),
            TokenType::Prefixexp => parser.goto(1001),
            TokenType::Functioncall => parser.goto(1156),
            TokenType::Functiondef => parser.goto(1069),
            TokenType::Tableconstructor => parser.goto(1070),
            TokenType::Unop => parser.goto(1073),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1220> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Until => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1221> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<24>(),
            TokenType::Break => parser.reduce::<24>(),
            TokenType::Do => parser.reduce::<24>(),
            TokenType::Else => parser.reduce::<24>(),
            TokenType::Elseif => parser.reduce::<24>(),
            TokenType::End => parser.reduce::<24>(),
            TokenType::For => parser.reduce::<24>(),
            TokenType::Function => parser.reduce::<24>(),
            TokenType::Goto => parser.reduce::<24>(),
            TokenType::If => parser.reduce::<24>(),
            TokenType::Local => parser.reduce::<24>(),
            TokenType::Repeat => parser.reduce::<24>(),
            TokenType::Return => parser.reduce::<24>(),
            TokenType::While => parser.reduce::<24>(),
            TokenType::LParen => parser.reduce::<24>(),
            TokenType::DoubleColon => parser.reduce::<24>(),
            TokenType::SemiColon => parser.reduce::<24>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1222> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1398),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1223> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1351),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1224> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1225> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1226> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<53>(),
            TokenType::Break => parser.reduce::<53>(),
            TokenType::Do => parser.reduce::<53>(),
            TokenType::Else => parser.reduce::<53>(),
            TokenType::Elseif => parser.reduce::<53>(),
            TokenType::End => parser.reduce::<53>(),
            TokenType::For => parser.reduce::<53>(),
            TokenType::Function => parser.reduce::<53>(),
            TokenType::Goto => parser.reduce::<53>(),
            TokenType::If => parser.reduce::<53>(),
            TokenType::Local => parser.reduce::<53>(),
            TokenType::Repeat => parser.reduce::<53>(),
            TokenType::Return => parser.reduce::<53>(),
            TokenType::While => parser.reduce::<53>(),
            TokenType::LParen => parser.reduce::<53>(),
            TokenType::DoubleColon => parser.reduce::<53>(),
            TokenType::SemiColon => parser.reduce::<53>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1227> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1097),
            TokenType::LParen => parser.shift(1101),
            TokenType::LCurly => parser.shift(1144),
            TokenType::Args => parser.goto(1343),
            TokenType::Tableconstructor => parser.goto(1143),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1228> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::RParen => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1229> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<15>(),
            TokenType::Break => parser.reduce::<15>(),
            TokenType::Do => parser.reduce::<15>(),
            TokenType::End => parser.reduce::<15>(),
            TokenType::For => parser.reduce::<15>(),
            TokenType::Function => parser.reduce::<15>(),
            TokenType::Goto => parser.reduce::<15>(),
            TokenType::If => parser.reduce::<15>(),
            TokenType::Local => parser.reduce::<15>(),
            TokenType::Repeat => parser.reduce::<15>(),
            TokenType::Return => parser.reduce::<15>(),
            TokenType::While => parser.reduce::<15>(),
            TokenType::LParen => parser.reduce::<15>(),
            TokenType::DoubleColon => parser.reduce::<15>(),
            TokenType::SemiColon => parser.reduce::<15>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1230> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Until => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1231> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1390),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1232> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1064),
            TokenType::String(_) => parser.shift(1111),
            TokenType::Integer(_) => parser.shift(1112),
            TokenType::Float(_) => parser.shift(1113),
            TokenType::False => parser.shift(1114),
            TokenType::Function => parser.shift(1182),
            TokenType::Nil => parser.shift(1115),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1116),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1172),
            TokenType::LCurly => parser.shift(1183),
            TokenType::Dots => parser.shift(1118),
            TokenType::Var => parser.goto(1178),
            TokenType::Exp => parser.goto(1384),
            TokenType::Prefixexp => parser.goto(1065),
            TokenType::Functioncall => parser.goto(1179),
            TokenType::Functiondef => parser.goto(1149),
            TokenType::Tableconstructor => parser.goto(1150),
            TokenType::Unop => parser.goto(1153),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1233> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1392),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1234> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(1344),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1235> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1397),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1236> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(1383),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1237> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(433),
            TokenType::Do => parser.shift(436),
            TokenType::Else => parser.reduce::<2>(),
            TokenType::Elseif => parser.reduce::<2>(),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(485),
            TokenType::Function => parser.shift(487),
            TokenType::Goto => parser.shift(488),
            TokenType::If => parser.shift(502),
            TokenType::Local => parser.shift(550),
            TokenType::Repeat => parser.shift(555),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(603),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(638),
            TokenType::SemiColon => parser.shift(634),
            TokenType::Block => parser.goto(1399),
            TokenType::BlockStat => parser.goto(390),
            TokenType::Stat => parser.goto(411),
            TokenType::Label => parser.goto(635),
            TokenType::Varlist => parser.goto(636),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(639),
            TokenType::Functioncall => parser.goto(637),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1238> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1389),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1239> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1388),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1240> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1241> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(1349),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1242> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            TokenType::Eof => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1243> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1244> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1347),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1245> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<14>(),
            TokenType::And => parser.shift(283),
            TokenType::Break => parser.reduce::<14>(),
            TokenType::Do => parser.reduce::<14>(),
            TokenType::Else => parser.reduce::<14>(),
            TokenType::Elseif => parser.reduce::<14>(),
            TokenType::End => parser.reduce::<14>(),
            TokenType::For => parser.reduce::<14>(),
            TokenType::Function => parser.reduce::<14>(),
            TokenType::Goto => parser.reduce::<14>(),
            TokenType::If => parser.reduce::<14>(),
            TokenType::Local => parser.reduce::<14>(),
            TokenType::Or => parser.shift(284),
            TokenType::Repeat => parser.reduce::<14>(),
            TokenType::Return => parser.reduce::<14>(),
            TokenType::While => parser.reduce::<14>(),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::LParen => parser.reduce::<14>(),
            TokenType::DoubleColon => parser.reduce::<14>(),
            TokenType::SemiColon => parser.reduce::<14>(),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(1356),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1246> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Eof => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1247> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1128),
            TokenType::LParen => parser.shift(1135),
            TokenType::LCurly => parser.shift(1160),
            TokenType::Args => parser.goto(1350),
            TokenType::Tableconstructor => parser.goto(1159),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1248> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1400),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1249> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<27>(),
            TokenType::Break => parser.reduce::<27>(),
            TokenType::Do => parser.reduce::<27>(),
            TokenType::Else => parser.reduce::<27>(),
            TokenType::Elseif => parser.reduce::<27>(),
            TokenType::End => parser.reduce::<27>(),
            TokenType::For => parser.reduce::<27>(),
            TokenType::Function => parser.reduce::<27>(),
            TokenType::Goto => parser.reduce::<27>(),
            TokenType::If => parser.reduce::<27>(),
            TokenType::Local => parser.reduce::<27>(),
            TokenType::Repeat => parser.reduce::<27>(),
            TokenType::Return => parser.reduce::<27>(),
            TokenType::While => parser.reduce::<27>(),
            TokenType::LParen => parser.reduce::<27>(),
            TokenType::DoubleColon => parser.reduce::<27>(),
            TokenType::SemiColon => parser.reduce::<27>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1250> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(1353),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1251> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1252> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1253> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1254> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1352),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1255> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::Else => parser.reduce::<78>(),
            TokenType::Elseif => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1256> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1257> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(1359),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1258> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1259> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            TokenType::Eof => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1260> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::Until => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1261> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Until => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1262> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::Until => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1263> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1264> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::Else => parser.reduce::<87>(),
            TokenType::Elseif => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1265> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1266> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1267> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            TokenType::Eof => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1268> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::Else => parser.reduce::<73>(),
            TokenType::Elseif => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1269> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1270> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<78>(),
            TokenType::Else => parser.reduce::<78>(),
            TokenType::Elseif => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Comma => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1271> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(1368),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1272> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Until => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1273> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1274> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<55>(),
            TokenType::Break => parser.reduce::<55>(),
            TokenType::Do => parser.reduce::<55>(),
            TokenType::End => parser.reduce::<55>(),
            TokenType::For => parser.reduce::<55>(),
            TokenType::Function => parser.reduce::<55>(),
            TokenType::Goto => parser.reduce::<55>(),
            TokenType::If => parser.reduce::<55>(),
            TokenType::Local => parser.reduce::<55>(),
            TokenType::Repeat => parser.reduce::<55>(),
            TokenType::Return => parser.reduce::<55>(),
            TokenType::While => parser.reduce::<55>(),
            TokenType::LParen => parser.reduce::<55>(),
            TokenType::DoubleColon => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1275> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::Until => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(1060),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1276> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::And => parser.reduce::<67>(),
            TokenType::Else => parser.reduce::<67>(),
            TokenType::Elseif => parser.reduce::<67>(),
            TokenType::End => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(1219),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1277> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::Until => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1278> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            TokenType::Eof => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1279> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Then => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1280> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::Until => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1281> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1362),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1282> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.shift(740),
            TokenType::Elseif => parser.shift(798),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatIf => parser.goto(1364),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1283> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<47>(),
            TokenType::String(_) => parser.reduce::<47>(),
            TokenType::And => parser.reduce::<47>(),
            TokenType::Break => parser.reduce::<47>(),
            TokenType::Do => parser.reduce::<47>(),
            TokenType::Else => parser.reduce::<47>(),
            TokenType::Elseif => parser.reduce::<47>(),
            TokenType::End => parser.reduce::<47>(),
            TokenType::For => parser.reduce::<47>(),
            TokenType::Function => parser.reduce::<47>(),
            TokenType::Goto => parser.reduce::<47>(),
            TokenType::If => parser.reduce::<47>(),
            TokenType::Local => parser.reduce::<47>(),
            TokenType::Or => parser.reduce::<47>(),
            TokenType::Repeat => parser.reduce::<47>(),
            TokenType::Return => parser.reduce::<47>(),
            TokenType::While => parser.reduce::<47>(),
            TokenType::Add => parser.reduce::<47>(),
            TokenType::Sub => parser.reduce::<47>(),
            TokenType::Mul => parser.reduce::<47>(),
            TokenType::Div => parser.reduce::<47>(),
            TokenType::Idiv => parser.reduce::<47>(),
            TokenType::Mod => parser.reduce::<47>(),
            TokenType::Pow => parser.reduce::<47>(),
            TokenType::BitAnd => parser.reduce::<47>(),
            TokenType::BitXor => parser.reduce::<47>(),
            TokenType::BitOr => parser.reduce::<47>(),
            TokenType::ShiftL => parser.reduce::<47>(),
            TokenType::ShiftR => parser.reduce::<47>(),
            TokenType::Eq => parser.reduce::<47>(),
            TokenType::Neq => parser.reduce::<47>(),
            TokenType::Leq => parser.reduce::<47>(),
            TokenType::Geq => parser.reduce::<47>(),
            TokenType::Less => parser.reduce::<47>(),
            TokenType::Greater => parser.reduce::<47>(),
            TokenType::LParen => parser.reduce::<47>(),
            TokenType::LSquare => parser.reduce::<47>(),
            TokenType::LCurly => parser.reduce::<47>(),
            TokenType::DoubleColon => parser.reduce::<47>(),
            TokenType::SemiColon => parser.reduce::<47>(),
            TokenType::Colon => parser.reduce::<47>(),
            TokenType::Dot => parser.reduce::<47>(),
            TokenType::Concat => parser.reduce::<47>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1284> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<64>(),
            TokenType::String(_) => parser.shift(1395),
            TokenType::And => parser.reduce::<64>(),
            TokenType::Break => parser.reduce::<64>(),
            TokenType::Do => parser.reduce::<64>(),
            TokenType::Else => parser.reduce::<64>(),
            TokenType::Elseif => parser.reduce::<64>(),
            TokenType::End => parser.reduce::<64>(),
            TokenType::For => parser.reduce::<64>(),
            TokenType::Function => parser.reduce::<64>(),
            TokenType::Goto => parser.reduce::<64>(),
            TokenType::If => parser.reduce::<64>(),
            TokenType::Local => parser.reduce::<64>(),
            TokenType::Or => parser.reduce::<64>(),
            TokenType::Repeat => parser.reduce::<64>(),
            TokenType::Return => parser.reduce::<64>(),
            TokenType::While => parser.reduce::<64>(),
            TokenType::Add => parser.reduce::<64>(),
            TokenType::Sub => parser.reduce::<64>(),
            TokenType::Mul => parser.reduce::<64>(),
            TokenType::Div => parser.reduce::<64>(),
            TokenType::Idiv => parser.reduce::<64>(),
            TokenType::Mod => parser.reduce::<64>(),
            TokenType::Pow => parser.reduce::<64>(),
            TokenType::BitAnd => parser.reduce::<64>(),
            TokenType::BitXor => parser.reduce::<64>(),
            TokenType::BitOr => parser.reduce::<64>(),
            TokenType::ShiftL => parser.reduce::<64>(),
            TokenType::ShiftR => parser.reduce::<64>(),
            TokenType::Eq => parser.reduce::<64>(),
            TokenType::Neq => parser.reduce::<64>(),
            TokenType::Leq => parser.reduce::<64>(),
            TokenType::Geq => parser.reduce::<64>(),
            TokenType::Less => parser.reduce::<64>(),
            TokenType::Greater => parser.reduce::<64>(),
            // Shift(1396)-Reduce(64)
            TokenType::LParen => parser.shift(1396),
            TokenType::LSquare => parser.shift(1376),
            TokenType::LCurly => parser.shift(1404),
            TokenType::DoubleColon => parser.reduce::<64>(),
            TokenType::SemiColon => parser.reduce::<64>(),
            TokenType::Colon => parser.shift(1393),
            TokenType::Dot => parser.shift(1391),
            TokenType::Concat => parser.reduce::<64>(),
            TokenType::Args => parser.goto(1394),
            TokenType::Tableconstructor => parser.goto(1403),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1285> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::Else => parser.reduce::<67>(),
            TokenType::Elseif => parser.reduce::<67>(),
            TokenType::End => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Comma => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(1294),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1286> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1367),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1287> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Else => parser.reduce::<71>(),
            TokenType::Elseif => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1288> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::Else => parser.reduce::<72>(),
            TokenType::Elseif => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1289> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Else => parser.reduce::<77>(),
            TokenType::Elseif => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1290> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(1401),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1291> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<55>(),
            TokenType::Break => parser.reduce::<55>(),
            TokenType::Do => parser.reduce::<55>(),
            TokenType::For => parser.reduce::<55>(),
            TokenType::Function => parser.reduce::<55>(),
            TokenType::Goto => parser.reduce::<55>(),
            TokenType::If => parser.reduce::<55>(),
            TokenType::Local => parser.reduce::<55>(),
            TokenType::Repeat => parser.reduce::<55>(),
            TokenType::Return => parser.reduce::<55>(),
            TokenType::Until => parser.reduce::<55>(),
            TokenType::While => parser.reduce::<55>(),
            TokenType::LParen => parser.reduce::<55>(),
            TokenType::DoubleColon => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1292> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(1122),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1293> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(1387),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1294> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1064),
            TokenType::String(_) => parser.shift(1111),
            TokenType::Integer(_) => parser.shift(1112),
            TokenType::Float(_) => parser.shift(1113),
            TokenType::False => parser.shift(1114),
            TokenType::Function => parser.shift(1182),
            TokenType::Nil => parser.shift(1115),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1116),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1172),
            TokenType::LCurly => parser.shift(1183),
            TokenType::Dots => parser.shift(1118),
            TokenType::Var => parser.goto(1178),
            TokenType::Exp => parser.goto(1386),
            TokenType::Prefixexp => parser.goto(1065),
            TokenType::Functioncall => parser.goto(1179),
            TokenType::Functiondef => parser.goto(1149),
            TokenType::Tableconstructor => parser.goto(1150),
            TokenType::Unop => parser.goto(1153),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1295> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::Until => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1296> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1377),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1297> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1366),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1298> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1375),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1299> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1358),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1300> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::Else => parser.reduce::<71>(),
            TokenType::Elseif => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Comma => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1301> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::Else => parser.reduce::<77>(),
            TokenType::Elseif => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Comma => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1302> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<59>(),
            TokenType::And => parser.reduce::<59>(),
            TokenType::Break => parser.reduce::<59>(),
            TokenType::Do => parser.reduce::<59>(),
            TokenType::Else => parser.reduce::<59>(),
            TokenType::Elseif => parser.reduce::<59>(),
            TokenType::End => parser.reduce::<59>(),
            TokenType::For => parser.reduce::<59>(),
            TokenType::Function => parser.reduce::<59>(),
            TokenType::Goto => parser.reduce::<59>(),
            TokenType::If => parser.reduce::<59>(),
            TokenType::Local => parser.reduce::<59>(),
            TokenType::Or => parser.reduce::<59>(),
            TokenType::Repeat => parser.reduce::<59>(),
            TokenType::Return => parser.reduce::<59>(),
            TokenType::While => parser.reduce::<59>(),
            TokenType::Add => parser.reduce::<59>(),
            TokenType::Sub => parser.reduce::<59>(),
            TokenType::Mul => parser.reduce::<59>(),
            TokenType::Div => parser.reduce::<59>(),
            TokenType::Idiv => parser.reduce::<59>(),
            TokenType::Mod => parser.reduce::<59>(),
            TokenType::Pow => parser.reduce::<59>(),
            TokenType::BitAnd => parser.reduce::<59>(),
            TokenType::BitXor => parser.reduce::<59>(),
            TokenType::BitOr => parser.reduce::<59>(),
            TokenType::ShiftL => parser.reduce::<59>(),
            TokenType::ShiftR => parser.reduce::<59>(),
            TokenType::Eq => parser.reduce::<59>(),
            TokenType::Neq => parser.reduce::<59>(),
            TokenType::Leq => parser.reduce::<59>(),
            TokenType::Geq => parser.reduce::<59>(),
            TokenType::Less => parser.reduce::<59>(),
            TokenType::Greater => parser.reduce::<59>(),
            TokenType::LParen => parser.reduce::<59>(),
            TokenType::DoubleColon => parser.reduce::<59>(),
            TokenType::SemiColon => parser.reduce::<59>(),
            TokenType::Concat => parser.reduce::<59>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1303> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<60>(),
            TokenType::And => parser.reduce::<60>(),
            TokenType::Break => parser.reduce::<60>(),
            TokenType::Do => parser.reduce::<60>(),
            TokenType::Else => parser.reduce::<60>(),
            TokenType::Elseif => parser.reduce::<60>(),
            TokenType::End => parser.reduce::<60>(),
            TokenType::For => parser.reduce::<60>(),
            TokenType::Function => parser.reduce::<60>(),
            TokenType::Goto => parser.reduce::<60>(),
            TokenType::If => parser.reduce::<60>(),
            TokenType::Local => parser.reduce::<60>(),
            TokenType::Or => parser.reduce::<60>(),
            TokenType::Repeat => parser.reduce::<60>(),
            TokenType::Return => parser.reduce::<60>(),
            TokenType::While => parser.reduce::<60>(),
            TokenType::Add => parser.reduce::<60>(),
            TokenType::Sub => parser.reduce::<60>(),
            TokenType::Mul => parser.reduce::<60>(),
            TokenType::Div => parser.reduce::<60>(),
            TokenType::Idiv => parser.reduce::<60>(),
            TokenType::Mod => parser.reduce::<60>(),
            TokenType::Pow => parser.reduce::<60>(),
            TokenType::BitAnd => parser.reduce::<60>(),
            TokenType::BitXor => parser.reduce::<60>(),
            TokenType::BitOr => parser.reduce::<60>(),
            TokenType::ShiftL => parser.reduce::<60>(),
            TokenType::ShiftR => parser.reduce::<60>(),
            TokenType::Eq => parser.reduce::<60>(),
            TokenType::Neq => parser.reduce::<60>(),
            TokenType::Leq => parser.reduce::<60>(),
            TokenType::Geq => parser.reduce::<60>(),
            TokenType::Less => parser.reduce::<60>(),
            TokenType::Greater => parser.reduce::<60>(),
            TokenType::LParen => parser.reduce::<60>(),
            TokenType::DoubleColon => parser.reduce::<60>(),
            TokenType::SemiColon => parser.reduce::<60>(),
            TokenType::Concat => parser.reduce::<60>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1304> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<61>(),
            TokenType::And => parser.reduce::<61>(),
            TokenType::Break => parser.reduce::<61>(),
            TokenType::Do => parser.reduce::<61>(),
            TokenType::Else => parser.reduce::<61>(),
            TokenType::Elseif => parser.reduce::<61>(),
            TokenType::End => parser.reduce::<61>(),
            TokenType::For => parser.reduce::<61>(),
            TokenType::Function => parser.reduce::<61>(),
            TokenType::Goto => parser.reduce::<61>(),
            TokenType::If => parser.reduce::<61>(),
            TokenType::Local => parser.reduce::<61>(),
            TokenType::Or => parser.reduce::<61>(),
            TokenType::Repeat => parser.reduce::<61>(),
            TokenType::Return => parser.reduce::<61>(),
            TokenType::While => parser.reduce::<61>(),
            TokenType::Add => parser.reduce::<61>(),
            TokenType::Sub => parser.reduce::<61>(),
            TokenType::Mul => parser.reduce::<61>(),
            TokenType::Div => parser.reduce::<61>(),
            TokenType::Idiv => parser.reduce::<61>(),
            TokenType::Mod => parser.reduce::<61>(),
            TokenType::Pow => parser.reduce::<61>(),
            TokenType::BitAnd => parser.reduce::<61>(),
            TokenType::BitXor => parser.reduce::<61>(),
            TokenType::BitOr => parser.reduce::<61>(),
            TokenType::ShiftL => parser.reduce::<61>(),
            TokenType::ShiftR => parser.reduce::<61>(),
            TokenType::Eq => parser.reduce::<61>(),
            TokenType::Neq => parser.reduce::<61>(),
            TokenType::Leq => parser.reduce::<61>(),
            TokenType::Geq => parser.reduce::<61>(),
            TokenType::Less => parser.reduce::<61>(),
            TokenType::Greater => parser.reduce::<61>(),
            TokenType::LParen => parser.reduce::<61>(),
            TokenType::DoubleColon => parser.reduce::<61>(),
            TokenType::SemiColon => parser.reduce::<61>(),
            TokenType::Concat => parser.reduce::<61>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1305> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(1402),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1306> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<57>(),
            TokenType::And => parser.reduce::<57>(),
            TokenType::Break => parser.reduce::<57>(),
            TokenType::Do => parser.reduce::<57>(),
            TokenType::Else => parser.reduce::<57>(),
            TokenType::Elseif => parser.reduce::<57>(),
            TokenType::End => parser.reduce::<57>(),
            TokenType::For => parser.reduce::<57>(),
            TokenType::Function => parser.reduce::<57>(),
            TokenType::Goto => parser.reduce::<57>(),
            TokenType::If => parser.reduce::<57>(),
            TokenType::Local => parser.reduce::<57>(),
            TokenType::Or => parser.reduce::<57>(),
            TokenType::Repeat => parser.reduce::<57>(),
            TokenType::Return => parser.reduce::<57>(),
            TokenType::While => parser.reduce::<57>(),
            TokenType::Add => parser.reduce::<57>(),
            TokenType::Sub => parser.reduce::<57>(),
            TokenType::Mul => parser.reduce::<57>(),
            TokenType::Div => parser.reduce::<57>(),
            TokenType::Idiv => parser.reduce::<57>(),
            TokenType::Mod => parser.reduce::<57>(),
            TokenType::Pow => parser.reduce::<57>(),
            TokenType::BitAnd => parser.reduce::<57>(),
            TokenType::BitXor => parser.reduce::<57>(),
            TokenType::BitOr => parser.reduce::<57>(),
            TokenType::ShiftL => parser.reduce::<57>(),
            TokenType::ShiftR => parser.reduce::<57>(),
            TokenType::Eq => parser.reduce::<57>(),
            TokenType::Neq => parser.reduce::<57>(),
            TokenType::Leq => parser.reduce::<57>(),
            TokenType::Geq => parser.reduce::<57>(),
            TokenType::Less => parser.reduce::<57>(),
            TokenType::Greater => parser.reduce::<57>(),
            TokenType::LParen => parser.reduce::<57>(),
            TokenType::DoubleColon => parser.reduce::<57>(),
            TokenType::SemiColon => parser.reduce::<57>(),
            TokenType::Concat => parser.reduce::<57>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1307> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<56>(),
            TokenType::And => parser.reduce::<56>(),
            TokenType::Break => parser.reduce::<56>(),
            TokenType::Do => parser.reduce::<56>(),
            TokenType::Else => parser.reduce::<56>(),
            TokenType::Elseif => parser.reduce::<56>(),
            TokenType::End => parser.reduce::<56>(),
            TokenType::For => parser.reduce::<56>(),
            TokenType::Function => parser.reduce::<56>(),
            TokenType::Goto => parser.reduce::<56>(),
            TokenType::If => parser.reduce::<56>(),
            TokenType::Local => parser.reduce::<56>(),
            TokenType::Or => parser.reduce::<56>(),
            TokenType::Repeat => parser.reduce::<56>(),
            TokenType::Return => parser.reduce::<56>(),
            TokenType::While => parser.reduce::<56>(),
            TokenType::Add => parser.reduce::<56>(),
            TokenType::Sub => parser.reduce::<56>(),
            TokenType::Mul => parser.reduce::<56>(),
            TokenType::Div => parser.reduce::<56>(),
            TokenType::Idiv => parser.reduce::<56>(),
            TokenType::Mod => parser.reduce::<56>(),
            TokenType::Pow => parser.reduce::<56>(),
            TokenType::BitAnd => parser.reduce::<56>(),
            TokenType::BitXor => parser.reduce::<56>(),
            TokenType::BitOr => parser.reduce::<56>(),
            TokenType::ShiftL => parser.reduce::<56>(),
            TokenType::ShiftR => parser.reduce::<56>(),
            TokenType::Eq => parser.reduce::<56>(),
            TokenType::Neq => parser.reduce::<56>(),
            TokenType::Leq => parser.reduce::<56>(),
            TokenType::Geq => parser.reduce::<56>(),
            TokenType::Less => parser.reduce::<56>(),
            TokenType::Greater => parser.reduce::<56>(),
            TokenType::LParen => parser.reduce::<56>(),
            TokenType::DoubleColon => parser.reduce::<56>(),
            TokenType::SemiColon => parser.reduce::<56>(),
            TokenType::Concat => parser.reduce::<56>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1308> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1360),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1309> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<58>(),
            TokenType::And => parser.reduce::<58>(),
            TokenType::Break => parser.reduce::<58>(),
            TokenType::Do => parser.reduce::<58>(),
            TokenType::Else => parser.reduce::<58>(),
            TokenType::Elseif => parser.reduce::<58>(),
            TokenType::End => parser.reduce::<58>(),
            TokenType::For => parser.reduce::<58>(),
            TokenType::Function => parser.reduce::<58>(),
            TokenType::Goto => parser.reduce::<58>(),
            TokenType::If => parser.reduce::<58>(),
            TokenType::Local => parser.reduce::<58>(),
            TokenType::Or => parser.reduce::<58>(),
            TokenType::Repeat => parser.reduce::<58>(),
            TokenType::Return => parser.reduce::<58>(),
            TokenType::While => parser.reduce::<58>(),
            TokenType::Add => parser.reduce::<58>(),
            TokenType::Sub => parser.reduce::<58>(),
            TokenType::Mul => parser.reduce::<58>(),
            TokenType::Div => parser.reduce::<58>(),
            TokenType::Idiv => parser.reduce::<58>(),
            TokenType::Mod => parser.reduce::<58>(),
            TokenType::Pow => parser.reduce::<58>(),
            TokenType::BitAnd => parser.reduce::<58>(),
            TokenType::BitXor => parser.reduce::<58>(),
            TokenType::BitOr => parser.reduce::<58>(),
            TokenType::ShiftL => parser.reduce::<58>(),
            TokenType::ShiftR => parser.reduce::<58>(),
            TokenType::Eq => parser.reduce::<58>(),
            TokenType::Neq => parser.reduce::<58>(),
            TokenType::Leq => parser.reduce::<58>(),
            TokenType::Geq => parser.reduce::<58>(),
            TokenType::Less => parser.reduce::<58>(),
            TokenType::Greater => parser.reduce::<58>(),
            TokenType::LParen => parser.reduce::<58>(),
            TokenType::DoubleColon => parser.reduce::<58>(),
            TokenType::SemiColon => parser.reduce::<58>(),
            TokenType::Concat => parser.reduce::<58>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1310> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<62>(),
            TokenType::And => parser.reduce::<62>(),
            TokenType::Break => parser.reduce::<62>(),
            TokenType::Do => parser.reduce::<62>(),
            TokenType::Else => parser.reduce::<62>(),
            TokenType::Elseif => parser.reduce::<62>(),
            TokenType::End => parser.reduce::<62>(),
            TokenType::For => parser.reduce::<62>(),
            TokenType::Function => parser.reduce::<62>(),
            TokenType::Goto => parser.reduce::<62>(),
            TokenType::If => parser.reduce::<62>(),
            TokenType::Local => parser.reduce::<62>(),
            TokenType::Or => parser.reduce::<62>(),
            TokenType::Repeat => parser.reduce::<62>(),
            TokenType::Return => parser.reduce::<62>(),
            TokenType::While => parser.reduce::<62>(),
            TokenType::Add => parser.reduce::<62>(),
            TokenType::Sub => parser.reduce::<62>(),
            TokenType::Mul => parser.reduce::<62>(),
            TokenType::Div => parser.reduce::<62>(),
            TokenType::Idiv => parser.reduce::<62>(),
            TokenType::Mod => parser.reduce::<62>(),
            TokenType::Pow => parser.reduce::<62>(),
            TokenType::BitAnd => parser.reduce::<62>(),
            TokenType::BitXor => parser.reduce::<62>(),
            TokenType::BitOr => parser.reduce::<62>(),
            TokenType::ShiftL => parser.reduce::<62>(),
            TokenType::ShiftR => parser.reduce::<62>(),
            TokenType::Eq => parser.reduce::<62>(),
            TokenType::Neq => parser.reduce::<62>(),
            TokenType::Leq => parser.reduce::<62>(),
            TokenType::Geq => parser.reduce::<62>(),
            TokenType::Less => parser.reduce::<62>(),
            TokenType::Greater => parser.reduce::<62>(),
            TokenType::LParen => parser.reduce::<62>(),
            TokenType::DoubleColon => parser.reduce::<62>(),
            TokenType::SemiColon => parser.reduce::<62>(),
            TokenType::Concat => parser.reduce::<62>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1311> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1361),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1312> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1363),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1313> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1372),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1314> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Else => parser.reduce::<76>(),
            TokenType::Elseif => parser.reduce::<76>(),
            TokenType::End => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1315> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1406),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1316> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1378),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1317> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<63>(),
            TokenType::And => parser.reduce::<63>(),
            TokenType::Break => parser.reduce::<63>(),
            TokenType::Do => parser.reduce::<63>(),
            TokenType::Else => parser.reduce::<63>(),
            TokenType::Elseif => parser.reduce::<63>(),
            TokenType::End => parser.reduce::<63>(),
            TokenType::For => parser.reduce::<63>(),
            TokenType::Function => parser.reduce::<63>(),
            TokenType::Goto => parser.reduce::<63>(),
            TokenType::If => parser.reduce::<63>(),
            TokenType::Local => parser.reduce::<63>(),
            TokenType::Or => parser.reduce::<63>(),
            TokenType::Repeat => parser.reduce::<63>(),
            TokenType::Return => parser.reduce::<63>(),
            TokenType::While => parser.reduce::<63>(),
            TokenType::Add => parser.reduce::<63>(),
            TokenType::Sub => parser.reduce::<63>(),
            TokenType::Mul => parser.reduce::<63>(),
            TokenType::Div => parser.reduce::<63>(),
            TokenType::Idiv => parser.reduce::<63>(),
            TokenType::Mod => parser.reduce::<63>(),
            TokenType::Pow => parser.reduce::<63>(),
            TokenType::BitAnd => parser.reduce::<63>(),
            TokenType::BitXor => parser.reduce::<63>(),
            TokenType::BitOr => parser.reduce::<63>(),
            TokenType::ShiftL => parser.reduce::<63>(),
            TokenType::ShiftR => parser.reduce::<63>(),
            TokenType::Eq => parser.reduce::<63>(),
            TokenType::Neq => parser.reduce::<63>(),
            TokenType::Leq => parser.reduce::<63>(),
            TokenType::Geq => parser.reduce::<63>(),
            TokenType::Less => parser.reduce::<63>(),
            TokenType::Greater => parser.reduce::<63>(),
            TokenType::LParen => parser.reduce::<63>(),
            TokenType::DoubleColon => parser.reduce::<63>(),
            TokenType::SemiColon => parser.reduce::<63>(),
            TokenType::Concat => parser.reduce::<63>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1318> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<65>(),
            TokenType::And => parser.reduce::<65>(),
            TokenType::Break => parser.reduce::<65>(),
            TokenType::Do => parser.reduce::<65>(),
            TokenType::Else => parser.reduce::<65>(),
            TokenType::Elseif => parser.reduce::<65>(),
            TokenType::End => parser.reduce::<65>(),
            TokenType::For => parser.reduce::<65>(),
            TokenType::Function => parser.reduce::<65>(),
            TokenType::Goto => parser.reduce::<65>(),
            TokenType::If => parser.reduce::<65>(),
            TokenType::Local => parser.reduce::<65>(),
            TokenType::Or => parser.reduce::<65>(),
            TokenType::Repeat => parser.reduce::<65>(),
            TokenType::Return => parser.reduce::<65>(),
            TokenType::While => parser.reduce::<65>(),
            TokenType::Add => parser.reduce::<65>(),
            TokenType::Sub => parser.reduce::<65>(),
            TokenType::Mul => parser.reduce::<65>(),
            TokenType::Div => parser.reduce::<65>(),
            TokenType::Idiv => parser.reduce::<65>(),
            TokenType::Mod => parser.reduce::<65>(),
            TokenType::Pow => parser.reduce::<65>(),
            TokenType::BitAnd => parser.reduce::<65>(),
            TokenType::BitXor => parser.reduce::<65>(),
            TokenType::BitOr => parser.reduce::<65>(),
            TokenType::ShiftL => parser.reduce::<65>(),
            TokenType::ShiftR => parser.reduce::<65>(),
            TokenType::Eq => parser.reduce::<65>(),
            TokenType::Neq => parser.reduce::<65>(),
            TokenType::Leq => parser.reduce::<65>(),
            TokenType::Geq => parser.reduce::<65>(),
            TokenType::Less => parser.reduce::<65>(),
            TokenType::Greater => parser.reduce::<65>(),
            TokenType::LParen => parser.reduce::<65>(),
            TokenType::DoubleColon => parser.reduce::<65>(),
            TokenType::SemiColon => parser.reduce::<65>(),
            TokenType::Concat => parser.reduce::<65>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1319> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1283),
            TokenType::String(_) => parser.shift(1302),
            TokenType::Integer(_) => parser.shift(1303),
            TokenType::Float(_) => parser.shift(1304),
            TokenType::False => parser.shift(1306),
            TokenType::Function => parser.shift(1332),
            TokenType::Nil => parser.shift(1307),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1309),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1329),
            TokenType::LCurly => parser.shift(1333),
            TokenType::Dots => parser.shift(1310),
            TokenType::Var => parser.goto(1330),
            TokenType::Exp => parser.goto(1385),
            TokenType::Prefixexp => parser.goto(1284),
            TokenType::Functioncall => parser.goto(1331),
            TokenType::Functiondef => parser.goto(1317),
            TokenType::Tableconstructor => parser.goto(1318),
            TokenType::Unop => parser.goto(1319),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1320> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::Else => parser.reduce::<76>(),
            TokenType::Elseif => parser.reduce::<76>(),
            TokenType::End => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Comma => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1321> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1405),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1322> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1379),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1323> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1374),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1324> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1370),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1325> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1365),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1326> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1373),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1327> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1369),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1328> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1371),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1329> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(37),
            TokenType::String(_) => parser.shift(51),
            TokenType::Integer(_) => parser.shift(52),
            TokenType::Float(_) => parser.shift(53),
            TokenType::False => parser.shift(54),
            TokenType::Function => parser.shift(130),
            TokenType::Nil => parser.shift(55),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(56),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(121),
            TokenType::LCurly => parser.shift(131),
            TokenType::Dots => parser.shift(57),
            TokenType::Var => parser.goto(124),
            TokenType::Exp => parser.goto(1382),
            TokenType::Prefixexp => parser.goto(40),
            TokenType::Functioncall => parser.goto(125),
            TokenType::Functiondef => parser.goto(91),
            TokenType::Tableconstructor => parser.goto(92),
            TokenType::Unop => parser.goto(93),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1330> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<68>(),
            TokenType::String(_) => parser.reduce::<68>(),
            TokenType::And => parser.reduce::<68>(),
            TokenType::Break => parser.reduce::<68>(),
            TokenType::Do => parser.reduce::<68>(),
            TokenType::Else => parser.reduce::<68>(),
            TokenType::Elseif => parser.reduce::<68>(),
            TokenType::End => parser.reduce::<68>(),
            TokenType::For => parser.reduce::<68>(),
            TokenType::Function => parser.reduce::<68>(),
            TokenType::Goto => parser.reduce::<68>(),
            TokenType::If => parser.reduce::<68>(),
            TokenType::Local => parser.reduce::<68>(),
            TokenType::Or => parser.reduce::<68>(),
            TokenType::Repeat => parser.reduce::<68>(),
            TokenType::Return => parser.reduce::<68>(),
            TokenType::While => parser.reduce::<68>(),
            TokenType::Add => parser.reduce::<68>(),
            TokenType::Sub => parser.reduce::<68>(),
            TokenType::Mul => parser.reduce::<68>(),
            TokenType::Div => parser.reduce::<68>(),
            TokenType::Idiv => parser.reduce::<68>(),
            TokenType::Mod => parser.reduce::<68>(),
            TokenType::Pow => parser.reduce::<68>(),
            TokenType::BitAnd => parser.reduce::<68>(),
            TokenType::BitXor => parser.reduce::<68>(),
            TokenType::BitOr => parser.reduce::<68>(),
            TokenType::ShiftL => parser.reduce::<68>(),
            TokenType::ShiftR => parser.reduce::<68>(),
            TokenType::Eq => parser.reduce::<68>(),
            TokenType::Neq => parser.reduce::<68>(),
            TokenType::Leq => parser.reduce::<68>(),
            TokenType::Geq => parser.reduce::<68>(),
            TokenType::Less => parser.reduce::<68>(),
            TokenType::Greater => parser.reduce::<68>(),
            TokenType::LParen => parser.reduce::<68>(),
            TokenType::LSquare => parser.reduce::<68>(),
            TokenType::LCurly => parser.reduce::<68>(),
            TokenType::DoubleColon => parser.reduce::<68>(),
            TokenType::SemiColon => parser.reduce::<68>(),
            TokenType::Colon => parser.reduce::<68>(),
            TokenType::Dot => parser.reduce::<68>(),
            TokenType::Concat => parser.reduce::<68>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1331> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<69>(),
            TokenType::String(_) => parser.reduce::<69>(),
            TokenType::And => parser.reduce::<69>(),
            TokenType::Break => parser.reduce::<69>(),
            TokenType::Do => parser.reduce::<69>(),
            TokenType::Else => parser.reduce::<69>(),
            TokenType::Elseif => parser.reduce::<69>(),
            TokenType::End => parser.reduce::<69>(),
            TokenType::For => parser.reduce::<69>(),
            TokenType::Function => parser.reduce::<69>(),
            TokenType::Goto => parser.reduce::<69>(),
            TokenType::If => parser.reduce::<69>(),
            TokenType::Local => parser.reduce::<69>(),
            TokenType::Or => parser.reduce::<69>(),
            TokenType::Repeat => parser.reduce::<69>(),
            TokenType::Return => parser.reduce::<69>(),
            TokenType::While => parser.reduce::<69>(),
            TokenType::Add => parser.reduce::<69>(),
            TokenType::Sub => parser.reduce::<69>(),
            TokenType::Mul => parser.reduce::<69>(),
            TokenType::Div => parser.reduce::<69>(),
            TokenType::Idiv => parser.reduce::<69>(),
            TokenType::Mod => parser.reduce::<69>(),
            TokenType::Pow => parser.reduce::<69>(),
            TokenType::BitAnd => parser.reduce::<69>(),
            TokenType::BitXor => parser.reduce::<69>(),
            TokenType::BitOr => parser.reduce::<69>(),
            TokenType::ShiftL => parser.reduce::<69>(),
            TokenType::ShiftR => parser.reduce::<69>(),
            TokenType::Eq => parser.reduce::<69>(),
            TokenType::Neq => parser.reduce::<69>(),
            TokenType::Leq => parser.reduce::<69>(),
            TokenType::Geq => parser.reduce::<69>(),
            TokenType::Less => parser.reduce::<69>(),
            TokenType::Greater => parser.reduce::<69>(),
            TokenType::LParen => parser.reduce::<69>(),
            TokenType::LSquare => parser.reduce::<69>(),
            TokenType::LCurly => parser.reduce::<69>(),
            TokenType::DoubleColon => parser.reduce::<69>(),
            TokenType::SemiColon => parser.reduce::<69>(),
            TokenType::Colon => parser.reduce::<69>(),
            TokenType::Dot => parser.reduce::<69>(),
            TokenType::Concat => parser.reduce::<69>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1332> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::LParen => parser.shift(1355),
            TokenType::Funcbody => parser.goto(1354),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1333> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1407),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1334> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::End => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1335> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::Until => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1336> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<32>(),
            TokenType::Break => parser.reduce::<32>(),
            TokenType::Do => parser.reduce::<32>(),
            TokenType::Else => parser.reduce::<32>(),
            TokenType::Elseif => parser.reduce::<32>(),
            TokenType::End => parser.reduce::<32>(),
            TokenType::For => parser.reduce::<32>(),
            TokenType::Function => parser.reduce::<32>(),
            TokenType::Goto => parser.reduce::<32>(),
            TokenType::If => parser.reduce::<32>(),
            TokenType::Local => parser.reduce::<32>(),
            TokenType::Repeat => parser.reduce::<32>(),
            TokenType::Return => parser.reduce::<32>(),
            TokenType::While => parser.reduce::<32>(),
            TokenType::Assign => parser.reduce::<32>(),
            TokenType::LParen => parser.reduce::<32>(),
            TokenType::DoubleColon => parser.reduce::<32>(),
            TokenType::SemiColon => parser.reduce::<32>(),
            TokenType::Comma => parser.reduce::<32>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1337> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(1419),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1338> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(1417),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1339> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<22>(),
            TokenType::Break => parser.reduce::<22>(),
            TokenType::Do => parser.reduce::<22>(),
            TokenType::End => parser.reduce::<22>(),
            TokenType::For => parser.reduce::<22>(),
            TokenType::Function => parser.reduce::<22>(),
            TokenType::Goto => parser.reduce::<22>(),
            TokenType::If => parser.reduce::<22>(),
            TokenType::Local => parser.reduce::<22>(),
            TokenType::Repeat => parser.reduce::<22>(),
            TokenType::Return => parser.reduce::<22>(),
            TokenType::While => parser.reduce::<22>(),
            TokenType::LParen => parser.reduce::<22>(),
            TokenType::DoubleColon => parser.reduce::<22>(),
            TokenType::SemiColon => parser.reduce::<22>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1340> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<22>(),
            TokenType::Break => parser.reduce::<22>(),
            TokenType::Do => parser.reduce::<22>(),
            TokenType::For => parser.reduce::<22>(),
            TokenType::Function => parser.reduce::<22>(),
            TokenType::Goto => parser.reduce::<22>(),
            TokenType::If => parser.reduce::<22>(),
            TokenType::Local => parser.reduce::<22>(),
            TokenType::Repeat => parser.reduce::<22>(),
            TokenType::Return => parser.reduce::<22>(),
            TokenType::Until => parser.reduce::<22>(),
            TokenType::While => parser.reduce::<22>(),
            TokenType::LParen => parser.reduce::<22>(),
            TokenType::DoubleColon => parser.reduce::<22>(),
            TokenType::SemiColon => parser.reduce::<22>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1341> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Do => parser.reduce::<21>(),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(220),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1342> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<31>(),
            TokenType::Break => parser.reduce::<31>(),
            TokenType::Do => parser.reduce::<31>(),
            TokenType::Else => parser.reduce::<31>(),
            TokenType::Elseif => parser.reduce::<31>(),
            TokenType::End => parser.reduce::<31>(),
            TokenType::For => parser.reduce::<31>(),
            TokenType::Function => parser.reduce::<31>(),
            TokenType::Goto => parser.reduce::<31>(),
            TokenType::If => parser.reduce::<31>(),
            TokenType::Local => parser.reduce::<31>(),
            TokenType::Repeat => parser.reduce::<31>(),
            TokenType::Return => parser.reduce::<31>(),
            TokenType::While => parser.reduce::<31>(),
            TokenType::Less => parser.shift(1031),
            TokenType::Assign => parser.reduce::<31>(),
            TokenType::LParen => parser.reduce::<31>(),
            TokenType::DoubleColon => parser.reduce::<31>(),
            TokenType::SemiColon => parser.reduce::<31>(),
            TokenType::Comma => parser.reduce::<31>(),
            TokenType::Attrib => parser.goto(1408),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1343> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1344> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::Until => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1345> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1436),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1346> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1438),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1347> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1443),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1348> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(396),
            TokenType::String(_) => parser.shift(447),
            TokenType::Integer(_) => parser.shift(448),
            TokenType::Float(_) => parser.shift(449),
            TokenType::False => parser.shift(450),
            TokenType::Function => parser.shift(649),
            TokenType::Nil => parser.shift(451),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(452),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(609),
            TokenType::LCurly => parser.shift(650),
            TokenType::Dots => parser.shift(455),
            TokenType::Var => parser.goto(647),
            TokenType::Exp => parser.goto(1418),
            TokenType::Prefixexp => parser.goto(405),
            TokenType::Functioncall => parser.goto(648),
            TokenType::Functiondef => parser.goto(500),
            TokenType::Tableconstructor => parser.goto(501),
            TokenType::Unop => parser.goto(509),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1349> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(1409),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1350> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::Until => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1351> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1441),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1352> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1444),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1353> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1354> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<78>(),
            TokenType::And => parser.reduce::<78>(),
            TokenType::Break => parser.reduce::<78>(),
            TokenType::Do => parser.reduce::<78>(),
            TokenType::Else => parser.reduce::<78>(),
            TokenType::Elseif => parser.reduce::<78>(),
            TokenType::End => parser.reduce::<78>(),
            TokenType::For => parser.reduce::<78>(),
            TokenType::Function => parser.reduce::<78>(),
            TokenType::Goto => parser.reduce::<78>(),
            TokenType::If => parser.reduce::<78>(),
            TokenType::Local => parser.reduce::<78>(),
            TokenType::Or => parser.reduce::<78>(),
            TokenType::Repeat => parser.reduce::<78>(),
            TokenType::Return => parser.reduce::<78>(),
            TokenType::While => parser.reduce::<78>(),
            TokenType::Add => parser.reduce::<78>(),
            TokenType::Sub => parser.reduce::<78>(),
            TokenType::Mul => parser.reduce::<78>(),
            TokenType::Div => parser.reduce::<78>(),
            TokenType::Idiv => parser.reduce::<78>(),
            TokenType::Mod => parser.reduce::<78>(),
            TokenType::Pow => parser.reduce::<78>(),
            TokenType::BitAnd => parser.reduce::<78>(),
            TokenType::BitXor => parser.reduce::<78>(),
            TokenType::BitOr => parser.reduce::<78>(),
            TokenType::ShiftL => parser.reduce::<78>(),
            TokenType::ShiftR => parser.reduce::<78>(),
            TokenType::Eq => parser.reduce::<78>(),
            TokenType::Neq => parser.reduce::<78>(),
            TokenType::Leq => parser.reduce::<78>(),
            TokenType::Geq => parser.reduce::<78>(),
            TokenType::Less => parser.reduce::<78>(),
            TokenType::Greater => parser.reduce::<78>(),
            TokenType::LParen => parser.reduce::<78>(),
            TokenType::DoubleColon => parser.reduce::<78>(),
            TokenType::SemiColon => parser.reduce::<78>(),
            TokenType::Concat => parser.reduce::<78>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1355> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(377),
            TokenType::RParen => parser.reduce::<80>(),
            TokenType::Dots => parser.shift(378),
            TokenType::FuncbodyParlist => parser.goto(1410),
            TokenType::Parlist => parser.goto(376),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1356> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1283),
            TokenType::String(_) => parser.shift(1302),
            TokenType::Integer(_) => parser.shift(1303),
            TokenType::Float(_) => parser.shift(1304),
            TokenType::False => parser.shift(1306),
            TokenType::Function => parser.shift(1332),
            TokenType::Nil => parser.shift(1307),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(1309),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(1329),
            TokenType::LCurly => parser.shift(1333),
            TokenType::Dots => parser.shift(1310),
            TokenType::Var => parser.goto(1330),
            TokenType::Exp => parser.goto(1439),
            TokenType::Prefixexp => parser.goto(1284),
            TokenType::Functioncall => parser.goto(1331),
            TokenType::Functiondef => parser.goto(1317),
            TokenType::Tableconstructor => parser.goto(1318),
            TokenType::Unop => parser.goto(1319),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1357> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(1412),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1358> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1301),
            TokenType::LParen => parser.shift(1305),
            TokenType::LCurly => parser.shift(1321),
            TokenType::Args => parser.goto(1411),
            TokenType::Tableconstructor => parser.goto(1320),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1359> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1422),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1360> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::RCurly => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1361> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1362> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Else => parser.reduce::<49>(),
            TokenType::Elseif => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1363> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<13>(),
            TokenType::Break => parser.reduce::<13>(),
            TokenType::Do => parser.reduce::<13>(),
            TokenType::Else => parser.reduce::<13>(),
            TokenType::Elseif => parser.reduce::<13>(),
            TokenType::End => parser.reduce::<13>(),
            TokenType::For => parser.reduce::<13>(),
            TokenType::Function => parser.reduce::<13>(),
            TokenType::Goto => parser.reduce::<13>(),
            TokenType::If => parser.reduce::<13>(),
            TokenType::Local => parser.reduce::<13>(),
            TokenType::Repeat => parser.reduce::<13>(),
            TokenType::Return => parser.reduce::<13>(),
            TokenType::While => parser.reduce::<13>(),
            TokenType::LParen => parser.reduce::<13>(),
            TokenType::DoubleColon => parser.reduce::<13>(),
            TokenType::SemiColon => parser.reduce::<13>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1364> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1413),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1365> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::Else => parser.reduce::<87>(),
            TokenType::Elseif => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1366> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            TokenType::Eof => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1367> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1289),
            TokenType::LParen => parser.shift(1290),
            TokenType::LCurly => parser.shift(1315),
            TokenType::Args => parser.goto(1414),
            TokenType::Tableconstructor => parser.goto(1314),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1368> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1425),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1369> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::Until => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1370> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::Until => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1371> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<87>(),
            TokenType::Else => parser.reduce::<87>(),
            TokenType::Elseif => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1372> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::RParen => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1373> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1374> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1375> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::Else => parser.reduce::<49>(),
            TokenType::Elseif => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Comma => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1376> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(155),
            TokenType::String(_) => parser.shift(223),
            TokenType::Integer(_) => parser.shift(224),
            TokenType::Float(_) => parser.shift(225),
            TokenType::False => parser.shift(227),
            TokenType::Function => parser.shift(354),
            TokenType::Nil => parser.shift(228),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(229),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(327),
            TokenType::LCurly => parser.shift(357),
            TokenType::Dots => parser.shift(230),
            TokenType::Var => parser.goto(348),
            TokenType::Exp => parser.goto(1435),
            TokenType::Prefixexp => parser.goto(164),
            TokenType::Functioncall => parser.goto(349),
            TokenType::Functiondef => parser.goto(262),
            TokenType::Tableconstructor => parser.goto(264),
            TokenType::Unop => parser.goto(266),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1377> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::Until => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1378> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            TokenType::Eof => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1379> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::RSquare => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1380> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Else => parser.reduce::<66>(),
            TokenType::Elseif => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(1219),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1381> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Else => parser.reduce::<54>(),
            TokenType::Elseif => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(1211),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(1437),
            TokenType::Binop => parser.goto(1219),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1382> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RParen => parser.shift(1440),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(191),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1383> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Else => parser.reduce::<70>(),
            TokenType::Elseif => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1384> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<54>(),
            TokenType::And => parser.shift(283),
            TokenType::Break => parser.reduce::<54>(),
            TokenType::Do => parser.reduce::<54>(),
            TokenType::Else => parser.reduce::<54>(),
            TokenType::Elseif => parser.reduce::<54>(),
            TokenType::End => parser.reduce::<54>(),
            TokenType::For => parser.reduce::<54>(),
            TokenType::Function => parser.reduce::<54>(),
            TokenType::Goto => parser.reduce::<54>(),
            TokenType::If => parser.reduce::<54>(),
            TokenType::Local => parser.reduce::<54>(),
            TokenType::Or => parser.shift(284),
            TokenType::Repeat => parser.reduce::<54>(),
            TokenType::Return => parser.reduce::<54>(),
            TokenType::While => parser.reduce::<54>(),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::LParen => parser.reduce::<54>(),
            TokenType::DoubleColon => parser.reduce::<54>(),
            TokenType::SemiColon => parser.reduce::<54>(),
            TokenType::Comma => parser.shift(1232),
            TokenType::Concat => parser.shift(311),
            TokenType::ExplistCont => parser.goto(1442),
            TokenType::Binop => parser.goto(1294),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1385> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        // Unary operator
        // Unary operators have higher precedence to all
        // expect `Pow`
        match lookahead {
            TokenType::Name(_) => parser.reduce::<67>(),
            TokenType::And => parser.reduce::<67>(),
            TokenType::Break => parser.reduce::<67>(),
            TokenType::Do => parser.reduce::<67>(),
            TokenType::Else => parser.reduce::<67>(),
            TokenType::Elseif => parser.reduce::<67>(),
            TokenType::End => parser.reduce::<67>(),
            TokenType::For => parser.reduce::<67>(),
            TokenType::Function => parser.reduce::<67>(),
            TokenType::Goto => parser.reduce::<67>(),
            TokenType::If => parser.reduce::<67>(),
            TokenType::Local => parser.reduce::<67>(),
            TokenType::Or => parser.reduce::<67>(),
            TokenType::Repeat => parser.reduce::<67>(),
            TokenType::Return => parser.reduce::<67>(),
            TokenType::While => parser.reduce::<67>(),
            TokenType::Add => parser.reduce::<67>(),
            TokenType::Sub => parser.reduce::<67>(),
            TokenType::Mul => parser.reduce::<67>(),
            TokenType::Div => parser.reduce::<67>(),
            TokenType::Idiv => parser.reduce::<67>(),
            TokenType::Mod => parser.reduce::<67>(),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.reduce::<67>(),
            TokenType::BitXor => parser.reduce::<67>(),
            TokenType::BitOr => parser.reduce::<67>(),
            TokenType::ShiftL => parser.reduce::<67>(),
            TokenType::ShiftR => parser.reduce::<67>(),
            TokenType::Eq => parser.reduce::<67>(),
            TokenType::Neq => parser.reduce::<67>(),
            TokenType::Leq => parser.reduce::<67>(),
            TokenType::Geq => parser.reduce::<67>(),
            TokenType::Less => parser.reduce::<67>(),
            TokenType::Greater => parser.reduce::<67>(),
            TokenType::LParen => parser.reduce::<67>(),
            TokenType::DoubleColon => parser.reduce::<67>(),
            TokenType::SemiColon => parser.reduce::<67>(),
            TokenType::Concat => parser.reduce::<67>(),
            TokenType::Binop => parser.goto(1356),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1386> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::Else => parser.reduce::<66>(),
            TokenType::Elseif => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Comma => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(1294),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1387> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::Else => parser.reduce::<70>(),
            TokenType::Elseif => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Comma => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1388> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1415),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1389> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1416),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1390> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1431),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1391> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1392> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1426),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1393> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(1433),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1394> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<71>(),
            TokenType::String(_) => parser.reduce::<71>(),
            TokenType::And => parser.reduce::<71>(),
            TokenType::Break => parser.reduce::<71>(),
            TokenType::Do => parser.reduce::<71>(),
            TokenType::Else => parser.reduce::<71>(),
            TokenType::Elseif => parser.reduce::<71>(),
            TokenType::End => parser.reduce::<71>(),
            TokenType::For => parser.reduce::<71>(),
            TokenType::Function => parser.reduce::<71>(),
            TokenType::Goto => parser.reduce::<71>(),
            TokenType::If => parser.reduce::<71>(),
            TokenType::Local => parser.reduce::<71>(),
            TokenType::Or => parser.reduce::<71>(),
            TokenType::Repeat => parser.reduce::<71>(),
            TokenType::Return => parser.reduce::<71>(),
            TokenType::While => parser.reduce::<71>(),
            TokenType::Add => parser.reduce::<71>(),
            TokenType::Sub => parser.reduce::<71>(),
            TokenType::Mul => parser.reduce::<71>(),
            TokenType::Div => parser.reduce::<71>(),
            TokenType::Idiv => parser.reduce::<71>(),
            TokenType::Mod => parser.reduce::<71>(),
            TokenType::Pow => parser.reduce::<71>(),
            TokenType::BitAnd => parser.reduce::<71>(),
            TokenType::BitXor => parser.reduce::<71>(),
            TokenType::BitOr => parser.reduce::<71>(),
            TokenType::ShiftL => parser.reduce::<71>(),
            TokenType::ShiftR => parser.reduce::<71>(),
            TokenType::Eq => parser.reduce::<71>(),
            TokenType::Neq => parser.reduce::<71>(),
            TokenType::Leq => parser.reduce::<71>(),
            TokenType::Geq => parser.reduce::<71>(),
            TokenType::Less => parser.reduce::<71>(),
            TokenType::Greater => parser.reduce::<71>(),
            TokenType::LParen => parser.reduce::<71>(),
            TokenType::LSquare => parser.reduce::<71>(),
            TokenType::LCurly => parser.reduce::<71>(),
            TokenType::DoubleColon => parser.reduce::<71>(),
            TokenType::SemiColon => parser.reduce::<71>(),
            TokenType::Colon => parser.reduce::<71>(),
            TokenType::Dot => parser.reduce::<71>(),
            TokenType::Concat => parser.reduce::<71>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1395> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<77>(),
            TokenType::String(_) => parser.reduce::<77>(),
            TokenType::And => parser.reduce::<77>(),
            TokenType::Break => parser.reduce::<77>(),
            TokenType::Do => parser.reduce::<77>(),
            TokenType::Else => parser.reduce::<77>(),
            TokenType::Elseif => parser.reduce::<77>(),
            TokenType::End => parser.reduce::<77>(),
            TokenType::For => parser.reduce::<77>(),
            TokenType::Function => parser.reduce::<77>(),
            TokenType::Goto => parser.reduce::<77>(),
            TokenType::If => parser.reduce::<77>(),
            TokenType::Local => parser.reduce::<77>(),
            TokenType::Or => parser.reduce::<77>(),
            TokenType::Repeat => parser.reduce::<77>(),
            TokenType::Return => parser.reduce::<77>(),
            TokenType::While => parser.reduce::<77>(),
            TokenType::Add => parser.reduce::<77>(),
            TokenType::Sub => parser.reduce::<77>(),
            TokenType::Mul => parser.reduce::<77>(),
            TokenType::Div => parser.reduce::<77>(),
            TokenType::Idiv => parser.reduce::<77>(),
            TokenType::Mod => parser.reduce::<77>(),
            TokenType::Pow => parser.reduce::<77>(),
            TokenType::BitAnd => parser.reduce::<77>(),
            TokenType::BitXor => parser.reduce::<77>(),
            TokenType::BitOr => parser.reduce::<77>(),
            TokenType::ShiftL => parser.reduce::<77>(),
            TokenType::ShiftR => parser.reduce::<77>(),
            TokenType::Eq => parser.reduce::<77>(),
            TokenType::Neq => parser.reduce::<77>(),
            TokenType::Leq => parser.reduce::<77>(),
            TokenType::Geq => parser.reduce::<77>(),
            TokenType::Less => parser.reduce::<77>(),
            TokenType::Greater => parser.reduce::<77>(),
            TokenType::LParen => parser.reduce::<77>(),
            TokenType::LSquare => parser.reduce::<77>(),
            TokenType::LCurly => parser.reduce::<77>(),
            TokenType::DoubleColon => parser.reduce::<77>(),
            TokenType::SemiColon => parser.reduce::<77>(),
            TokenType::Colon => parser.reduce::<77>(),
            TokenType::Dot => parser.reduce::<77>(),
            TokenType::Concat => parser.reduce::<77>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1396> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(187),
            TokenType::String(_) => parser.shift(208),
            TokenType::Integer(_) => parser.shift(209),
            TokenType::Float(_) => parser.shift(210),
            TokenType::False => parser.shift(212),
            TokenType::Function => parser.shift(346),
            TokenType::Nil => parser.shift(213),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(214),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(328),
            TokenType::RParen => parser.reduce::<74>(),
            TokenType::LCurly => parser.shift(350),
            TokenType::Dots => parser.shift(215),
            TokenType::Var => parser.goto(340),
            TokenType::Explist => parser.goto(345),
            TokenType::Exp => parser.goto(207),
            TokenType::Prefixexp => parser.goto(189),
            TokenType::Functioncall => parser.goto(342),
            TokenType::ArgsExplist => parser.goto(1445),
            TokenType::Functiondef => parser.goto(258),
            TokenType::Tableconstructor => parser.goto(259),
            TokenType::Unop => parser.goto(265),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1397> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1420),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1398> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1432),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1399> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.shift(740),
            TokenType::Elseif => parser.shift(798),
            TokenType::End => parser.reduce::<16>(),
            TokenType::StatIf => parser.goto(1434),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1400> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1421),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1401> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1424),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1402> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1423),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1403> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<76>(),
            TokenType::String(_) => parser.reduce::<76>(),
            TokenType::And => parser.reduce::<76>(),
            TokenType::Break => parser.reduce::<76>(),
            TokenType::Do => parser.reduce::<76>(),
            TokenType::Else => parser.reduce::<76>(),
            TokenType::Elseif => parser.reduce::<76>(),
            TokenType::End => parser.reduce::<76>(),
            TokenType::For => parser.reduce::<76>(),
            TokenType::Function => parser.reduce::<76>(),
            TokenType::Goto => parser.reduce::<76>(),
            TokenType::If => parser.reduce::<76>(),
            TokenType::Local => parser.reduce::<76>(),
            TokenType::Or => parser.reduce::<76>(),
            TokenType::Repeat => parser.reduce::<76>(),
            TokenType::Return => parser.reduce::<76>(),
            TokenType::While => parser.reduce::<76>(),
            TokenType::Add => parser.reduce::<76>(),
            TokenType::Sub => parser.reduce::<76>(),
            TokenType::Mul => parser.reduce::<76>(),
            TokenType::Div => parser.reduce::<76>(),
            TokenType::Idiv => parser.reduce::<76>(),
            TokenType::Mod => parser.reduce::<76>(),
            TokenType::Pow => parser.reduce::<76>(),
            TokenType::BitAnd => parser.reduce::<76>(),
            TokenType::BitXor => parser.reduce::<76>(),
            TokenType::BitOr => parser.reduce::<76>(),
            TokenType::ShiftL => parser.reduce::<76>(),
            TokenType::ShiftR => parser.reduce::<76>(),
            TokenType::Eq => parser.reduce::<76>(),
            TokenType::Neq => parser.reduce::<76>(),
            TokenType::Leq => parser.reduce::<76>(),
            TokenType::Geq => parser.reduce::<76>(),
            TokenType::Less => parser.reduce::<76>(),
            TokenType::Greater => parser.reduce::<76>(),
            TokenType::LParen => parser.reduce::<76>(),
            TokenType::LSquare => parser.reduce::<76>(),
            TokenType::LCurly => parser.reduce::<76>(),
            TokenType::DoubleColon => parser.reduce::<76>(),
            TokenType::SemiColon => parser.reduce::<76>(),
            TokenType::Colon => parser.reduce::<76>(),
            TokenType::Dot => parser.reduce::<76>(),
            TokenType::Concat => parser.reduce::<76>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1404> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(216),
            TokenType::String(_) => parser.shift(240),
            TokenType::Integer(_) => parser.shift(241),
            TokenType::Float(_) => parser.shift(242),
            TokenType::False => parser.shift(243),
            TokenType::Function => parser.shift(358),
            TokenType::Nil => parser.shift(244),
            TokenType::Not => parser.shift(136),
            TokenType::True => parser.shift(245),
            TokenType::Sub => parser.shift(137),
            TokenType::Len => parser.shift(138),
            TokenType::BitXor => parser.shift(139),
            TokenType::LParen => parser.shift(332),
            TokenType::LSquare => parser.shift(363),
            TokenType::LCurly => parser.shift(359),
            TokenType::RCurly => parser.reduce::<88>(),
            TokenType::Dots => parser.shift(246),
            TokenType::Var => parser.goto(355),
            TokenType::Exp => parser.goto(247),
            TokenType::Prefixexp => parser.goto(219),
            TokenType::Functioncall => parser.goto(356),
            TokenType::Functiondef => parser.goto(271),
            TokenType::Tableconstructor => parser.goto(272),
            TokenType::TableconstructorFieldlist => parser.goto(1446),
            TokenType::Fieldlist => parser.goto(361),
            TokenType::Field => parser.goto(362),
            TokenType::Unop => parser.goto(274),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1405> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1430),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1406> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1428),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1407> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1429),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1408> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<29>(),
            TokenType::Break => parser.reduce::<29>(),
            TokenType::Do => parser.reduce::<29>(),
            TokenType::Else => parser.reduce::<29>(),
            TokenType::Elseif => parser.reduce::<29>(),
            TokenType::End => parser.reduce::<29>(),
            TokenType::For => parser.reduce::<29>(),
            TokenType::Function => parser.reduce::<29>(),
            TokenType::Goto => parser.reduce::<29>(),
            TokenType::If => parser.reduce::<29>(),
            TokenType::Local => parser.reduce::<29>(),
            TokenType::Repeat => parser.reduce::<29>(),
            TokenType::Return => parser.reduce::<29>(),
            TokenType::While => parser.reduce::<29>(),
            TokenType::Assign => parser.reduce::<29>(),
            TokenType::LParen => parser.reduce::<29>(),
            TokenType::DoubleColon => parser.reduce::<29>(),
            TokenType::SemiColon => parser.reduce::<29>(),
            TokenType::Comma => parser.shift(1213),
            TokenType::AttnamelistCont => parser.goto(1448),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1409> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::Else => parser.reduce::<48>(),
            TokenType::Elseif => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1410> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1458),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1411> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::Else => parser.reduce::<72>(),
            TokenType::Elseif => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1412> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Else => parser.reduce::<48>(),
            TokenType::Elseif => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Comma => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1413> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<15>(),
            TokenType::Break => parser.reduce::<15>(),
            TokenType::Do => parser.reduce::<15>(),
            TokenType::Else => parser.reduce::<15>(),
            TokenType::Elseif => parser.reduce::<15>(),
            TokenType::End => parser.reduce::<15>(),
            TokenType::For => parser.reduce::<15>(),
            TokenType::Function => parser.reduce::<15>(),
            TokenType::Goto => parser.reduce::<15>(),
            TokenType::If => parser.reduce::<15>(),
            TokenType::Local => parser.reduce::<15>(),
            TokenType::Repeat => parser.reduce::<15>(),
            TokenType::Return => parser.reduce::<15>(),
            TokenType::While => parser.reduce::<15>(),
            TokenType::LParen => parser.reduce::<15>(),
            TokenType::DoubleColon => parser.reduce::<15>(),
            TokenType::SemiColon => parser.reduce::<15>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1414> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Else => parser.reduce::<72>(),
            TokenType::Elseif => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Comma => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1415> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            TokenType::Eof => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1416> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Until => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1417> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1460),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1418> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Do => parser.reduce::<20>(),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::Comma => parser.shift(1208),
            TokenType::Concat => parser.shift(311),
            TokenType::StatForexp => parser.goto(1447),
            TokenType::Binop => parser.goto(733),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1419> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1459),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1420> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::Until => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1421> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1422> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1462),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1423> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::Else => parser.reduce::<73>(),
            TokenType::Elseif => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1424> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Else => parser.reduce::<73>(),
            TokenType::Elseif => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Comma => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1425> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1461),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1426> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1427> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<49>(),
            TokenType::String(_) => parser.reduce::<49>(),
            TokenType::And => parser.reduce::<49>(),
            TokenType::Break => parser.reduce::<49>(),
            TokenType::Do => parser.reduce::<49>(),
            TokenType::Else => parser.reduce::<49>(),
            TokenType::Elseif => parser.reduce::<49>(),
            TokenType::End => parser.reduce::<49>(),
            TokenType::For => parser.reduce::<49>(),
            TokenType::Function => parser.reduce::<49>(),
            TokenType::Goto => parser.reduce::<49>(),
            TokenType::If => parser.reduce::<49>(),
            TokenType::Local => parser.reduce::<49>(),
            TokenType::Or => parser.reduce::<49>(),
            TokenType::Repeat => parser.reduce::<49>(),
            TokenType::Return => parser.reduce::<49>(),
            TokenType::While => parser.reduce::<49>(),
            TokenType::Add => parser.reduce::<49>(),
            TokenType::Sub => parser.reduce::<49>(),
            TokenType::Mul => parser.reduce::<49>(),
            TokenType::Div => parser.reduce::<49>(),
            TokenType::Idiv => parser.reduce::<49>(),
            TokenType::Mod => parser.reduce::<49>(),
            TokenType::Pow => parser.reduce::<49>(),
            TokenType::BitAnd => parser.reduce::<49>(),
            TokenType::BitXor => parser.reduce::<49>(),
            TokenType::BitOr => parser.reduce::<49>(),
            TokenType::ShiftL => parser.reduce::<49>(),
            TokenType::ShiftR => parser.reduce::<49>(),
            TokenType::Eq => parser.reduce::<49>(),
            TokenType::Neq => parser.reduce::<49>(),
            TokenType::Leq => parser.reduce::<49>(),
            TokenType::Geq => parser.reduce::<49>(),
            TokenType::Less => parser.reduce::<49>(),
            TokenType::Greater => parser.reduce::<49>(),
            TokenType::LParen => parser.reduce::<49>(),
            TokenType::LSquare => parser.reduce::<49>(),
            TokenType::LCurly => parser.reduce::<49>(),
            TokenType::DoubleColon => parser.reduce::<49>(),
            TokenType::SemiColon => parser.reduce::<49>(),
            TokenType::Colon => parser.reduce::<49>(),
            TokenType::Dot => parser.reduce::<49>(),
            TokenType::Concat => parser.reduce::<49>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1428> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Else => parser.reduce::<87>(),
            TokenType::Elseif => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1429> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::Else => parser.reduce::<87>(),
            TokenType::Elseif => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1430> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::Else => parser.reduce::<87>(),
            TokenType::Elseif => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Comma => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1431> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1432> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1433> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::String(_) => parser.shift(1395),
            TokenType::LParen => parser.shift(1396),
            TokenType::LCurly => parser.shift(1404),
            TokenType::Args => parser.goto(1450),
            TokenType::Tableconstructor => parser.goto(1403),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1434> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.reduce::<17>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1435> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.shift(283),
            TokenType::Or => parser.shift(284),
            TokenType::Add => parser.shift(285),
            TokenType::Sub => parser.shift(286),
            TokenType::Mul => parser.shift(287),
            TokenType::Div => parser.shift(288),
            TokenType::Idiv => parser.shift(289),
            TokenType::Mod => parser.shift(290),
            TokenType::Pow => parser.shift(294),
            TokenType::BitAnd => parser.shift(295),
            TokenType::BitXor => parser.shift(297),
            TokenType::BitOr => parser.shift(298),
            TokenType::ShiftL => parser.shift(299),
            TokenType::ShiftR => parser.shift(300),
            TokenType::Eq => parser.shift(301),
            TokenType::Neq => parser.shift(302),
            TokenType::Leq => parser.shift(303),
            TokenType::Geq => parser.shift(308),
            TokenType::Less => parser.shift(309),
            TokenType::Greater => parser.shift(310),
            TokenType::RSquare => parser.shift(1449),
            TokenType::Concat => parser.shift(311),
            TokenType::Binop => parser.goto(427),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1436> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1452),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1437> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Else => parser.reduce::<55>(),
            TokenType::Elseif => parser.reduce::<55>(),
            TokenType::End => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1438> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1451),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1439> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        let precedence = Self::get_previous_binop(parser).precedence(lookahead);
        match lookahead {
            TokenType::Name(_) => parser.reduce::<66>(),
            TokenType::And => precedence.resolve::<66>(parser, 283),
            TokenType::Break => parser.reduce::<66>(),
            TokenType::Do => parser.reduce::<66>(),
            TokenType::Else => parser.reduce::<66>(),
            TokenType::Elseif => parser.reduce::<66>(),
            TokenType::End => parser.reduce::<66>(),
            TokenType::For => parser.reduce::<66>(),
            TokenType::Function => parser.reduce::<66>(),
            TokenType::Goto => parser.reduce::<66>(),
            TokenType::If => parser.reduce::<66>(),
            TokenType::Local => parser.reduce::<66>(),
            TokenType::Or => precedence.resolve::<66>(parser, 284),
            TokenType::Repeat => parser.reduce::<66>(),
            TokenType::Return => parser.reduce::<66>(),
            TokenType::While => parser.reduce::<66>(),
            TokenType::Add => precedence.resolve::<66>(parser, 285),
            TokenType::Sub => precedence.resolve::<66>(parser, 286),
            TokenType::Mul => precedence.resolve::<66>(parser, 287),
            TokenType::Div => precedence.resolve::<66>(parser, 288),
            TokenType::Idiv => precedence.resolve::<66>(parser, 289),
            TokenType::Mod => precedence.resolve::<66>(parser, 290),
            TokenType::Pow => precedence.resolve::<66>(parser, 294),
            TokenType::BitAnd => precedence.resolve::<66>(parser, 295),
            TokenType::BitXor => precedence.resolve::<66>(parser, 297),
            TokenType::BitOr => precedence.resolve::<66>(parser, 298),
            TokenType::ShiftL => precedence.resolve::<66>(parser, 299),
            TokenType::ShiftR => precedence.resolve::<66>(parser, 300),
            TokenType::Eq => precedence.resolve::<66>(parser, 301),
            TokenType::Neq => precedence.resolve::<66>(parser, 302),
            TokenType::Leq => precedence.resolve::<66>(parser, 303),
            TokenType::Geq => precedence.resolve::<66>(parser, 308),
            TokenType::Less => precedence.resolve::<66>(parser, 309),
            TokenType::Greater => precedence.resolve::<66>(parser, 310),
            TokenType::LParen => parser.reduce::<66>(),
            TokenType::DoubleColon => parser.reduce::<66>(),
            TokenType::SemiColon => parser.reduce::<66>(),
            TokenType::Concat => precedence.resolve::<66>(parser, 311),
            TokenType::Binop => parser.goto(1356),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1440> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<70>(),
            TokenType::String(_) => parser.reduce::<70>(),
            TokenType::And => parser.reduce::<70>(),
            TokenType::Break => parser.reduce::<70>(),
            TokenType::Do => parser.reduce::<70>(),
            TokenType::Else => parser.reduce::<70>(),
            TokenType::Elseif => parser.reduce::<70>(),
            TokenType::End => parser.reduce::<70>(),
            TokenType::For => parser.reduce::<70>(),
            TokenType::Function => parser.reduce::<70>(),
            TokenType::Goto => parser.reduce::<70>(),
            TokenType::If => parser.reduce::<70>(),
            TokenType::Local => parser.reduce::<70>(),
            TokenType::Or => parser.reduce::<70>(),
            TokenType::Repeat => parser.reduce::<70>(),
            TokenType::Return => parser.reduce::<70>(),
            TokenType::While => parser.reduce::<70>(),
            TokenType::Add => parser.reduce::<70>(),
            TokenType::Sub => parser.reduce::<70>(),
            TokenType::Mul => parser.reduce::<70>(),
            TokenType::Div => parser.reduce::<70>(),
            TokenType::Idiv => parser.reduce::<70>(),
            TokenType::Mod => parser.reduce::<70>(),
            TokenType::Pow => parser.reduce::<70>(),
            TokenType::BitAnd => parser.reduce::<70>(),
            TokenType::BitXor => parser.reduce::<70>(),
            TokenType::BitOr => parser.reduce::<70>(),
            TokenType::ShiftL => parser.reduce::<70>(),
            TokenType::ShiftR => parser.reduce::<70>(),
            TokenType::Eq => parser.reduce::<70>(),
            TokenType::Neq => parser.reduce::<70>(),
            TokenType::Leq => parser.reduce::<70>(),
            TokenType::Geq => parser.reduce::<70>(),
            TokenType::Less => parser.reduce::<70>(),
            TokenType::Greater => parser.reduce::<70>(),
            TokenType::LParen => parser.reduce::<70>(),
            TokenType::LSquare => parser.reduce::<70>(),
            TokenType::LCurly => parser.reduce::<70>(),
            TokenType::DoubleColon => parser.reduce::<70>(),
            TokenType::SemiColon => parser.reduce::<70>(),
            TokenType::Colon => parser.reduce::<70>(),
            TokenType::Dot => parser.reduce::<70>(),
            TokenType::Concat => parser.reduce::<70>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1441> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1453),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1442> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<55>(),
            TokenType::Break => parser.reduce::<55>(),
            TokenType::Do => parser.reduce::<55>(),
            TokenType::Else => parser.reduce::<55>(),
            TokenType::Elseif => parser.reduce::<55>(),
            TokenType::End => parser.reduce::<55>(),
            TokenType::For => parser.reduce::<55>(),
            TokenType::Function => parser.reduce::<55>(),
            TokenType::Goto => parser.reduce::<55>(),
            TokenType::If => parser.reduce::<55>(),
            TokenType::Local => parser.reduce::<55>(),
            TokenType::Repeat => parser.reduce::<55>(),
            TokenType::Return => parser.reduce::<55>(),
            TokenType::While => parser.reduce::<55>(),
            TokenType::LParen => parser.reduce::<55>(),
            TokenType::DoubleColon => parser.reduce::<55>(),
            TokenType::SemiColon => parser.reduce::<55>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1443> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1455),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1444> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1454),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1445> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RParen => parser.shift(1457),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1446> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::RCurly => parser.shift(1456),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1447> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Do => parser.shift(1467),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1448> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<30>(),
            TokenType::Break => parser.reduce::<30>(),
            TokenType::Do => parser.reduce::<30>(),
            TokenType::Else => parser.reduce::<30>(),
            TokenType::Elseif => parser.reduce::<30>(),
            TokenType::End => parser.reduce::<30>(),
            TokenType::For => parser.reduce::<30>(),
            TokenType::Function => parser.reduce::<30>(),
            TokenType::Goto => parser.reduce::<30>(),
            TokenType::If => parser.reduce::<30>(),
            TokenType::Local => parser.reduce::<30>(),
            TokenType::Repeat => parser.reduce::<30>(),
            TokenType::Return => parser.reduce::<30>(),
            TokenType::While => parser.reduce::<30>(),
            TokenType::Assign => parser.reduce::<30>(),
            TokenType::LParen => parser.reduce::<30>(),
            TokenType::DoubleColon => parser.reduce::<30>(),
            TokenType::SemiColon => parser.reduce::<30>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1449> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<48>(),
            TokenType::String(_) => parser.reduce::<48>(),
            TokenType::And => parser.reduce::<48>(),
            TokenType::Break => parser.reduce::<48>(),
            TokenType::Do => parser.reduce::<48>(),
            TokenType::Else => parser.reduce::<48>(),
            TokenType::Elseif => parser.reduce::<48>(),
            TokenType::End => parser.reduce::<48>(),
            TokenType::For => parser.reduce::<48>(),
            TokenType::Function => parser.reduce::<48>(),
            TokenType::Goto => parser.reduce::<48>(),
            TokenType::If => parser.reduce::<48>(),
            TokenType::Local => parser.reduce::<48>(),
            TokenType::Or => parser.reduce::<48>(),
            TokenType::Repeat => parser.reduce::<48>(),
            TokenType::Return => parser.reduce::<48>(),
            TokenType::While => parser.reduce::<48>(),
            TokenType::Add => parser.reduce::<48>(),
            TokenType::Sub => parser.reduce::<48>(),
            TokenType::Mul => parser.reduce::<48>(),
            TokenType::Div => parser.reduce::<48>(),
            TokenType::Idiv => parser.reduce::<48>(),
            TokenType::Mod => parser.reduce::<48>(),
            TokenType::Pow => parser.reduce::<48>(),
            TokenType::BitAnd => parser.reduce::<48>(),
            TokenType::BitXor => parser.reduce::<48>(),
            TokenType::BitOr => parser.reduce::<48>(),
            TokenType::ShiftL => parser.reduce::<48>(),
            TokenType::ShiftR => parser.reduce::<48>(),
            TokenType::Eq => parser.reduce::<48>(),
            TokenType::Neq => parser.reduce::<48>(),
            TokenType::Leq => parser.reduce::<48>(),
            TokenType::Geq => parser.reduce::<48>(),
            TokenType::Less => parser.reduce::<48>(),
            TokenType::Greater => parser.reduce::<48>(),
            TokenType::LParen => parser.reduce::<48>(),
            TokenType::LSquare => parser.reduce::<48>(),
            TokenType::LCurly => parser.reduce::<48>(),
            TokenType::DoubleColon => parser.reduce::<48>(),
            TokenType::SemiColon => parser.reduce::<48>(),
            TokenType::Colon => parser.reduce::<48>(),
            TokenType::Dot => parser.reduce::<48>(),
            TokenType::Concat => parser.reduce::<48>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1450> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<72>(),
            TokenType::String(_) => parser.reduce::<72>(),
            TokenType::And => parser.reduce::<72>(),
            TokenType::Break => parser.reduce::<72>(),
            TokenType::Do => parser.reduce::<72>(),
            TokenType::Else => parser.reduce::<72>(),
            TokenType::Elseif => parser.reduce::<72>(),
            TokenType::End => parser.reduce::<72>(),
            TokenType::For => parser.reduce::<72>(),
            TokenType::Function => parser.reduce::<72>(),
            TokenType::Goto => parser.reduce::<72>(),
            TokenType::If => parser.reduce::<72>(),
            TokenType::Local => parser.reduce::<72>(),
            TokenType::Or => parser.reduce::<72>(),
            TokenType::Repeat => parser.reduce::<72>(),
            TokenType::Return => parser.reduce::<72>(),
            TokenType::While => parser.reduce::<72>(),
            TokenType::Add => parser.reduce::<72>(),
            TokenType::Sub => parser.reduce::<72>(),
            TokenType::Mul => parser.reduce::<72>(),
            TokenType::Div => parser.reduce::<72>(),
            TokenType::Idiv => parser.reduce::<72>(),
            TokenType::Mod => parser.reduce::<72>(),
            TokenType::Pow => parser.reduce::<72>(),
            TokenType::BitAnd => parser.reduce::<72>(),
            TokenType::BitXor => parser.reduce::<72>(),
            TokenType::BitOr => parser.reduce::<72>(),
            TokenType::ShiftL => parser.reduce::<72>(),
            TokenType::ShiftR => parser.reduce::<72>(),
            TokenType::Eq => parser.reduce::<72>(),
            TokenType::Neq => parser.reduce::<72>(),
            TokenType::Leq => parser.reduce::<72>(),
            TokenType::Geq => parser.reduce::<72>(),
            TokenType::Less => parser.reduce::<72>(),
            TokenType::Greater => parser.reduce::<72>(),
            TokenType::LParen => parser.reduce::<72>(),
            TokenType::LSquare => parser.reduce::<72>(),
            TokenType::LCurly => parser.reduce::<72>(),
            TokenType::DoubleColon => parser.reduce::<72>(),
            TokenType::SemiColon => parser.reduce::<72>(),
            TokenType::Colon => parser.reduce::<72>(),
            TokenType::Dot => parser.reduce::<72>(),
            TokenType::Concat => parser.reduce::<72>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1451> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<22>(),
            TokenType::Break => parser.reduce::<22>(),
            TokenType::Do => parser.reduce::<22>(),
            TokenType::Else => parser.reduce::<22>(),
            TokenType::Elseif => parser.reduce::<22>(),
            TokenType::End => parser.reduce::<22>(),
            TokenType::For => parser.reduce::<22>(),
            TokenType::Function => parser.reduce::<22>(),
            TokenType::Goto => parser.reduce::<22>(),
            TokenType::If => parser.reduce::<22>(),
            TokenType::Local => parser.reduce::<22>(),
            TokenType::Repeat => parser.reduce::<22>(),
            TokenType::Return => parser.reduce::<22>(),
            TokenType::While => parser.reduce::<22>(),
            TokenType::LParen => parser.reduce::<22>(),
            TokenType::DoubleColon => parser.reduce::<22>(),
            TokenType::SemiColon => parser.reduce::<22>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1452> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<19>(),
            TokenType::Break => parser.reduce::<19>(),
            TokenType::Do => parser.reduce::<19>(),
            TokenType::For => parser.reduce::<19>(),
            TokenType::Function => parser.reduce::<19>(),
            TokenType::Goto => parser.reduce::<19>(),
            TokenType::If => parser.reduce::<19>(),
            TokenType::Local => parser.reduce::<19>(),
            TokenType::Repeat => parser.reduce::<19>(),
            TokenType::Return => parser.reduce::<19>(),
            TokenType::While => parser.reduce::<19>(),
            TokenType::LParen => parser.reduce::<19>(),
            TokenType::DoubleColon => parser.reduce::<19>(),
            TokenType::SemiColon => parser.reduce::<19>(),
            TokenType::Eof => parser.reduce::<19>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1453> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1454> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::Until => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1455> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::Else => parser.reduce::<79>(),
            TokenType::Elseif => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1456> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<87>(),
            TokenType::String(_) => parser.reduce::<87>(),
            TokenType::And => parser.reduce::<87>(),
            TokenType::Break => parser.reduce::<87>(),
            TokenType::Do => parser.reduce::<87>(),
            TokenType::Else => parser.reduce::<87>(),
            TokenType::Elseif => parser.reduce::<87>(),
            TokenType::End => parser.reduce::<87>(),
            TokenType::For => parser.reduce::<87>(),
            TokenType::Function => parser.reduce::<87>(),
            TokenType::Goto => parser.reduce::<87>(),
            TokenType::If => parser.reduce::<87>(),
            TokenType::Local => parser.reduce::<87>(),
            TokenType::Or => parser.reduce::<87>(),
            TokenType::Repeat => parser.reduce::<87>(),
            TokenType::Return => parser.reduce::<87>(),
            TokenType::While => parser.reduce::<87>(),
            TokenType::Add => parser.reduce::<87>(),
            TokenType::Sub => parser.reduce::<87>(),
            TokenType::Mul => parser.reduce::<87>(),
            TokenType::Div => parser.reduce::<87>(),
            TokenType::Idiv => parser.reduce::<87>(),
            TokenType::Mod => parser.reduce::<87>(),
            TokenType::Pow => parser.reduce::<87>(),
            TokenType::BitAnd => parser.reduce::<87>(),
            TokenType::BitXor => parser.reduce::<87>(),
            TokenType::BitOr => parser.reduce::<87>(),
            TokenType::ShiftL => parser.reduce::<87>(),
            TokenType::ShiftR => parser.reduce::<87>(),
            TokenType::Eq => parser.reduce::<87>(),
            TokenType::Neq => parser.reduce::<87>(),
            TokenType::Leq => parser.reduce::<87>(),
            TokenType::Geq => parser.reduce::<87>(),
            TokenType::Less => parser.reduce::<87>(),
            TokenType::Greater => parser.reduce::<87>(),
            TokenType::LParen => parser.reduce::<87>(),
            TokenType::LSquare => parser.reduce::<87>(),
            TokenType::LCurly => parser.reduce::<87>(),
            TokenType::DoubleColon => parser.reduce::<87>(),
            TokenType::SemiColon => parser.reduce::<87>(),
            TokenType::Colon => parser.reduce::<87>(),
            TokenType::Dot => parser.reduce::<87>(),
            TokenType::Concat => parser.reduce::<87>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1457> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<73>(),
            TokenType::String(_) => parser.reduce::<73>(),
            TokenType::And => parser.reduce::<73>(),
            TokenType::Break => parser.reduce::<73>(),
            TokenType::Do => parser.reduce::<73>(),
            TokenType::Else => parser.reduce::<73>(),
            TokenType::Elseif => parser.reduce::<73>(),
            TokenType::End => parser.reduce::<73>(),
            TokenType::For => parser.reduce::<73>(),
            TokenType::Function => parser.reduce::<73>(),
            TokenType::Goto => parser.reduce::<73>(),
            TokenType::If => parser.reduce::<73>(),
            TokenType::Local => parser.reduce::<73>(),
            TokenType::Or => parser.reduce::<73>(),
            TokenType::Repeat => parser.reduce::<73>(),
            TokenType::Return => parser.reduce::<73>(),
            TokenType::While => parser.reduce::<73>(),
            TokenType::Add => parser.reduce::<73>(),
            TokenType::Sub => parser.reduce::<73>(),
            TokenType::Mul => parser.reduce::<73>(),
            TokenType::Div => parser.reduce::<73>(),
            TokenType::Idiv => parser.reduce::<73>(),
            TokenType::Mod => parser.reduce::<73>(),
            TokenType::Pow => parser.reduce::<73>(),
            TokenType::BitAnd => parser.reduce::<73>(),
            TokenType::BitXor => parser.reduce::<73>(),
            TokenType::BitOr => parser.reduce::<73>(),
            TokenType::ShiftL => parser.reduce::<73>(),
            TokenType::ShiftR => parser.reduce::<73>(),
            TokenType::Eq => parser.reduce::<73>(),
            TokenType::Neq => parser.reduce::<73>(),
            TokenType::Leq => parser.reduce::<73>(),
            TokenType::Geq => parser.reduce::<73>(),
            TokenType::Less => parser.reduce::<73>(),
            TokenType::Greater => parser.reduce::<73>(),
            TokenType::LParen => parser.reduce::<73>(),
            TokenType::LSquare => parser.reduce::<73>(),
            TokenType::LCurly => parser.reduce::<73>(),
            TokenType::DoubleColon => parser.reduce::<73>(),
            TokenType::SemiColon => parser.reduce::<73>(),
            TokenType::Colon => parser.reduce::<73>(),
            TokenType::Dot => parser.reduce::<73>(),
            TokenType::Concat => parser.reduce::<73>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1458> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1468),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1459> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1463),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1460> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1466),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1461> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1465),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1462> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1464),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1463> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<19>(),
            TokenType::Break => parser.reduce::<19>(),
            TokenType::Do => parser.reduce::<19>(),
            TokenType::End => parser.reduce::<19>(),
            TokenType::For => parser.reduce::<19>(),
            TokenType::Function => parser.reduce::<19>(),
            TokenType::Goto => parser.reduce::<19>(),
            TokenType::If => parser.reduce::<19>(),
            TokenType::Local => parser.reduce::<19>(),
            TokenType::Repeat => parser.reduce::<19>(),
            TokenType::Return => parser.reduce::<19>(),
            TokenType::While => parser.reduce::<19>(),
            TokenType::LParen => parser.reduce::<19>(),
            TokenType::DoubleColon => parser.reduce::<19>(),
            TokenType::SemiColon => parser.reduce::<19>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1464> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::Else => parser.reduce::<79>(),
            TokenType::Elseif => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1465> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::And => parser.reduce::<79>(),
            TokenType::Else => parser.reduce::<79>(),
            TokenType::Elseif => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Comma => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1466> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<19>(),
            TokenType::Break => parser.reduce::<19>(),
            TokenType::Do => parser.reduce::<19>(),
            TokenType::For => parser.reduce::<19>(),
            TokenType::Function => parser.reduce::<19>(),
            TokenType::Goto => parser.reduce::<19>(),
            TokenType::If => parser.reduce::<19>(),
            TokenType::Local => parser.reduce::<19>(),
            TokenType::Repeat => parser.reduce::<19>(),
            TokenType::Return => parser.reduce::<19>(),
            TokenType::Until => parser.reduce::<19>(),
            TokenType::While => parser.reduce::<19>(),
            TokenType::LParen => parser.reduce::<19>(),
            TokenType::DoubleColon => parser.reduce::<19>(),
            TokenType::SemiColon => parser.reduce::<19>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1467> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.shift(19),
            TokenType::Break => parser.shift(43),
            TokenType::Do => parser.shift(45),
            TokenType::End => parser.reduce::<2>(),
            TokenType::For => parser.shift(64),
            TokenType::Function => parser.shift(65),
            TokenType::Goto => parser.shift(67),
            TokenType::If => parser.shift(70),
            TokenType::Local => parser.shift(100),
            TokenType::Repeat => parser.shift(102),
            TokenType::Return => parser.reduce::<2>(),
            TokenType::While => parser.shift(105),
            TokenType::LParen => parser.shift(21),
            TokenType::DoubleColon => parser.shift(113),
            TokenType::SemiColon => parser.shift(109),
            TokenType::Block => parser.goto(1470),
            TokenType::BlockStat => parser.goto(27),
            TokenType::Stat => parser.goto(38),
            TokenType::Label => parser.goto(110),
            TokenType::Varlist => parser.goto(111),
            TokenType::Var => parser.goto(18),
            TokenType::Prefixexp => parser.goto(114),
            TokenType::Functioncall => parser.goto(112),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1468> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1469),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1469> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<79>(),
            TokenType::And => parser.reduce::<79>(),
            TokenType::Break => parser.reduce::<79>(),
            TokenType::Do => parser.reduce::<79>(),
            TokenType::Else => parser.reduce::<79>(),
            TokenType::Elseif => parser.reduce::<79>(),
            TokenType::End => parser.reduce::<79>(),
            TokenType::For => parser.reduce::<79>(),
            TokenType::Function => parser.reduce::<79>(),
            TokenType::Goto => parser.reduce::<79>(),
            TokenType::If => parser.reduce::<79>(),
            TokenType::Local => parser.reduce::<79>(),
            TokenType::Or => parser.reduce::<79>(),
            TokenType::Repeat => parser.reduce::<79>(),
            TokenType::Return => parser.reduce::<79>(),
            TokenType::While => parser.reduce::<79>(),
            TokenType::Add => parser.reduce::<79>(),
            TokenType::Sub => parser.reduce::<79>(),
            TokenType::Mul => parser.reduce::<79>(),
            TokenType::Div => parser.reduce::<79>(),
            TokenType::Idiv => parser.reduce::<79>(),
            TokenType::Mod => parser.reduce::<79>(),
            TokenType::Pow => parser.reduce::<79>(),
            TokenType::BitAnd => parser.reduce::<79>(),
            TokenType::BitXor => parser.reduce::<79>(),
            TokenType::BitOr => parser.reduce::<79>(),
            TokenType::ShiftL => parser.reduce::<79>(),
            TokenType::ShiftR => parser.reduce::<79>(),
            TokenType::Eq => parser.reduce::<79>(),
            TokenType::Neq => parser.reduce::<79>(),
            TokenType::Leq => parser.reduce::<79>(),
            TokenType::Geq => parser.reduce::<79>(),
            TokenType::Less => parser.reduce::<79>(),
            TokenType::Greater => parser.reduce::<79>(),
            TokenType::LParen => parser.reduce::<79>(),
            TokenType::DoubleColon => parser.reduce::<79>(),
            TokenType::SemiColon => parser.reduce::<79>(),
            TokenType::Concat => parser.reduce::<79>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1470> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::End => parser.shift(1471),
            _ => Self::unimplemented_lookahead(),
        }
    }
}

impl StateProcessor for State<1471> {
    fn process_state(parser: &mut Parser, lookahead: TokenType) -> Result<(), Error> {
        match lookahead {
            TokenType::Name(_) => parser.reduce::<19>(),
            TokenType::Break => parser.reduce::<19>(),
            TokenType::Do => parser.reduce::<19>(),
            TokenType::Else => parser.reduce::<19>(),
            TokenType::Elseif => parser.reduce::<19>(),
            TokenType::End => parser.reduce::<19>(),
            TokenType::For => parser.reduce::<19>(),
            TokenType::Function => parser.reduce::<19>(),
            TokenType::Goto => parser.reduce::<19>(),
            TokenType::If => parser.reduce::<19>(),
            TokenType::Local => parser.reduce::<19>(),
            TokenType::Repeat => parser.reduce::<19>(),
            TokenType::Return => parser.reduce::<19>(),
            TokenType::While => parser.reduce::<19>(),
            TokenType::LParen => parser.reduce::<19>(),
            TokenType::DoubleColon => parser.reduce::<19>(),
            TokenType::SemiColon => parser.reduce::<19>(),
            _ => Self::unimplemented_lookahead(),
        }
    }
}
